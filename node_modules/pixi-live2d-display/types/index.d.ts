// Generated by dts-bundle-generator v5.5.0

///<reference types="pixi.js"/>

import EventEmitter = PIXI.utils.EventEmitter;
import url = PIXI.utils.url;
import Renderer = PIXI.Renderer;
import Texture = PIXI.Texture;
import Container = PIXI.Container;
import InteractionManager = PIXI.InteractionManager;
import Matrix = PIXI.Matrix;
import ObservablePoint = PIXI.ObservablePoint;
import Point = PIXI.Point;
import Transform = PIXI.Transform;
import Ticker = PIXI.Ticker;

declare class Live2DModelWebGL {
	static loadModel(buffer: ArrayBuffer): Live2DModelWebGL;
	private constructor();
	drawParamWebGL: Live2DObfuscated.DrawParamWebGL;
	getModelContext(): Live2DObfuscated.ModelContext;
	/**
	 * @return The width of model's Live2D drawing canvas but NOT the html canvas element.
	 */
	getCanvasWidth(): number;
	/**
	 * @return The height of model's Live2D drawing canvas but NOT the html canvas element.
	 */
	getCanvasHeight(): number;
	setTexture(index: number, texture: WebGLTexture): void;
	setMatrix(matrix: ArrayLike<number>): void;
	setParamFloat(id: string | number, value: number, weight?: number): unknown;
	addToParamFloat(id: string | number, value: number, weight?: number): unknown;
	multParamFloat(id: string | number, value: number, weight?: number): unknown;
	setPartsOpacity(id: string | number, value: number): unknown;
	getPartsOpacity(id: string | number): number;
	getParamFloat(id: string | number): number;
	getParamIndex(id: string): number;
	getPartsDataIndex(id: string): number;
	getDrawDataIndex(id: string): number;
	getTransformedPoints(index: number): Float32Array;
	loadParam(): void;
	saveParam(): void;
	update(): void;
	draw(): void;
}
declare class AMotion {
	setFadeIn(time: number): unknown;
	setFadeOut(time: number): unknown;
	updateParam(model: Live2DModelWebGL, entry: Live2DObfuscated.MotionQueueEnt): void;
	updateParamExe(model: Live2DModelWebGL, time: DOMTimeStamp, weight: number, MotionQueueEnt: unknown): unknown;
}
declare class Live2DMotion extends AMotion {
	private constructor();
	static loadMotion(buffer: ArrayBuffer): Live2DMotion;
}
declare class MotionQueueManager {
	motions: unknown[];
	/**
	 * @return The size of internal motion arrays.
	 */
	startMotion(motion: AMotion, neverUsedArg?: boolean): number;
	stopAllMotions(): void;
	isFinished(): boolean;
	/**
	 * @return True if parameters are updated by any motion.
	 */
	updateParam(model: Live2DModelWebGL): boolean;
}
declare class PhysicsHair {
	static Src: {
		SRC_TO_X: string;
		SRC_TO_Y: string;
		SRC_TO_G_ANGLE: string;
	};
	static Target: {
		TARGET_FROM_ANGLE: string;
		TARGET_FROM_ANGLE_V: string;
	};
	setup(length: number, regist: number, mass: number): unknown;
	addSrcParam(type: string, id: string, scale: number, weight: number): unknown;
	addTargetParam(type: string, id: string, scale: number, weight: number): unknown;
	update(model: Live2DModelWebGL, time: DOMTimeStamp): unknown;
}
declare class DrawDataID {
	id: string;
}
/**
 * Members that have been obfuscated.
 */
export declare namespace Live2DObfuscated {
	class MotionQueueEnt {
		isFinished(): boolean;
	}
	class DrawParamWebGL {
		gl: WebGLRenderingContext;
		glno: number;
		firstDraw: boolean;
		culling: boolean;
		setGL(gl: WebGLRenderingContext): void;
	}
	class ModelContext {
		clipManager: ClipManager;
		/**
		 * This is basically `DrawData[]`, but not reliable since it's an obfuscated property.
		 * Always check the type before using it!
		 */
		_$aS?: unknown; // DrawData[]
		getDrawData(index: number): DrawData | null;
	}
	class IDrawData {
		getDrawDataID(): DrawDataID;
	}
	class DrawData extends IDrawData {
		getNumPoints?(): unknown;
		draw(aN: unknown, aK: unknown, aI: Unknown_aB): void;
	}
	class Unknown_aB {
		baseOpacity: number;
	}
	class ClipManager {
		curFrameNo: number;
		getMaskRenderTexture(): number;
		setupClip(modelContext: ModelContext, drawParam: DrawParamWebGL): void;
	}
}
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Proprietary Software license
 * that can be found at https://www.live2d.com/eula/live2d-proprietary-software-license-agreement_en.html.
 */
export declare namespace Live2DCubismCore {
	/** Cubism version identifier. */
	type csmVersion = number;
	/** moc3 version identifier. */
	type csmMocVersion = number;
	/** Log handler.
	 *
	 * @param message Null-terminated string message to log.
	 */
	interface csmLogFunction {
		(message: string): void;
	}
	/** Cubism version. */
	class Version {
		/**
		 * Queries Core version.
		 *
		 * @return Core version.
		 */
		static csmGetVersion(): csmVersion;
		/**
		 * Gets Moc file supported latest version.
		 *
		 * @return Moc file latest format version.
		 */
		static csmGetLatestMocVersion(): csmMocVersion;
		/**
		 * Gets Moc file format version.
		 *
		 * @param moc Moc
		 *
		 * @return csmMocVersion
		 */
		static csmGetMocVersion(moc: Moc): csmMocVersion;
		private constructor();
	}
	/** Cubism logging. */
	class Logging {
		private static logFunction;
		/**
		 * Sets log handler.
		 *
		 * @param handler  Handler to use.
		 */
		static csmSetLogFunction(handler: csmLogFunction): void;
		/**
		 * Queries log handler.
		 *
		 * @return Log handler.
		 */
		static csmGetLogFunction(): csmLogFunction;
		/**
		 * Wrap log function.
		 *
		 * @param messagePtr number
		 *
		 * @return string
		 */
		private static wrapLogFunction;
		private constructor();
	}
	/** Cubism moc. */
	class Moc {
		/** Creates [[Moc]] from [[ArrayBuffer]].
		 *
		 * @param buffer Array buffer
		 *
		 * @return [[Moc]] on success; [[null]] otherwise.
		 */
		static fromArrayBuffer(buffer: ArrayBuffer): Moc;
		/** Releases instance. */
		_release(): void;
		/** Native moc. */
		_ptr: number;
		/**
		 * Initializes instance.
		 *
		 * @param mocBytes Moc bytes.
		 */
		private constructor();
	}
	/** Cubism model. */
	class Model {
		/** Parameters. */
		parameters: Parameters;
		/** Parts. */
		parts: Parts;
		/** Drawables. */
		drawables: Drawables;
		/** Canvas information. */
		canvasinfo: CanvasInfo;
		/**
		 * Creates [[Model]] from [[Moc]].
		 *
		 * @param moc Moc
		 *
		 * @return [[Model]] on success; [[null]] otherwise.
		 */
		static fromMoc(moc: Moc): Model;
		/** Updates instance. */
		update(): void;
		/** Releases instance. */
		release(): void;
		/** Native model. */
		_ptr: number;
		/**
		 * Initializes instance.
		 *
		 * @param moc Moc
		 */
		private constructor();
	}
	/** Canvas information interface. */
	class CanvasInfo {
		/** Width of native model canvas. */
		CanvasWidth: number;
		/** Height of native model canvas. */
		CanvasHeight: number;
		/** Coordinate origin of X axis. */
		CanvasOriginX: number;
		/** Coordinate origin of Y axis. */
		CanvasOriginY: number;
		/** Pixels per unit of native model. */
		PixelsPerUnit: number;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model pointer.
		 */
		constructor(modelPtr: number);
	}
	/** Cubism model parameters */
	class Parameters {
		/** Parameter count. */
		count: number;
		/** Parameter IDs. */
		ids: Array<string>;
		/** Minimum parameter values. */
		minimumValues: Float32Array;
		/** Maximum parameter values. */
		maximumValues: Float32Array;
		/** Default parameter values. */
		defaultValues: Float32Array;
		/** Parameter values. */
		values: Float32Array;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
		constructor(modelPtr: number);
	}
	/** Cubism model parts */
	class Parts {
		/** Part count. */
		count: number;
		/** Part IDs. */
		ids: Array<string>;
		/** Opacity values. */
		opacities: Float32Array;
		/** Part's parent part indices. */
		parentIndices: Int32Array;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
		constructor(modelPtr: number);
	}
	/** Cubism model drawables */
	class Drawables {
		/** Drawable count. */
		count: number;
		/** Drawable IDs. */
		ids: Array<string>;
		/** Constant drawable flags. */
		constantFlags: Uint8Array;
		/** Dynamic drawable flags. */
		dynamicFlags: Uint8Array;
		/** Drawable texture indices. */
		textureIndices: Int32Array;
		/** Drawable draw orders. */
		drawOrders: Int32Array;
		/** Drawable render orders. */
		renderOrders: Int32Array;
		/** Drawable opacities. */
		opacities: Float32Array;
		/** Mask count for each drawable. */
		maskCounts: Int32Array;
		/** Masks for each drawable. */
		masks: Array<Int32Array>;
		/** Number of vertices of each drawable. */
		vertexCounts: Int32Array;
		/** 2D vertex position data of each drawable. */
		vertexPositions: Array<Float32Array>;
		/** 2D texture coordinate data of each drawables. */
		vertexUvs: Array<Float32Array>;
		/** Number of triangle indices for each drawable. */
		indexCounts: Int32Array;
		/** Triangle index data for each drawable. */
		indices: Array<Uint16Array>;
		/** Resets all dynamic drawable flags.. */
		resetDynamicFlags(): void;
		/** Native model. */
		private _modelPtr;
		/**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
		constructor(modelPtr: number);
	}
	/** Utility functions. */
	class Utils {
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasBlendAdditiveBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasBlendMultiplicativeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasIsDoubleSidedBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasIsInvertedMaskBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasIsVisibleBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasVisibilityDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasOpacityDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasDrawOrderDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasRenderOrderDidChangeBit(bitfield: number): boolean;
		/**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
		static hasVertexPositionsDidChangeBit(bitfield: number): boolean;
	}
	/** Emscripten Cubism Core module. */
}
export declare namespace CubismSpec {
	export interface ModelJSON {
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Relative paths from the model3.json to other files.
		 */
		FileReferences: {
			/**
			 * Relative path to the moc3 file.
			 */
			Moc: string;
			/**
			 * Relative paths to the textures.
			 */
			Textures: string[];
			/**
			 * [Optional] Relative path to the physics3.json file.
			 */
			Physics?: string;
			/**
			 * [Optional] Relative path to the userdata3.json file.
			 */
			UserData?: string;
			/**
			 * [Optional] Relative path to the pose3.json file.
			 */
			Pose?: string;
			/**
			 * [Optional] Relative path to the cdi3.json file.
			 */
			DisplayInfo?: string;
			/**
			 * [Optional] Relative path to the exp3.json file.
			 */
			Expressions?: Expression[];
			/**
			 * [Optional] Relative path to the motion3.json file.
			 */
			Motions?: {
				/**
				 * This interface was referenced by `undefined`'s JSON-Schema definition
				 * via the `patternProperty` ".+".
				 */
				[k: string]: Motion[];
			};
		};
		/**
		 * [Optional] groups.
		 */
		Groups?: Group[];
		/**
		 * [Optional]Collision detection
		 */
		HitAreas?: HitArea[];
		/**
		 * [Optional]Layout
		 */
		Layout?: {
			Width?: number;
			Height?: number;
			X?: number;
			Y?: number;
			CenterX?: number;
			CenterY?: number;
		};
	}
	/**
	 * Motion.
	 */
	export interface Motion {
		/**
		 * File name.
		 */
		File: string;
		/**
		 * [Optional] Time of the Fade-out for motion easing in seconds.
		 */
		FadeOutTime?: number;
		/**
		 * [Optional] Time of the Fade-In for motion easing in seconds..
		 */
		FadeInTime?: number;
		/**
		 * [Optional] Audio files playback with motion.
		 */
		Sound?: string;
	}
	/**
	 * Group entry.
	 */
	export interface Group {
		/**
		 * Target of group.
		 */
		Target: {
			[k: string]: unknown;
		};
		/**
		 * Unique name of group.
		 */
		Name: string;
		/**
		 * IDs for mapping to target.
		 */
		Ids: string[];
	}
	/**
	 * Collision detection.
	 */
	export interface HitArea {
		/**
		 * Unique name of group.
		 */
		Name: string;
		/**
		 * IDs for mapping to target.
		 */
		Id: string;
	}
	export interface Expression {
		Name: string;
		File: string;
	}
	export interface MotionJSON {
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Additional data describing the motion.
		 */
		Meta: {
			/**
			 * Duration of the motion in seconds.
			 */
			Duration: number;
			/**
			 * Framerate of the motion in seconds.
			 */
			Fps: number;
			/**
			 * [Optional] Status of the looping of the motion.
			 */
			Loop?: boolean;
			/**
			 * [Optional] Status of the restriction of Bezier handles'X translations.
			 */
			AreBeziersRestricted?: boolean;
			/**
			 * [Optional] Time of the overall Fade-In for easing in seconds.
			 */
			FadeInTime?: number;
			/**
			 * [Optional] Time of the overall Fade-Out for easing in seconds.
			 */
			FadeOutTime?: number;
			/**
			 * The total number of curves.
			 */
			CurveCount: number;
			/**
			 * The total number of segments (from all curves).
			 */
			TotalSegmentCount: number;
			/**
			 * The total number of points (from all segments of all curves).
			 */
			TotalPointCount: number;
			/**
			 * [Optional] The total number of UserData.
			 */
			UserDataCount?: number;
			/**
			 * [Optional] The total size of UserData in bytes.
			 */
			TotalUserDataSize?: number;
		};
		/**
		 * Motion curves.
		 */
		Curves: Curve[];
		/**
		 * [Optional] User data.
		 */
		UserData?: {
			/**
			 * Time in seconds.
			 */
			Time: number;
			/**
			 * Content of user data.
			 */
			Value: string;
		}[];
	}
	/**
	 * Single curve.
	 */
	export interface Curve {
		/**
		 * Target type.
		 */
		Target: string;
		/**
		 * Identifier for mapping curve to target.
		 */
		Id: string;
		/**
		 * [Optional] Time of the Fade-In for easing in seconds.
		 */
		FadeInTime?: number;
		/**
		 * [Optional] Time of the Fade-Out for easing in seconds.
		 */
		FadeOutTime?: number;
		/**
		 * Flattened segments.
		 */
		Segments: number[];
	}
	export interface ExpressionJSON {
		/**
		 * Json file format type.
		 */
		Type: "Live2D Expression";
		/**
		 * [Optional] Time of the Fade-In for easing in seconds.
		 */
		FadeInTime?: number;
		/**
		 * [Optional] Time of the Fade-Out for easing in seconds.
		 */
		FadeOutTime?: number;
		Parameters: {
			Id: string;
			Value: number;
			Blend?: "Add" | "Multiply" | "Overwrite";
		}[];
	}
	export interface PhysicsJSON {
		/**
		 * Physics Settings.
		 */
		PhysicsSettings: {
			/**
			 * Identifier for Physics settings(each model is different).
			 */
			Id: string;
			/**
			 * Input.
			 */
			Input: {
				/**
				 * Targeted parameter.
				 */
				Source: {
					/**
					 * Target type.
					 */
					Target: string;
					/**
					 * Parameter ID.
					 */
					Id: string;
				};
				/**
				 * Effectiveness:propotion of each type（0～100%）.
				 */
				Weight: number;
				/**
				 * Type X or Angle.
				 */
				Type: string;
				/**
				 * Reflect.
				 */
				Reflect: boolean;
			}[];
			/**
			 * Output.
			 */
			Output: {
				/**
				 * Targeted parameter.
				 */
				Destination: {
					/**
					 * Target type.
					 */
					Target: string;
					/**
					 * Parameter ID.
					 */
					Id: string;
				};
				/**
				 * Number（0 origin） of parent pendulum（Vertex）.
				 */
				VertexIndex: number;
				/**
				 * Scale
				 */
				Scale: number;
				/**
				 * Effectiveness:propotion of each type（0～100%）.
				 */
				Weight: number;
				/**
				 * Type X or Angle (Angle might be fixed)
				 */
				Type: string;
				/**
				 * Reflect
				 */
				Reflect: boolean;
			}[];
			/**
			 * Array of the pendulums
			 */
			Vertices: Vertex[];
			/**
			 * Parameter(input value normalized).
			 */
			Normalization: {
				/**
				 * Normalization value of position.
				 */
				Position: {
					/**
					 * Normalized minimum.
					 */
					Minimum: number;
					/**
					 * Center of the range of normalization.
					 */
					Default: number;
					/**
					 * Normalized maximum.
					 */
					Maximum: number;
				};
				/**
				 * Normalization value of angle.
				 */
				Angle: {
					/**
					 * Normalized minimum.
					 */
					Minimum: number;
					/**
					 * Center of the range of normalization.
					 */
					Default: number;
					/**
					 * Normalized maximum.
					 */
					Maximum: number;
				};
			};
		}[];
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Additional data describing the physics.
		 */
		Meta: {
			/**
			 * Number of physics settings.
			 */
			PhysicsSettingCount: number;
			/**
			 * Total number of input parameters.
			 */
			TotalInputCount: number;
			/**
			 * Total number of output parameters.
			 */
			TotalOutputCount: number;
			/**
			 * Total number of vertices.
			 */
			VertexCount: number;
			/**
			 * Settings of gravity and wind.
			 */
			EffectiveForces: {
				/**
				 * Gravity.
				 */
				Gravity: {
					X: number;
					Y: number;
				};
				/**
				 * Wind.
				 */
				Wind: {
					X: number;
					Y: number;
				};
			};
			/**
			 * List of names and identifiers of Physics setting.
			 */
			PhysicsDictionary: {
				/**
				 * Identifier for Physics settings(each model is different).
				 */
				Id: string;
				/**
				 * Name of Physics settings(group name).
				 */
				Name: string;
			}[];
		};
	}
	/**
	 * Single vertex.
	 */
	export interface Vertex {
		/**
		 * Default position.
		 */
		Position: {
			X: number;
			Y: number;
		};
		/**
		 * Shaking influence.
		 */
		Mobility: number;
		/**
		 * Reaction time.
		 */
		Delay: number;
		/**
		 * Overall acceleration.
		 */
		Acceleration: number;
		/**
		 * Radius of pendulum.
		 */
		Radius: number;
	}
	export interface PoseJSON {
		Type: "Live2D Pose";
		/**
		 * Time of the Fade-In for easing in seconds.
		 */
		FadeInTime?: number;
		/**
		 * List of the switching control groups.
		 */
		Groups: {
			/**
			 * Main switching Part ID.
			 */
			Id: string;
			/**
			 * List of the linked switching Part IDs.
			 */
			Link?: string[];
		}[][];
	}
	export interface UserDataJSON {
		/**
		 * Json file format version.
		 */
		Version: number;
		/**
		 * Additional data describing the user data.
		 */
		Meta: {
			/**
			 * The total number of UserData.
			 */
			UserDataCount: number;
			/**
			 * The total size of UserData in bytes.
			 */
			TotalUserDataSize: number;
		};
		/**
		 * User data.
		 */
		UserData: UserData[];
	}
	/**
	 * User data.
	 */
	export interface UserData {
		/**
		 * Target type.
		 */
		Target: string;
		/**
		 * Identifier for mapping to target.
		 */
		Id: string;
		/**
		 * Content of user data.
		 */
		Value: string;
	}
}
export declare namespace Cubism2Spec {
	interface ModelJSON {
		name?: string;
		// files
		model: string;
		pose?: string;
		physics?: string;
		textures: string[];
		// metadata
		layout?: Layout;
		hit_areas?: HitArea[];
		init_params?: InitParam[];
		init_opacities?: InitOpacity[];
		// motions
		expressions?: Expression[];
		motions?: Record<string, Motion[]>;
	}
	interface Layout {
		width?: number;
		height?: number;
		x?: number;
		y?: number;
		center_x?: number;
		center_y?: number;
		top?: number;
		bottom?: number;
		left?: number;
		right?: number;
	}
	interface Motion {
		/** `*.mtn` file. */
		file: string;
		/** Sound file. */
		sound?: string;
		/** Motion fade-in timeout. */
		fade_in?: number;
		/** Motion fade-out timeout. */
		fade_out?: number;
	}
	interface Expression {
		name: string;
		/** `*.json` file. */
		file: string;
	}
	interface HitArea {
		name: string;
		id: string;
	}
	interface InitParam {
		id: string;
		value: number;
	}
	interface InitOpacity {
		id: string;
		value: number;
	}
	interface ExpressionJSON {
		fade_in?: number;
		fade_out?: number;
		params?: {
			id: string;
			val: number;
			def?: number;
			calc?: "set" | "add" | "mult";
		}[];
	}
	interface PhysicsJSON {
		physics_hair?: {
			"comment": string;
			"setup": {
				"length": number;
				"regist": number;
				"mass": number;
			};
			"src": {
				"id": string;
				"ptype": "x" | "y" | "angle";
				"scale": number;
				"weight": number;
			}[];
			"targets": {
				"id": string;
				"ptype": "x" | "y" | "angle";
				"scale": number;
				"weight": number;
			}[];
		}[];
	}
	interface PoseJSON {
		"parts_visible": {
			group: {
				id: string;
				link?: string[];
			}[];
		}[];
	}
}
export type JSONObject = object;
export declare const LOGICAL_WIDTH = 2;
export declare const LOGICAL_HEIGHT = 2;
/**
 * Parses, and provides access to the settings JSON.
 */
export declare abstract class ModelSettings {
	json: JSONObject;
	/**
	 * The model's name, typically used for displaying or logging. By default it's inferred from
	 * the URL by taking the folder name (the second to last component). In Cubism 2 it'll be overwritten
	 * by the `name` field of settings JSON.
	 */
	name: string;
	/**
	 * URL of the model settings file, used to resolve paths of the resource files defined in settings.
	 * This typically ends with `.model.json` in Cubism 2 and `.model3.json` in Cubism 4.
	 */
	url: string;
	/**
	 * Relative path of he moc file, typically ends with `.moc` in Cubism 2 and `.moc3` in Cubism 4.
	 */
	abstract moc: string;
	/**
	 * Relative paths of the texture images.
	 */
	abstract textures: string[];
	/**
	 * Relative path of the pose file.
	 */
	pose?: string;
	/**
	 * Relative path of the physics file.
	 */
	physics?: string;
	/**
	 * @param json - The settings JSON object.
	 * @param json.url - The `url` field must be defined to specify the settings file's URL.
	 */
	protected constructor(json: JSONObject & {
		url: string;
	});
	/**
	 * Resolves a relative path using the {@link url}. This is used to resolve the resource files
	 * defined in the settings.
	 * @param path - Relative path.
	 * @return Resolved path.
	 */
	resolveURL(path: string): string;
	/**
	 * Replaces the resource files by running each file through the `replacer`.
	 * @param replacer - Invoked with two arguments: `(file, path)`, where `file` is the file definition,
	 * and `path` is its property path in the ModelSettings instance. A string must be returned to be the replacement.
	 *
	 * ```js
	 * modelSettings.replaceFiles((file, path) => {
	 *     // file = "foo.moc", path = "moc"
	 *     // file = "foo.png", path = "textures[0]"
	 *     // file = "foo.mtn", path = "motions.idle[0].file"
	 *     // file = "foo.motion3.json", path = "motions.idle[0].File"
	 *
	 *     return "bar/" + file;
	 * });
	 * ```
	 */
	replaceFiles(replacer: (file: string, path: string) => string): void;
	/**
	 * Retrieves all resource files defined in the settings.
	 * @return A flat array of the paths of all resource files.
	 *
	 * ```js
	 * modelSettings.getDefinedFiles();
	 * // returns: ["foo.moc", "foo.png", ...]
	 * ```
	 */
	getDefinedFiles(): string[];
	/**
	 * Validates that the files defined in the settings exist in given files. Each file will be
	 * resolved by {@link resolveURL} before comparison.
	 * @param files - A flat array of file paths.
	 * @return All the files which are defined in the settings and also exist in given files,
	 * *including the optional files*.
	 * @throws Error if any *essential* file is defined in settings but not included in given files.
	 */
	validateFiles(files: string[]): string[];
}
/**
 * Indicates the motion priority.
 */
export declare enum MotionPriority {
	/** States that the model is currently not playing any motion. This priority cannot be applied to a motion. */
	NONE = 0,
	/** Low priority, used when starting idle motions automatically. */
	IDLE = 1,
	/** Medium priority. */
	NORMAL = 2,
	/** High priority. Motions as this priority will always be played regardless of the current priority. */
	FORCE = 3
}
/**
 * Handles the state of a MotionManager.
 */
export declare class MotionState {
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * When enabled, the states will be dumped to the logger when an exception occurs.
	 */
	debug: boolean;
	/**
	 * Priority of the current motion. Will be `MotionPriority.NONE` if there's no playing motion.
	 */
	currentPriority: MotionPriority;
	/**
	 * Priority of the reserved motion, which is still in loading and will be played once loaded.
	 * Will be `MotionPriority.NONE` if there's no reserved motion.
	 */
	reservePriority: MotionPriority;
	/**
	 * Group of current motion.
	 */
	currentGroup?: string;
	/**
	 * Index of current motion in its group.
	 */
	currentIndex?: number;
	/**
	 * Group of the reserved motion.
	 */
	reservedGroup?: string;
	/**
	 * Index of the reserved motion in its group.
	 */
	reservedIndex?: number;
	/**
	 * Group of the reserved idle motion.
	 */
	reservedIdleGroup?: string;
	/**
	 * Index of the reserved idle motion in its group.
	 */
	reservedIdleIndex?: number;
	/**
	 * Reserves the playback for a motion.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @return True if the reserving has succeeded.
	 */
	reserve(group: string, index: number, priority: MotionPriority): boolean;
	/**
	 * Requests the playback for a motion.
	 * @param motion - The Motion, can be undefined.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @return True if the request has been approved, i.e. the motion is allowed to play.
	 */
	start(motion: any, group: string, index: number, priority: MotionPriority): boolean;
	/**
	 * Notifies the motion playback has finished.
	 */
	complete(): void;
	/**
	 * Sets the current motion.
	 */
	setCurrent(group: string | undefined, index: number | undefined, priority: MotionPriority): void;
	/**
	 * Sets the reserved motion.
	 */
	setReserved(group: string | undefined, index: number | undefined, priority: MotionPriority): void;
	/**
	 * Sets the reserved idle motion.
	 */
	setReservedIdle(group: string | undefined, index: number | undefined): void;
	/**
	 * Checks if a Motion is currently playing or has reserved.
	 * @return True if active.
	 */
	isActive(group: string, index: number): boolean;
	/**
	 * Resets the state.
	 */
	reset(): void;
	/**
	 * Checks if an idle motion should be requests to play.
	 */
	shouldRequestIdleMotion(): boolean;
	/**
	 * Checks if the model's expression should be overridden by the motion.
	 */
	shouldOverrideExpression(): boolean;
	/**
	 * Dumps the state for debugging.
	 */
	dump(requestedGroup?: string, requestedIndex?: number): string;
}
export interface MotionManagerOptions {
	/**
	 * How to preload the motions.
	 * @default {@link MotionPreloadStrategy.NONE}
	 */
	motionPreload?: MotionPreloadStrategy;
	/**
	 * Specifies the idle motion group.
	 * @default "idle" in Cubism 2 and "Idle" in Cubism 4.
	 */
	idleMotionGroup?: string;
}
/**
 * Indicates how the motions will be preloaded.
 */
export declare enum MotionPreloadStrategy {
	/** Preload all the motions. */
	ALL = "ALL",
	/** Preload only the idle motions. */
	IDLE = "IDLE",
	/** No preload. */
	NONE = "NONE"
}
/**
 * Handles the motion playback.
 * @emits {@link MotionManagerEvents}
 */
export declare abstract class MotionManager<Motion = any, MotionSpec = any> extends EventEmitter {
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * Motion definitions copied from ModelSettings.
	 */
	abstract readonly definitions: Partial<Record<string, MotionSpec[]>>;
	/**
	 * Motion groups with particular internal usages. Currently there's only the `idle` field,
	 * which specifies the actual name of the idle motion group, so the idle motions
	 * can be correctly found from the settings JSON of various Cubism versions.
	 */
	abstract readonly groups: {
		idle: string;
	};
	/**
	 * Indicates the content type of the motion files, varies in different Cubism versions.
	 * This will be used as `xhr.responseType`.
	 */
	abstract readonly motionDataType: "json" | "arraybuffer";
	/**
	 * Can be undefined if the settings defines no expression.
	 */
	abstract expressionManager?: ExpressionManager;
	/**
	 * The ModelSettings reference.
	 */
	readonly settings: ModelSettings;
	/**
	 * The Motions. The structure is the same as {@link definitions}, initially each group contains
	 * an empty array, which means all motions will be `undefined`. When a Motion has been loaded,
	 * it'll fill the place in which it should be; when it fails to load, the place will be filled
	 * with `null`.
	 */
	motionGroups: Partial<Record<string, (Motion | undefined | null)[]>>;
	/**
	 * Maintains the state of this MotionManager.
	 */
	state: MotionState;
	/**
	 * Audio element of the current motion if a sound file is defined with it.
	 */
	currentAudio?: HTMLAudioElement;
	/**
	 * Flags there's a motion playing.
	 */
	playing: boolean;
	/**
	 * Flags the instances has been destroyed.
	 */
	destroyed: boolean;
	protected constructor(settings: ModelSettings, options?: MotionManagerOptions);
	/**
	 * Should be called in the constructor of derived class.
	 */
	protected init(options?: MotionManagerOptions): void;
	/**
	 * Sets up motions from the definitions, and preloads them according to the preload strategy.
	 */
	protected setupMotions(options?: MotionManagerOptions): void;
	/**
	 * Loads a Motion in a motion group. Errors in this method will not be thrown,
	 * but be emitted with a "motionLoadError" event.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
	 * @emits {@link MotionManagerEvents.motionLoaded}
	 * @emits {@link MotionManagerEvents.motionLoadError}
	 */
	loadMotion(group: string, index: number): Promise<Motion | undefined>;
	/**
	 * Loads the Motion. Will be implemented by Live2DFactory.
	 * @ignore
	 */
	private _loadMotion;
	/**
	 * Starts a motion as given priority.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
	startMotion(group: string, index: number, priority?: MotionPriority): Promise<boolean>;
	/**
	 * Starts a random Motion as given priority.
	 * @param group - The motion group.
	 * @param priority - The priority to be applied.
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
	startRandomMotion(group: string, priority?: MotionPriority): Promise<boolean>;
	/**
	 * Stops all playing motions as well as the sound.
	 */
	stopAllMotions(): void;
	/**
	 * Updates parameters of the core model.
	 * @param model - The core model.
	 * @param now - Current time in milliseconds.
	 * @return True if the parameters have been actually updated.
	 */
	update(model: object, now: DOMHighResTimeStamp): boolean;
	/**
	 * Destroys the instance.
	 * @emits {@link MotionManagerEvents.destroy}
	 */
	destroy(): void;
	/**
	 * Checks if the motion playback has finished.
	 */
	abstract isFinished(): boolean;
	/**
	 * Creates a Motion from the data.
	 * @param data - Content of the motion file. The format must be consistent with {@link motionDataType}.
	 * @param group - The motion group.
	 * @param definition - The motion definition.
	 * @return The created Motion.
	 */
	abstract createMotion(data: ArrayBuffer | JSONObject, group: string, definition: MotionSpec): Motion;
	/**
	 * Retrieves the motion's file path by its definition.
	 * @return The file path extracted from given definition. Not resolved.
	 */
	abstract getMotionFile(definition: MotionSpec): string;
	/**
	 * Retrieves the motion's name by its definition.
	 * @return The motion's name.
	 */
	protected abstract getMotionName(definition: MotionSpec): string;
	/**
	 * Retrieves the motion's sound file by its definition.
	 * @return The motion's sound file, can be undefined.
	 */
	protected abstract getSoundFile(definition: MotionSpec): string | undefined;
	/**
	 * Starts the Motion.
	 */
	protected abstract _startMotion(motion: Motion, onFinish?: (motion: Motion) => void): number;
	/**
	 * Stops all playing motions.
	 */
	protected abstract _stopAllMotions(): void;
	/**
	 * Updates parameters of the core model.
	 * @param model - The core model.
	 * @param now - Current time in milliseconds.
	 * @return True if the parameters have been actually updated.
	 */
	protected abstract updateParameters(model: object, now: DOMHighResTimeStamp): boolean;
}
/**
 * Abstract expression manager.
 * @emits {@link ExpressionManagerEvents}
 */
export declare abstract class ExpressionManager<Expression = any, ExpressionSpec = any> extends EventEmitter {
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * Expression definitions copied from ModelSettings.
	 */
	abstract readonly definitions: ExpressionSpec[];
	/**
	 * The ModelSettings reference.
	 */
	readonly settings: ModelSettings;
	/**
	 * The Expressions. The structure is the same as {@link definitions}, initially there's only
	 * an empty array, which means all expressions will be `undefined`. When an Expression has
	 * been loaded, it'll fill the place in which it should be; when it fails to load,
	 * the place will be filled with `null`.
	 */
	expressions: (Expression | null | undefined)[];
	/**
	 * An empty Expression to reset all the expression parameters.
	 */
	defaultExpression: Expression;
	/**
	 * Current Expression. This will not be overwritten by the {@link defaultExpression}.
	 */
	currentExpression: Expression;
	/**
	 * The pending Expression.
	 */
	reserveExpressionIndex: number;
	/**
	 * Flags the instance has been destroyed.
	 */
	destroyed: boolean;
	protected constructor(settings: ModelSettings, options?: MotionManagerOptions);
	/**
	 * Should be called in the constructor of derived class.
	 */
	protected init(): void;
	/**
	 * Loads an Expression. Errors in this method will not be thrown,
	 * but be emitted with an "expressionLoadError" event.
	 * @param index - Index of the expression in definitions.
	 * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
	 * @emits {@link ExpressionManagerEvents.expressionLoaded}
	 * @emits {@link ExpressionManagerEvents.expressionLoadError}
	 */
	protected loadExpression(index: number): Promise<Expression | undefined>;
	/**
	 * Loads the Expression. Will be implemented by Live2DFactory.
	 * @ignore
	 */
	private _loadExpression;
	/**
	 * Sets a random Expression that differs from current one.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
	setRandomExpression(): Promise<boolean>;
	/**
	 * Resets model's expression using {@link defaultExpression}.
	 */
	resetExpression(): void;
	/**
	 * Restores model's expression to {@link currentExpression}.
	 */
	restoreExpression(): void;
	/**
	 * Sets an Expression.
	 * @param index - Either the index, or the name of the expression.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
	setExpression(index: number | string): Promise<boolean>;
	/**
	 * Updates parameters of the core model.
	 * @return True if the parameters are actually updated.
	 */
	update(model: object, now: DOMHighResTimeStamp): boolean;
	/**
	 * Destroys the instance.
	 * @emits {@link ExpressionManagerEvents.destroy}
	 */
	destroy(): void;
	/**
	 * Checks if the expression playback has finished.
	 */
	abstract isFinished(): boolean;
	/**
	 * Retrieves the expression's index by its name.
	 * @return The index. `-1` if not found.
	 */
	abstract getExpressionIndex(name: string): number;
	/**
	 * Retrieves the expression's file path by its definition.
	 * @return The file path extracted from given definition. Not resolved.
	 */
	abstract getExpressionFile(definition: ExpressionSpec): string;
	/**
	 * Creates an Expression from the data.
	 * @param data - Content of the expression file.
	 * @param definition - The expression definition. Can be undefined when creating the {@link defaultExpression}.
	 * @return The created Expression.
	 */
	abstract createExpression(data: JSONObject, definition: ExpressionSpec | undefined): Expression;
	/**
	 * Applies the Expression to the model.
	 */
	protected abstract _setExpression(motion: Expression): number;
	/**
	 * Cancels expression playback.
	 */
	protected abstract stopAllExpressions(): void;
	/**
	 * Updates parameters of the core model.
	 * @return True if the parameters are actually updated.
	 */
	protected abstract updateParameters(model: object, now: DOMHighResTimeStamp): boolean;
}
/**
 * Interpolates the transition of focus position.
 */
export declare class FocusController {
	/** The focus position. */
	targetX: number;
	/** The focus position. */
	targetY: number;
	/** Current position. */
	x: number;
	/** Current position. */
	y: number;
	/** Current velocity. */
	vx: number;
	/** Current velocity. */
	vy: number;
	/**
	 * Sets the focus position.
	 * @param x - X position in range `[-1, 1]`.
	 * @param y - Y position in range `[-1, 1]`.
	 * @param instant - Should the focus position be instantly applied.
	 */
	focus(x: number, y: number, instant?: boolean): void;
	/**
	 * Updates the interpolation.
	 * @param dt - Delta time in milliseconds.
	 */
	update(dt: DOMHighResTimeStamp): void;
}
/**
 * Manages all the sounds.
 */
export declare class SoundManager {
	/**
	 * Audio elements playing or pending to play. Finished audios will be removed automatically.
	 */
	static audios: HTMLAudioElement[];
	protected static _volume: number;
	/**
	 * Global volume that applies to all the sounds.
	 */
	static get volume(): number;
	static set volume(value: number);
	/**
	 * Creates an audio element and adds it to the {@link audios}.
	 * @param file - URL of the sound file.
	 * @param onFinish - Callback invoked when the playback has finished.
	 * @param onError - Callback invoked when error occurs.
	 * @return Created audio element.
	 */
	static add(file: string, onFinish?: () => void, onError?: (e: Error) => void): HTMLAudioElement;
	/**
	 * Plays the sound.
	 * @param audio - An audio element.
	 * @return Promise that resolves when the audio is ready to play, rejects when error occurs.
	 */
	static play(audio: HTMLAudioElement): Promise<void>;
	/**
	 * Disposes an audio element and removes it from {@link audios}.
	 * @param audio - An audio element.
	 */
	static dispose(audio: HTMLAudioElement): void;
	/**
	 * Destroys all managed audios.
	 */
	static destroy(): void;
}
/**
 * Common layout definition shared between all Cubism versions.
 */
export interface CommonLayout {
	centerX?: number;
	centerY?: number;
	x?: number;
	y?: number;
	width?: number;
	height?: number;
	top?: number;
	bottom?: number;
	left?: number;
	right?: number;
}
/**
 * Common hit area definition shared between all Cubism versions.
 */
export interface CommonHitArea {
	id: string;
	name: string;
	index: number;
}
export interface Bounds {
	x: number;
	y: number;
	width: number;
	height: number;
}
export interface InternalModelOptions extends MotionManagerOptions {
}
/**
 * A wrapper that manages the states of a Live2D core model, and delegates all operations to it.
 * @emits {@link InternalModelEvents}
 */
export declare abstract class InternalModel extends EventEmitter {
	/**
	 * The managed Live2D core model.
	 */
	abstract readonly coreModel: object;
	abstract readonly settings: ModelSettings;
	focusController: FocusController;
	abstract motionManager: MotionManager;
	pose?: any;
	physics?: any;
	/**
	 * Original canvas width of the model. Note this doesn't represent the model's real size,
	 * as the model can overflow from its canvas.
	 */
	readonly originalWidth: number;
	/**
	 * Original canvas height of the model. Note this doesn't represent the model's real size,
	 * as the model can overflow from its canvas.
	 */
	readonly originalHeight: number;
	/**
	 * Canvas width of the model, scaled by the `width` of the model's layout.
	 */
	readonly width: number;
	/**
	 * Canvas height of the model, scaled by the `height` of the model's layout.
	 */
	readonly height: number;
	/**
	 * Local transformation, calculated from the model's layout.
	 */
	localTransform: Matrix;
	/**
	 * The final matrix to draw the model.
	 */
	drawingMatrix: Matrix;
	/**
	 * The hit area definitions, keyed by their names.
	 */
	hitAreas: Record<string, CommonHitArea>;
	/**
	 * Flags whether `gl.UNPACK_FLIP_Y_WEBGL` should be enabled when binding the textures.
	 */
	textureFlipY: boolean;
	/**
	 * WebGL viewport when drawing the model. The format is `[x, y, width, height]`.
	 */
	viewport: [
		number,
		number,
		number,
		number
	];
	/**
	 * Flags this instance has been destroyed.
	 */
	destroyed: boolean;
	/**
	 * Should be called in the constructor of derived class.
	 */
	protected init(): void;
	/**
	 * Sets up the model's size and local transform by the model's layout.
	 */
	protected setupLayout(): void;
	/**
	 * Sets up the hit areas by their definitions in settings.
	 */
	protected setupHitAreas(): void;
	/**
	 * Hit-test on the model.
	 * @param x - Position in model canvas.
	 * @param y - Position in model canvas.
	 * @return The names of the *hit* hit areas. Can be empty if none is hit.
	 */
	hitTest(x: number, y: number): string[];
	/**
	 * Hit-test for a single hit area.
	 * @param hitAreaName - The hit area's name.
	 * @param x - Position in model canvas.
	 * @param y - Position in model canvas.
	 * @return True if hit.
	 */
	isHit(hitAreaName: string, x: number, y: number): boolean;
	/**
	 * Gets a drawable's bounds.
	 * @param index - Index of the drawable.
	 * @param bounds - Object to store the output values.
	 * @return The bounds in model canvas space.
	 */
	getDrawableBounds(index: number, bounds?: Bounds): Bounds;
	/**
	 * Updates the model's transform.
	 * @param transform - The world transform.
	 */
	updateTransform(transform: Matrix): void;
	/**
	 * Updates the model's parameters.
	 * @param dt - Elapsed time in milliseconds from last frame.
	 * @param now - Current time in milliseconds.
	 */
	update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	/**
	 * Destroys the model and all related resources.
	 * @emits {@link InternalModelEvents.destroy | destroy}
	 */
	destroy(): void;
	/**
	 * Gets all the hit area definitions.
	 * @return Normalized definitions.
	 */
	protected abstract getHitAreaDefs(): CommonHitArea[];
	/**
	 * Gets the model's original canvas size.
	 * @return `[width, height]`
	 */
	protected abstract getSize(): [
		number,
		number
	];
	/**
	 * Gets the layout definition.
	 * @return Normalized definition.
	 */
	protected abstract getLayout(): CommonLayout;
	/**
	 * Gets all the drawables' IDs.
	 * @return IDs.
	 */
	abstract getDrawableIDs(): string[];
	/**
	 * Finds the index of a drawable by its ID.
	 * @return The index.
	 */
	abstract getDrawableIndex(id: string): number;
	/**
	 * Gets a drawable's vertices.
	 * @param index - Either the index or the ID of the drawable.
	 * @throws Error when the drawable cannot be found.
	 */
	abstract getDrawableVertices(index: number | string): Float32Array;
	/**
	 * Updates WebGL context bound to this model.
	 * @param gl - WebGL context.
	 * @param glContextID - Unique ID for given WebGL context.
	 */
	abstract updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void;
	/**
	 * Binds a texture to the model. The index must be the same as that of this texture
	 * in the {@link ModelSettings.textures} array.
	 */
	abstract bindTexture(index: number, texture: WebGLTexture): void;
	/**
	 * Draws the model.
	 */
	abstract draw(gl: WebGLRenderingContext): void;
}
export declare type Middleware<T> = (context: T, next: (err?: any) => Promise<void>) => Promise<void>;
export interface Live2DFactoryOptions extends Live2DModelOptions {
	/**
	 * String to use for crossOrigin properties on `<img>` elements when loading textures.
	 * @default undefined
	 */
	crossOrigin?: string;
	/**
	 * Callback invokes when the model has been loaded.
	 * @default undefined
	 */
	onLoad?(): void;
	/**
	 * Callback invokes when error occurs while loading the model.
	 * @default undefined
	 */
	onError?(e: Error): void;
}
/**
 * The context transferred through the model creation middlewares.
 */
export interface Live2DFactoryContext {
	source: any;
	options: Live2DFactoryOptions;
	live2dModel: Live2DModel;
	internalModel?: InternalModel;
	settings?: ModelSettings;
}
/**
 * Represents a Cubism version.
 */
export interface Live2DRuntime {
	/**
	 * The version number. Higher version takes priority when matching the runtime.
	 */
	version: number;
	/**
	 * Checks if the source belongs to this runtime.
	 * @param source - Either a settings JSON object or a ModelSettings instance.
	 * @return True if the source belongs to this runtime.
	 */
	test(source: any): boolean;
	ready(): Promise<void>;
	/**
	 * Checks if the data is a valid moc to create the core model.
	 * @param modelData - The moc content.
	 * @return True if the data is valid.
	 */
	isValidMoc(modelData: ArrayBuffer): boolean;
	/**
	 * Creates a ModelSettings.
	 * @param json - The settings JSON object.
	 * @return Created ModelSettings.
	 */
	createModelSettings(json: JSONObject): ModelSettings;
	/**
	 * Creates a core model.
	 * @param data - Content of the moc file.
	 * @return Created core model.
	 */
	createCoreModel(data: ArrayBuffer): any;
	/**
	 * Creates an InternalModel.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param settings - ModelSettings of this model.
	 * @param options - Options that will be passed to the InternalModel's constructor.
	 * @return Created InternalModel.
	 */
	createInternalModel(coreModel: any, settings: ModelSettings, options?: Live2DFactoryOptions): InternalModel;
	/**
	 * Creates a pose.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param data - Content of the pose file.
	 * @return Created pose.
	 */
	createPose(coreModel: any, data: any): any;
	/**
	 * Creates a physics.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param data - Content of the physics file.
	 * @return Created physics.
	 */
	createPhysics(coreModel: any, data: any): any;
}
/**
 * Handles all the network load tasks.
 *
 * - Model creation: requested by {@link Live2DModel.from}.
 * - Motion loading: implements the load method of MotionManager.
 * - Expression loading: implements the load method of ExpressionManager.
 */
export declare class Live2DFactory {
	/**
	 * All registered runtimes, sorted by versions in descending order.
	 */
	static runtimes: Live2DRuntime[];
	static urlToJSON: Middleware<Live2DFactoryContext>;
	static jsonToSettings: Middleware<Live2DFactoryContext>;
	static waitUntilReady: Middleware<Live2DFactoryContext>;
	static setupOptionals: Middleware<Live2DFactoryContext>;
	static setupEssentials: Middleware<Live2DFactoryContext>;
	static createInternalModel: Middleware<Live2DFactoryContext>;
	/**
	 * Middlewares to run through when setting up a Live2DModel.
	 */
	static live2DModelMiddlewares: Middleware<Live2DFactoryContext>[];
	/**
	 * load tasks of each motion. The structure of each value in this map
	 * is the same as respective {@link MotionManager.definitions}.
	 */
	static motionTasksMap: WeakMap<MotionManager<any, any>, Record<string, (Promise<any> | undefined)[]>>;
	/**
	 * Load tasks of each expression.
	 */
	static expressionTasksMap: WeakMap<ExpressionManager<any, any>, (Promise<any> | undefined)[]>;
	/**
	 * Registers a Live2DRuntime.
	 */
	static registerRuntime(runtime: Live2DRuntime): void;
	/**
	 * Finds a runtime that matches given source.
	 * @param source - Either a settings JSON object or a ModelSettings instance.
	 * @return The Live2DRuntime, or undefined if not found.
	 */
	static findRuntime(source: any): Live2DRuntime | undefined;
	/**
	 * Sets up a Live2DModel, populating it with all defined resources.
	 * @param live2dModel - The Live2DModel instance.
	 * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
	 * @param options - Options for the process.
	 * @return Promise that resolves when all resources have been loaded, rejects when error occurs.
	 */
	static setupLive2DModel<IM extends InternalModel>(live2dModel: Live2DModel<IM>, source: string | object | IM["settings"], options?: Live2DFactoryOptions): Promise<void>;
	/**
	 * Loads a Motion and registers the task to {@link motionTasksMap}. The task will be automatically
	 * canceled when its owner - the MotionManager instance - has been destroyed.
	 * @param motionManager - MotionManager that owns this Motion.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
	 */
	static loadMotion<Motion, MotionSpec>(motionManager: MotionManager<Motion, MotionSpec>, group: string, index: number): Promise<Motion | undefined>;
	/**
	 * Loads an Expression and registers the task to {@link expressionTasksMap}. The task will be automatically
	 * canceled when its owner - the ExpressionManager instance - has been destroyed.
	 * @param expressionManager - ExpressionManager that owns this Expression.
	 * @param index - Index of the Expression.
	 * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
	 */
	static loadExpression<Expression, ExpressionSpec>(expressionManager: ExpressionManager<Expression, ExpressionSpec>, index: number): Promise<Expression | undefined>;
	static releaseTasks(this: MotionManager | ExpressionManager): void;
}
/**
 * The interaction control split from Live2DModel class for code clarity. This mixin should *only*
 * be used on the Live2DModel.
 */
export declare class InteractionMixin {
	private _autoInteract;
	/**
	 * Enables automatic interaction. Only takes effect if Pixi's interaction
	 * feature has been enabled (by registering the `PIXI.InteractionManager` into `PIXI.Renderer`).
	 */
	get autoInteract(): boolean;
	set autoInteract(autoInteract: boolean);
	/**
	 * Local reference used to clean up the event listeners when destroying the model.
	 */
	interactionManager?: InteractionManager;
	/**
	 * Registers interaction by subscribing to the `PIXI.InteractionManager`.
	 */
	registerInteraction(this: Live2DModel, manager?: InteractionManager): void;
	/**
	 * Unregisters interaction.
	 */
	unregisterInteraction(this: Live2DModel): void;
}
/**
 * Useless class. May be useful in the future.
 */
export declare class Live2DTransform extends Transform {
}
export interface Live2DModelOptions extends MotionManagerOptions {
	/**
	 * Should the internal model be automatically updated by `PIXI.Ticker.shared`.
	 * @default ture
	 */
	autoUpdate?: boolean;
	/**
	 * Should the internal model automatically reacts to interactions by listening for pointer events.
	 * @see {@link InteractionMixin}
	 * @default true
	 */
	autoInteract?: boolean;
}
export interface Live2DModel<IM extends InternalModel = InternalModel> extends InteractionMixin {
}
export declare type Live2DConstructor = {
	new (options?: Live2DModelOptions): Live2DModel;
};
/**
 * A wrapper that allows the Live2D model to be used as a DisplayObject in PixiJS.
 *
 * ```js
 * const model = await Live2DModel.from('shizuku.model.json');
 * container.add(model);
 * ```
 * @emits {@link Live2DModelEvents}
 */
export declare class Live2DModel<IM extends InternalModel = InternalModel> extends Container {
	/**
	 * Creates a Live2DModel from given source.
	 * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
	 * @param options - Options for the creation.
	 * @return Promise that resolves with the Live2DModel.
	 */
	static from<M extends Live2DConstructor = typeof Live2DModel>(this: M, source: string | JSONObject | ModelSettings, options?: Live2DFactoryOptions): Promise<InstanceType<M>>;
	/**
	 * Synchronous version of `Live2DModel.from()`. This method immediately returns a Live2DModel instance,
	 * whose resources have not been loaded. Therefore this model can't be manipulated or rendered
	 * until the "load" event has been emitted.
	 *
	 * ```js
	 * // no `await` here as it's not a Promise
	 * const model = Live2DModel.fromSync('shizuku.model.json');
	 *
	 * // these will cause errors!
	 * // app.stage.addChild(model);
	 * // model.motion('tap_body');
	 *
	 * model.once('load', () => {
	 *     // now it's safe
	 *     app.stage.addChild(model);
	 *     model.motion('tap_body');
	 * });
	 * ```
	 */
	static fromSync<M extends Live2DConstructor = typeof Live2DModel>(this: M, source: string | JSONObject | ModelSettings, options?: Live2DFactoryOptions): InstanceType<M>;
	/**
	 * Registers the class of `PIXI.Ticker` for auto updating.
	 */
	static registerTicker(tickerClass: typeof Ticker): void;
	/**
	 * Tag for logging.
	 */
	tag: string;
	/**
	 * The internal model. Though typed as non-nullable, it'll be undefined until the "ready" event is emitted.
	 */
	internalModel: IM;
	/**
	 * Pixi textures.
	 */
	textures: Texture[];
	/** @override */
	transform: Live2DTransform;
	/**
	 * The anchor behaves like the one in `PIXI.Sprite`, where `(0, 0)` means the top left
	 * and `(1, 1)` means the bottom right.
	 */
	anchor: ObservablePoint;
	/**
	 * An ID of Gl context that syncs with `renderer.CONTEXT_UID`. Used to check if the GL context has changed.
	 */
	protected glContextID: number;
	/**
	 * Elapsed time in milliseconds since created.
	 */
	elapsedTime: DOMHighResTimeStamp;
	/**
	 * Elapsed time in milliseconds from last frame to this frame.
	 */
	deltaTime: DOMHighResTimeStamp;
	protected _autoUpdate: boolean;
	/**
	 * Enables automatic updating. Requires {@link Live2DModel.registerTicker} or the global `window.PIXI.Ticker`.
	 */
	get autoUpdate(): boolean;
	set autoUpdate(autoUpdate: boolean);
	constructor(options?: Live2DModelOptions);
	/**
	 * A handler of the "modelLoaded" event, invoked when the internal model has been loaded.
	 */
	protected init(options?: Live2DModelOptions): void;
	/**
	 * A callback that observes {@link anchor}, invoked when the anchor's values have been changed.
	 */
	protected onAnchorChange(): void;
	/**
	 * Shorthand to start a motion.
	 * @param group - The motion group.
	 * @param index - The index in this group. If not presented, a random motion will be started.
	 * @param priority - The motion priority. Defaults to `MotionPriority.NORMAL`.
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
	motion(group: string, index?: number, priority?: MotionPriority): Promise<boolean>;
	/**
	 * Shorthand to set an expression.
	 * @param id - Either the index, or the name of the expression. If not presented, a random expression will be set.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
	expression(id?: number | string): Promise<boolean>;
	/**
	 * Updates the focus position. This will not cause the model to immediately look at the position,
	 * instead the movement will be interpolated.
	 * @param x - Position in world space.
	 * @param y - Position in world space.
	 * @param instant - Should the focus position be instantly applied.
	 */
	focus(x: number, y: number, instant?: boolean): void;
	/**
	 * Tap on the model. This will perform a hit-testing, and emit a "hit" event
	 * if at least one of the hit areas is hit.
	 * @param x - Position in world space.
	 * @param y - Position in world space.
	 * @emits {@link Live2DModelEvents.hit}
	 */
	tap(x: number, y: number): void;
	/**
	 * Hit-test on the model.
	 * @param x - Position in world space.
	 * @param y - Position in world space.
	 * @return The names of the *hit* hit areas. Can be empty if none is hit.
	 */
	hitTest(x: number, y: number): string[];
	/**
	 * Calculates the position in the canvas of original, unscaled Live2D model.
	 * @param position - A Point in world space.
	 * @param result - A Point to store the new value. Defaults to a new Point.
	 * @param skipUpdate - True to skip the update transform.
	 * @return The Point in model canvas space.
	 */
	toModelPosition(position: Point, result?: Point, skipUpdate?: boolean): Point;
	/**
	 * A method required by `PIXI.InteractionManager` to perform hit-testing.
	 * @param point - A Point in world space.
	 * @return True if the point is inside this model.
	 */
	containsPoint(point: Point): boolean;
	/** @override */
	protected _calculateBounds(): void;
	/**
	 * An update callback to be added to `PIXI.Ticker` and invoked every tick.
	 */
	onTickerUpdate(): void;
	/**
	 * Updates the model. Note this method just updates the timer,
	 * and the actual update will be done right before rendering the model.
	 * @param dt - The elapsed time in milliseconds since last frame.
	 */
	update(dt: DOMHighResTimeStamp): void;
	/** @override */
	protected _render(renderer: Renderer): void;
	/**
	 * Destroys the model and all related resources. This takes the same options and also
	 * behaves the same as `PIXI.Container#destroy`.
	 * @param options - Options parameter. A boolean will act as if all options
	 *  have been set to that value
	 * @param [options.children=false] - if set to true, all the children will have their destroy
	 *  method called as well. 'options' will be passed on to those calls.
	 * @param [options.texture=false] - Only used for child Sprites if options.children is set to true
	 *  Should it destroy the texture of the child sprite
	 * @param [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
	 *  Should it destroy the base texture of the child sprite
	 */
	destroy(options?: {
		children?: boolean;
		texture?: boolean;
		baseTexture?: boolean;
	}): void;
}
/**
 * Global configs.
 */
export declare namespace config {
	const LOG_LEVEL_VERBOSE = 0;
	const LOG_LEVEL_WARNING = 1;
	const LOG_LEVEL_ERROR = 2;
	const LOG_LEVEL_NONE = 999;
	/**
	 * Global log level.
	 * @default {@link LOG_LEVEL_WARNING}
	 */
	let logLevel: number;
	/**
	 * Enabling sound for motions.
	 */
	let sound: boolean;
	/**
	 * Deferring motion and corresponding sound until both are loaded.
	 */
	let motionSync: boolean;
	/**
	 * Default fading duration for motions without such value specified.
	 */
	let motionFadingDuration: number;
	/**
	 * Default fading duration for idle motions without such value specified.
	 */
	let idleMotionFadingDuration: number;
	/**
	 * Default fading duration for expressions without such value specified.
	 */
	let expressionFadingDuration: number;
	let cubism4: {
		/**
		 * Should masks support 4x4 division, which is unofficial and experimental.
		 * See [official manual](https://docs.live2d.com/cubism-sdk-manual/ow-sdk-mask-premake-web/?locale=en_us).
		 * @default true
		 */
		supportMoreMaskDivisions: boolean;
	} | undefined;
}
/**
 * Consistent with the `version` in package.json.
 */
export declare const VERSION: string;
export declare type Live2DLoaderTarget = Live2DModel | InternalModel | MotionManager | ExpressionManager;
/**
 * The context transferred through Live2DLoader middlewares.
 */
export interface Live2DLoaderContext {
	/** The XHR's response type. */
	type: XMLHttpRequestResponseType;
	/** Will be resolved by {@link ModelSettings.resolveURL} if a ModelSettings is provided. */
	url: string;
	/** If provided, the given URL will be resolved by {@link ModelSettings.resolveURL}. */
	settings?: ModelSettings;
	/**
	 * Owner of this resource. The load task will be automatically canceled
	 * when receiving an "destroy" event from the target.
	 */
	target?: Live2DLoaderTarget;
	/** Loaded data. */
	result?: any;
}
export declare class Live2DLoader {
	static middlewares: Middleware<Live2DLoaderContext>[];
	/**
	 * Loads a resource.
	 * @return Promise that resolves with the loaded data in a format that's consistent with the specified `type`.
	 */
	static load<T = any>(context: Live2DLoaderContext): Promise<T>;
}
/**
 * The basic XHR loader.
 *
 * A network error will be thrown with the following properties:
 * - `url` - The request URL.
 * - `status` - The HTTP status.
 * - `aborted` - True if the error is caused by aborting the XHR.
 */
export declare class XHRLoader {
	/**
	 * All the created XHRs, keyed by their owners respectively.
	 */
	static xhrMap: WeakMap<Live2DLoaderTarget, Set<XMLHttpRequest>>;
	/**
	 * All the created XHRs as a flat array.
	 */
	static allXhrSet: Set<XMLHttpRequest>;
	/**
	 * Middleware for Live2DLoader.
	 */
	static loader: Middleware<Live2DLoaderContext>;
	/**
	 * Creates a managed XHR.
	 * @param target - If provided, the XHR will be canceled when receiving an "destroy" event from the target.
	 * @param url - The URL.
	 * @param type - The XHR response type.
	 * @param onload - Load listener.
	 * @param onerror - Error handler.
	 */
	static createXHR<T = any>(target: Live2DLoaderTarget | undefined, url: string, type: XMLHttpRequestResponseType, onload: (data: T) => void, onerror: (e: Error) => void): XMLHttpRequest;
	/**
	 * Cancels all XHRs related to this target.
	 */
	static cancelXHRs(this: Live2DLoaderTarget): void;
	/**
	 * Release all XHRs.
	 */
	static release(): void;
}
export declare type ExtendedFileList = File[] & {
	settings?: ModelSettings;
};
/**
 * Experimental loader to load resources from uploaded files.
 *
 * This loader relies on
 * [webkitRelativePath](https://developer.mozilla.org/en-US/docs/Web/API/File/webkitRelativePath)
 * to recognize the file path.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
export declare class FileLoader {
	/**
	 * Stores all the object URLs of uploaded files.
	 */
	static filesMap: {
		[settingsFileURL: string]: {
			[resourceFileURL: string]: string;
		};
	};
	/**
	 * Resolves the path of a resource file to the object URL.
	 * @param settingsURL - Object URL of the settings file.
	 * @param filePath - Resource file path.
	 * @return Resolved object URL.
	 */
	static resolveURL(settingsURL: string, filePath: string): string;
	/**
	 * Middleware for Live2DFactory.
	 */
	static factory: Middleware<Live2DFactoryContext>;
	/**
	 * Consumes the files by storing their object URLs. Files not defined in the settings will be ignored.
	 */
	static upload(files: File[], settings: ModelSettings): Promise<void>;
	/**
	 * Creates a ModelSettings by given files.
	 * @return Promise that resolves with the created ModelSettings.
	 */
	static createSettings(files: File[]): Promise<ModelSettings>;
	/**
	 * Reads a file as text in UTF-8.
	 */
	static readText(file: File): Promise<string>;
}
export declare type ZipReader = any;
/**
 * Experimental loader to load resources from a zip file.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
export declare class ZipLoader {
	static ZIP_PROTOCOL: string;
	static uid: number;
	static factory: Middleware<Live2DFactoryContext>;
	static unzip(reader: ZipReader, settings: ModelSettings): Promise<File[]>;
	static createSettings(reader: ZipReader): Promise<ModelSettings>;
	static zipReader(data: Blob, url: string): Promise<ZipReader>;
	static getFilePaths(reader: ZipReader): Promise<string[]>;
	static getFiles(reader: ZipReader, paths: string[]): Promise<File[]>;
	static readText(reader: ZipReader, path: string): Promise<string>;
	static releaseReader(reader: ZipReader): void;
}
/**
 * A simple tagged logger.
 *
 * You can replace the methods with your own ones.
 *
 * ```js
 * import { logger } from 'pixi-live2d-display';
 *
 * logger.log = (tag, ...messages) => {
 *     console.log(tag, 'says:', ...messages);
 * };
 * ```
 */
export declare namespace logger {
	function log(tag: string, ...messages: any[]): void;
	function warn(tag: string, ...messages: any[]): void;
	function error(tag: string, ...messages: any[]): void;
}
/**
 * These functions can be slightly faster than the ones in Lodash.
 * @packageDocumentation
 */
export declare function clamp(num: number, lower: number, upper: number): number;
export declare function rand(min: number, max: number): number;
/**
 * Copies a property at only if it matches the `type`.
 * @param type - Type expected to match `typeof` on the property.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the property in source object.
 * @param toKey - Key of the property in destination object.
 */
export declare function copyProperty<From, FromKey extends keyof From, ToKey extends keyof any, To extends Partial<Record<ToKey, From[FromKey]>>>(type: string, from: From, to: To, fromKey: FromKey, toKey: ToKey): void;
/**
 * Copies an array at `key`, filtering the items that match the `type`.
 * @param type - Type expected to match `typeof` on the items.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the array property in source object.
 * @param toKey - Key of the array property in destination object.
 */
export declare function copyArray<FromKey extends keyof any, From extends Partial<Record<FromKey, any[]>>, ToKey extends keyof any, To extends Partial<Record<ToKey, any[]>>>(type: string, from: From, to: To, fromKey: FromKey, toKey: ToKey): void;
/**
 * @see {@link https://www.typescriptlang.org/docs/handbook/mixins.html}
 */
export declare function applyMixins(derivedCtor: any, baseCtors: any[]): void;
/**
 * Gets the name of parent folder in a url.
 * @param url - URL of a file.
 * @return Name of the parent folder, or the file itself if it has no parent folder.
 */
export declare function folderName(url: string): string;
declare interface Live2DMotion {
	onFinishHandler?(motion: this): void;
}
export declare class Cubism2ModelSettings extends ModelSettings {
	json: Cubism2Spec.ModelJSON;
	moc: string;
	textures: string[];
	pose?: string;
	physics?: string;
	layout?: Cubism2Spec.Layout;
	hitAreas?: Cubism2Spec.HitArea[];
	initParams?: Cubism2Spec.InitParam[];
	initOpacities?: Cubism2Spec.InitOpacity[];
	expressions?: Cubism2Spec.Expression[];
	motions: Record<string, Cubism2Spec.Motion[]>;
	/**
	 * Checks if a JSON object is valid model settings.
	 * @param json
	 */
	static isValidJSON(json: any): json is Cubism2Spec.ModelJSON;
	constructor(json: Cubism2Spec.ModelJSON & {
		url: string;
	});
	/**
	 * Validates and copies *optional* properties from raw JSON.
	 */
	protected copy(json: Cubism2Spec.ModelJSON): void;
	replaceFiles(replace: (file: string, path: string) => string): void;
}
export declare class Live2DExpression extends AMotion {
	readonly params: NonNullable<Cubism2Spec.ExpressionJSON["params"]>;
	constructor(json: Cubism2Spec.ExpressionJSON);
	/** @override */
	updateParamExe(model: Live2DModelWebGL, time: DOMTimeStamp, weight: number, motionQueueEnt: unknown): void;
}
export declare class Cubism2ExpressionManager extends ExpressionManager<Live2DExpression> {
	readonly queueManager: MotionQueueManager;
	readonly definitions: Cubism2Spec.Expression[];
	readonly settings: Cubism2ModelSettings;
	constructor(settings: Cubism2ModelSettings, options?: MotionManagerOptions);
	isFinished(): boolean;
	getExpressionIndex(name: string): number;
	getExpressionFile(definition: Cubism2Spec.Expression): string;
	createExpression(data: object, definition: Cubism2Spec.Expression | undefined): Live2DExpression;
	protected _setExpression(motion: Live2DExpression): number;
	protected stopAllExpressions(): void;
	protected updateParameters(model: Live2DModelWebGL, dt: number): boolean;
}
export declare class Cubism2MotionManager extends MotionManager<Live2DMotion, Cubism2Spec.Motion> {
	readonly definitions: Partial<Record<string, Cubism2Spec.Motion[]>>;
	readonly groups: {
		readonly idle: "idle";
	};
	readonly motionDataType = "arraybuffer";
	readonly queueManager: MotionQueueManager;
	readonly settings: Cubism2ModelSettings;
	expressionManager?: Cubism2ExpressionManager;
	constructor(settings: Cubism2ModelSettings, options?: MotionManagerOptions);
	protected init(options?: MotionManagerOptions): void;
	isFinished(): boolean;
	createMotion(data: ArrayBuffer, group: string, definition: Cubism2Spec.Motion): Live2DMotion;
	getMotionFile(definition: Cubism2Spec.Motion): string;
	protected getMotionName(definition: Cubism2Spec.Motion): string;
	protected getSoundFile(definition: Cubism2Spec.Motion): string | undefined;
	protected _startMotion(motion: Live2DMotion, onFinish?: (motion: Live2DMotion) => void): number;
	protected _stopAllMotions(): void;
	protected updateParameters(model: Live2DModelWebGL, now: DOMHighResTimeStamp): boolean;
	destroy(): void;
}
export declare const enum EyeState {
	Idle = 0,
	Closing = 1,
	Closed = 2,
	Opening = 3
}
export declare class Live2DEyeBlink {
	readonly coreModel: Live2DModelWebGL;
	leftParam: number;
	rightParam: number;
	blinkInterval: DOMHighResTimeStamp;
	closingDuration: DOMHighResTimeStamp;
	closedDuration: DOMHighResTimeStamp;
	openingDuration: DOMHighResTimeStamp;
	eyeState: EyeState;
	eyeParamValue: number;
	closedTimer: number;
	nextBlinkTimeLeft: number;
	constructor(coreModel: Live2DModelWebGL);
	setEyeParams(value: number): void;
	update(dt: DOMHighResTimeStamp): void;
}
export declare class Live2DPhysics {
	readonly coreModel: Live2DModelWebGL;
	physicsHairs: PhysicsHair[];
	constructor(coreModel: Live2DModelWebGL, json: Cubism2Spec.PhysicsJSON);
	update(elapsed: DOMHighResTimeStamp): void;
}
declare class Live2DPartsParam {
	readonly id: string;
	paramIndex: number;
	partsIndex: number;
	link: Live2DPartsParam[];
	constructor(id: string);
	initIndex(model: Live2DModelWebGL): void;
}
export declare class Live2DPose {
	readonly coreModel: Live2DModelWebGL;
	opacityAnimDuration: DOMHighResTimeStamp;
	partsGroups: Live2DPartsParam[][];
	constructor(coreModel: Live2DModelWebGL, json: Cubism2Spec.PoseJSON);
	init(): void;
	normalizePartsOpacityGroup(partsGroup: Live2DPartsParam[], dt: DOMHighResTimeStamp): void;
	copyOpacity(partsGroup: Live2DPartsParam[]): void;
	update(dt: DOMHighResTimeStamp): void;
}
export declare class Cubism2InternalModel extends InternalModel {
	settings: Cubism2ModelSettings;
	coreModel: Live2DModelWebGL;
	motionManager: Cubism2MotionManager;
	eyeBlink?: Live2DEyeBlink;
	physics?: Live2DPhysics;
	pose?: Live2DPose;
	eyeballXParamIndex: number;
	eyeballYParamIndex: number;
	angleXParamIndex: number;
	angleYParamIndex: number;
	angleZParamIndex: number;
	bodyAngleXParamIndex: number;
	breathParamIndex: number;
	textureFlipY: boolean;
	/**
	 * Number of the drawables in this model.
	 */
	drawDataCount: number;
	/**
	 * If true, the face culling will always be disabled when drawing the model,
	 * regardless of the model's internal flags.
	 */
	disableCulling: boolean;
	constructor(coreModel: Live2DModelWebGL, settings: Cubism2ModelSettings, options?: InternalModelOptions);
	protected init(): void;
	protected getSize(): [
		number,
		number
	];
	protected getLayout(): CommonLayout;
	updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void;
	bindTexture(index: number, texture: WebGLTexture): void;
	protected getHitAreaDefs(): CommonHitArea[];
	getDrawableIDs(): string[];
	getDrawableIndex(id: string): number;
	getDrawableVertices(drawIndex: number | string): Float32Array;
	update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	updateFocus(): void;
	updateNaturalMovements(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	draw(gl: WebGLRenderingContext): void;
	destroy(): void;
}
declare class CubismModelSettingsJson {
	constructor(json: CubismSpec.ModelJSON);
	getEyeBlinkParameters(): string[] | undefined;
	getLipSyncParameters(): string[] | undefined;
	groups?: CubismSpec.Group[];
	moc: string;
	expressions?: CubismSpec.Expression[];
	motions?: Record<string, CubismSpec.Motion[]>;
	textures: string[];
	physics?: string;
	pose?: string;
	hitAreas?: CubismSpec.HitArea[];
	layout?: CubismSpec.ModelJSON["Layout"];
}
export interface Cubism4ModelSettings extends CubismModelSettingsJson {
}
export declare class Cubism4ModelSettings extends ModelSettings {
	json: CubismSpec.ModelJSON;
	moc: string;
	textures: string[];
	static isValidJSON(json: any): json is CubismSpec.ModelJSON;
	constructor(json: CubismSpec.ModelJSON & {
		url: string;
	});
	replaceFiles(replace: (file: string, path: string) => string): void;
}
declare class CubismMatrix44 {
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * 受け取った２つの行列の乗算を行う。
	 *
	 * @param a 行列a
	 * @param b 行列b
	 * @return 乗算結果の行列
	 */
	static multiply(a: Float32Array, b: Float32Array, dst: Float32Array): void;
	/**
	 * 単位行列に初期化する
	 */
	loadIdentity(): void;
	/**
	 * 行列を設定
	 *
	 * @param tr 16個の浮動小数点数で表される4x4の行列
	 */
	setMatrix(tr: Float32Array): void;
	/**
	 * 行列を浮動小数点数の配列で取得
	 *
	 * @return 16個の浮動小数点数で表される4x4の行列
	 */
	getArray(): Float32Array;
	/**
	 * X軸の拡大率を取得
	 * @return X軸の拡大率
	 */
	getScaleX(): number;
	/**
	 * Y軸の拡大率を取得する
	 *
	 * @return Y軸の拡大率
	 */
	getScaleY(): number;
	/**
	 * X軸の移動量を取得
	 * @return X軸の移動量
	 */
	getTranslateX(): number;
	/**
	 * Y軸の移動量を取得
	 * @return Y軸の移動量
	 */
	getTranslateY(): number;
	/**
	 * X軸の値を現在の行列で計算
	 *
	 * @param src X軸の値
	 * @return 現在の行列で計算されたX軸の値
	 */
	transformX(src: number): number;
	/**
	 * Y軸の値を現在の行列で計算
	 *
	 * @param src Y軸の値
	 * @return 現在の行列で計算されたY軸の値
	 */
	transformY(src: number): number;
	/**
	 * X軸の値を現在の行列で逆計算
	 */
	invertTransformX(src: number): number;
	/**
	 * Y軸の値を現在の行列で逆計算
	 */
	invertTransformY(src: number): number;
	/**
	 * 現在の行列の位置を起点にして移動
	 *
	 * 現在の行列の位置を起点にして相対的に移動する。
	 *
	 * @param x X軸の移動量
	 * @param y Y軸の移動量
	 */
	translateRelative(x: number, y: number): void;
	/**
	 * 現在の行列の位置を移動
	 *
	 * 現在の行列の位置を指定した位置へ移動する
	 *
	 * @param x X軸の移動量
	 * @param y y軸の移動量
	 */
	translate(x: number, y: number): void;
	/**
	 * 現在の行列のX軸の位置を指定した位置へ移動する
	 *
	 * @param x X軸の移動量
	 */
	translateX(x: number): void;
	/**
	 * 現在の行列のY軸の位置を指定した位置へ移動する
	 *
	 * @param y Y軸の移動量
	 */
	translateY(y: number): void;
	/**
	 * 現在の行列の拡大率を相対的に設定する
	 *
	 * @param x X軸の拡大率
	 * @param y Y軸の拡大率
	 */
	scaleRelative(x: number, y: number): void;
	/**
	 * 現在の行列の拡大率を指定した倍率に設定する
	 *
	 * @param x X軸の拡大率
	 * @param y Y軸の拡大率
	 */
	scale(x: number, y: number): void;
	/**
	 * 現在の行列に行列を乗算
	 *
	 * @param m 行列
	 */
	multiplyByMatrix(m: CubismMatrix44): void;
	/**
	 * オブジェクトのコピーを生成する
	 */
	clone(): CubismMatrix44;
	protected _tr: Float32Array;
}
declare abstract class CubismRenderer {
	/**
	 * レンダラの初期化処理を実行する
	 * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
	 * @param model モデルのインスタンス
	 */
	initialize(model: CubismModel): void;
	/**
	 * モデルを描画する
	 */
	drawModel(): void;
	/**
	 * Model-View-Projection 行列をセットする
	 * 配列は複製されるので、元の配列は外で破棄して良い
	 * @param matrix44 Model-View-Projection 行列
	 */
	setMvpMatrix(matrix44: CubismMatrix44): void;
	/**
	 * Model-View-Projection 行列を取得する
	 * @return Model-View-Projection 行列
	 */
	getMvpMatrix(): CubismMatrix44;
	/**
	 * モデルの色をセットする
	 * 各色0.0~1.0の間で指定する（1.0が標準の状態）
	 * @param red 赤チャンネルの値
	 * @param green 緑チャンネルの値
	 * @param blue 青チャンネルの値
	 * @param alpha αチャンネルの値
	 */
	setModelColor(red: number, green: number, blue: number, alpha: number): void;
	/**
	 * モデルの色を取得する
	 * 各色0.0~1.0の間で指定する(1.0が標準の状態)
	 *
	 * @return RGBAのカラー情報
	 */
	getModelColor(): CubismTextureColor;
	/**
	 * 乗算済みαの有効・無効をセットする
	 * 有効にするならtrue、無効にするならfalseをセットする
	 */
	setIsPremultipliedAlpha(enable: boolean): void;
	/**
	 * 乗算済みαの有効・無効を取得する
	 * @return true 乗算済みのα有効
	 * @return false 乗算済みのα無効
	 */
	isPremultipliedAlpha(): boolean;
	/**
	 * カリング（片面描画）の有効・無効をセットする。
	 * 有効にするならtrue、無効にするならfalseをセットする
	 */
	setIsCulling(culling: boolean): void;
	/**
	 * カリング（片面描画）の有効・無効を取得する。
	 * @return true カリング有効
	 * @return false カリング無効
	 */
	isCulling(): boolean;
	/**
	 * テクスチャの異方性フィルタリングのパラメータをセットする
	 * パラメータ値の影響度はレンダラの実装に依存する
	 * @param n パラメータの値
	 */
	setAnisotropy(n: number): void;
	/**
	 * テクスチャの異方性フィルタリングのパラメータをセットする
	 * @return 異方性フィルタリングのパラメータ
	 */
	getAnisotropy(): number;
	/**
	 * レンダリングするモデルを取得する
	 * @return レンダリングするモデル
	 */
	getModel(): CubismModel;
	/**
	 * コンストラクタ
	 */
	protected constructor();
	/**
	 * モデル描画の実装
	 */
	abstract doDrawModel(): void;
	/**
	 * 描画オブジェクト（アートメッシュ）を描画する
	 * ポリゴンメッシュとテクスチャ番号をセットで渡す。
	 * @param textureNo 描画するテクスチャ番号
	 * @param indexCount 描画オブジェクトのインデックス値
	 * @param vertexCount ポリゴンメッシュの頂点数
	 * @param indexArray ポリゴンメッシュ頂点のインデックス配列
	 * @param vertexArray ポリゴンメッシュの頂点配列
	 * @param uvArray uv配列
	 * @param opacity 不透明度
	 * @param colorBlendMode カラーブレンディングのタイプ
	 * @param invertedMask マスク使用時のマスクの反転使用
	 */
	abstract drawMesh(textureNo: number, indexCount: number, vertexCount: number, indexArray: Uint16Array, vertexArray: Float32Array, uvArray: Float32Array, opacity: number, colorBlendMode: CubismBlendMode, invertedMask: boolean): void;
	/**
	 * レンダラが保持する静的なリソースを開放する
	 */
	static staticRelease: Function;
	protected _mvpMatrix4x4: CubismMatrix44;
	protected _modelColor: CubismTextureColor;
	protected _isCulling: boolean;
	protected _isPremultipliedAlpha: boolean;
	protected _anisortopy: any;
	protected _model: CubismModel;
}
declare enum CubismBlendMode {
	CubismBlendMode_Normal = 0,
	CubismBlendMode_Additive = 1,
	CubismBlendMode_Multiplicative = 2
}
declare class CubismTextureColor {
	/**
	 * コンストラクタ
	 */
	constructor();
	R: number;
	G: number;
	B: number;
	A: number;
}
declare class CubismModel {
	/**
	 * モデルのパラメータの更新
	 */
	update(): void;
	/**
	 * キャンバスの幅を取得する
	 */
	getCanvasWidth(): number;
	/**
	 * キャンバスの高さを取得する
	 */
	getCanvasHeight(): number;
	/**
	 * パラメータを保存する
	 */
	saveParameters(): void;
	/**
	 * モデルを取得
	 */
	getModel(): Live2DCubismCore.Model;
	/**
	 * パーツのインデックスを取得
	 * @param partId パーツのID
	 * @return パーツのインデックス
	 */
	getPartIndex(partId: string): number;
	/**
	 * パーツの個数の取得
	 * @return パーツの個数
	 */
	getPartCount(): number;
	/**
	 * パーツの不透明度の設定(Index)
	 * @param partIndex パーツのインデックス
	 * @param opacity 不透明度
	 */
	setPartOpacityByIndex(partIndex: number, opacity: number): void;
	/**
	 * パーツの不透明度の設定(Id)
	 * @param partId パーツのID
	 * @param opacity パーツの不透明度
	 */
	setPartOpacityById(partId: string, opacity: number): void;
	/**
	 * パーツの不透明度の取得(index)
	 * @param partIndex パーツのインデックス
	 * @return パーツの不透明度
	 */
	getPartOpacityByIndex(partIndex: number): number;
	/**
	 * パーツの不透明度の取得(id)
	 * @param partId パーツのＩｄ
	 * @return パーツの不透明度
	 */
	getPartOpacityById(partId: string): number;
	/**
	 * パラメータのインデックスの取得
	 * @param パラメータID
	 * @return パラメータのインデックス
	 */
	getParameterIndex(parameterId: string): number;
	/**
	 * パラメータの個数の取得
	 * @return パラメータの個数
	 */
	getParameterCount(): number;
	/**
	 * パラメータの最大値の取得
	 * @param parameterIndex パラメータのインデックス
	 * @return パラメータの最大値
	 */
	getParameterMaximumValue(parameterIndex: number): number;
	/**
	 * パラメータの最小値の取得
	 * @param parameterIndex パラメータのインデックス
	 * @return パラメータの最小値
	 */
	getParameterMinimumValue(parameterIndex: number): number;
	/**
	 * パラメータのデフォルト値の取得
	 * @param parameterIndex パラメータのインデックス
	 * @return パラメータのデフォルト値
	 */
	getParameterDefaultValue(parameterIndex: number): number;
	/**
	 * パラメータの値の取得
	 * @param parameterIndex    パラメータのインデックス
	 * @return パラメータの値
	 */
	getParameterValueByIndex(parameterIndex: number): number;
	/**
	 * パラメータの値の取得
	 * @param parameterId    パラメータのID
	 * @return パラメータの値
	 */
	getParameterValueById(parameterId: string): number;
	/**
	 * パラメータの値の設定
	 * @param parameterIndex パラメータのインデックス
	 * @param value パラメータの値
	 * @param weight 重み
	 */
	setParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void;
	/**
	 * パラメータの値の設定
	 * @param parameterId パラメータのID
	 * @param value パラメータの値
	 * @param weight 重み
	 */
	setParameterValueById(parameterId: string, value: number, weight?: number): void;
	/**
	 * パラメータの値の加算(index)
	 * @param parameterIndex パラメータインデックス
	 * @param value 加算する値
	 * @param weight 重み
	 */
	addParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void;
	/**
	 * パラメータの値の加算(id)
	 * @param parameterId パラメータＩＤ
	 * @param value 加算する値
	 * @param weight 重み
	 */
	addParameterValueById(parameterId: any, value: number, weight?: number): void;
	/**
	 * パラメータの値の乗算
	 * @param parameterId パラメータのID
	 * @param value 乗算する値
	 * @param weight 重み
	 */
	multiplyParameterValueById(parameterId: string, value: number, weight?: number): void;
	/**
	 * パラメータの値の乗算
	 * @param parameterIndex パラメータのインデックス
	 * @param value 乗算する値
	 * @param weight 重み
	 */
	multiplyParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void;
	getDrawableIds(): string[];
	/**
	 * Drawableのインデックスの取得
	 * @param drawableId DrawableのID
	 * @return Drawableのインデックス
	 */
	getDrawableIndex(drawableId: string): number;
	/**
	 * Drawableの個数の取得
	 * @return drawableの個数
	 */
	getDrawableCount(): number;
	/**
	 * DrawableのIDを取得する
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのID
	 */
	getDrawableId(drawableIndex: number): string;
	/**
	 * Drawableの描画順リストの取得
	 * @return Drawableの描画順リスト
	 */
	getDrawableRenderOrders(): Int32Array;
	/**
	 * Drawableのテクスチャインデックスリストの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのテクスチャインデックスリスト
	 */
	getDrawableTextureIndices(drawableIndex: number): number;
	/**
	 * DrawableのVertexPositionsの変化情報の取得
	 *
	 * 直近のCubismModel.update関数でDrawableの頂点情報が変化したかを取得する。
	 *
	 * @param   drawableIndex   Drawableのインデックス
	 * @retval  true    Drawableの頂点情報が直近のCubismModel.update関数で変化した
	 * @retval  false   Drawableの頂点情報が直近のCubismModel.update関数で変化していない
	 */
	getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex: number): boolean;
	/**
	 * Drawableの頂点インデックスの個数の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点インデックスの個数
	 */
	getDrawableVertexIndexCount(drawableIndex: number): number;
	/**
	 * Drawableの頂点の個数の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点の個数
	 */
	getDrawableVertexCount(drawableIndex: number): number;
	/**
	 * Drawableの頂点リストの取得
	 * @param drawableIndex drawableのインデックス
	 * @return drawableの頂点リスト
	 */
	getDrawableVertices(drawableIndex: number): Float32Array;
	/**
	 * Drawableの頂点インデックスリストの取得
	 * @param drarableIndex Drawableのインデックス
	 * @return drawableの頂点インデックスリスト
	 */
	getDrawableVertexIndices(drawableIndex: number): Uint16Array;
	/**
	 * Drawableの頂点リストの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点リスト
	 */
	getDrawableVertexPositions(drawableIndex: number): Float32Array;
	/**
	 * Drawableの頂点のUVリストの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点UVリスト
	 */
	getDrawableVertexUvs(drawableIndex: number): Float32Array;
	/**
	 * Drawableの不透明度の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの不透明度
	 */
	getDrawableOpacity(drawableIndex: number): number;
	/**
	 * Drawableのカリング情報の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのカリング情報
	 */
	getDrawableCulling(drawableIndex: number): boolean;
	/**
	 * Drawableのブレンドモードを取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのブレンドモード
	 */
	getDrawableBlendMode(drawableIndex: number): CubismBlendMode;
	/**
	 * Drawableのマスクの反転使用の取得
	 *
	 * Drawableのマスク使用時の反転設定を取得する。
	 * マスクを使用しない場合は無視される。
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @return Drawableの反転設定
	 */
	getDrawableInvertedMaskBit(drawableIndex: number): boolean;
	/**
	 * Drawableのクリッピングマスクリストの取得
	 * @return Drawableのクリッピングマスクリスト
	 */
	getDrawableMasks(): Int32Array[];
	/**
	 * Drawableのクリッピングマスクの個数リストの取得
	 * @return Drawableのクリッピングマスクの個数リスト
	 */
	getDrawableMaskCounts(): Int32Array;
	/**
	 * クリッピングマスクの使用状態
	 *
	 * @return true クリッピングマスクを使用している
	 * @return false クリッピングマスクを使用していない
	 */
	isUsingMasking(): boolean;
	/**
	 * Drawableの表示情報を取得する
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @return true Drawableが表示
	 * @return false Drawableが非表示
	 */
	getDrawableDynamicFlagIsVisible(drawableIndex: number): boolean;
	/**
	 * DrawableのDrawOrderの変化情報の取得
	 *
	 * 直近のCubismModel.update関数でdrawableのdrawOrderが変化したかを取得する。
	 * drawOrderはartMesh上で指定する0から1000の情報
	 * @param drawableIndex drawableのインデックス
	 * @return true drawableの不透明度が直近のCubismModel.update関数で変化した
	 * @return false drawableの不透明度が直近のCubismModel.update関数で変化している
	 */
	getDrawableDynamicFlagVisibilityDidChange(drawableIndex: number): boolean;
	/**
	 * Drawableの不透明度の変化情報の取得
	 *
	 * 直近のCubismModel.update関数でdrawableの不透明度が変化したかを取得する。
	 *
	 * @param drawableIndex drawableのインデックス
	 * @return true Drawableの不透明度が直近のCubismModel.update関数で変化した
	 * @return false Drawableの不透明度が直近のCubismModel.update関数で変化してない
	 */
	getDrawableDynamicFlagOpacityDidChange(drawableIndex: number): boolean;
	/**
	 * Drawableの描画順序の変化情報の取得
	 *
	 * 直近のCubismModel.update関数でDrawableの描画の順序が変化したかを取得する。
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @return true Drawableの描画の順序が直近のCubismModel.update関数で変化した
	 * @return false Drawableの描画の順序が直近のCubismModel.update関数で変化してない
	 */
	getDrawableDynamicFlagRenderOrderDidChange(drawableIndex: number): boolean;
	/**
	 * 保存されたパラメータの読み込み
	 */
	loadParameters(): void;
	/**
	 * 初期化する
	 */
	initialize(): void;
	/**
	 * コンストラクタ
	 * @param model モデル
	 */
	constructor(model: Live2DCubismCore.Model);
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	private _notExistPartOpacities;
	private _notExistPartId;
	private _notExistParameterValues;
	private _notExistParameterId;
	private _savedParameters;
	private _model;
	private _parameterValues;
	private _parameterMaximumValues;
	private _parameterMinimumValues;
	private _partOpacities;
	private _parameterIds;
	private _partIds;
	private _drawableIds;
}
declare class CubismMotionQueueManager {
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ
	 */
	release(): void;
	/**
	 * 指定したモーションの開始
	 *
	 * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。
	 *
	 * @param   motion          開始するモーション
	 * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true
	 * @param   userTimeSeconds デルタ時間の積算値[秒]
	 * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」
	 */
	startMotion(motion: ACubismMotion, autoDelete: boolean, userTimeSeconds: number): CubismMotionQueueEntryHandle;
	/**
	 * 全てのモーションの終了の確認
	 * @return true 全て終了している
	 * @return false 終了していない
	 */
	isFinished(): boolean;
	/**
	 * 指定したモーションの終了の確認
	 * @param motionQueueEntryNumber モーションの識別番号
	 * @return true 全て終了している
	 * @return false 終了していない
	 */
	isFinishedByHandle(motionQueueEntryNumber: CubismMotionQueueEntryHandle): boolean;
	/**
	 * 全てのモーションを停止する
	 */
	stopAllMotions(): void;
	/**
	 * 指定したCubismMotionQueueEntryの取得
  
	 * @param   motionQueueEntryNumber  モーションの識別番号
	 * @return  指定したCubismMotionQueueEntry
	 * @return  null   見つからなかった
	 */
	getCubismMotionQueueEntry(motionQueueEntryNumber: any): CubismMotionQueueEntry | undefined;
	/**
	 * イベントを受け取るCallbackの登録
	 *
	 * @param callback コールバック関数
	 * @param customData コールバックに返されるデータ
	 */
	setEventCallback(callback: CubismMotionEventFunction, customData?: any): void;
	/**
	 * モーションを更新して、モデルにパラメータ値を反映する。
	 *
	 * @param   model   対象のモデル
	 * @param   userTimeSeconds   デルタ時間の積算値[秒]
	 * @return  true    モデルへパラメータ値の反映あり
	 * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)
	 */
	doUpdateMotion(model: CubismModel, userTimeSeconds: number): boolean;
	_userTimeSeconds: number;
	_motions: CubismMotionQueueEntry[];
	_eventCallBack: CubismMotionEventFunction;
	_eventCustomData: any;
}
/**
 * イベントのコールバック関数を定義
 *
 * イベントのコールバックに登録できる関数の型情報
 * @param caller        発火したイベントを再生させたCubismMotionQueueManager
 * @param eventValue    発火したイベントの文字列データ
 * @param customData   コールバックに返される登録時に指定されたデータ
 */
export interface CubismMotionEventFunction {
	(caller: CubismMotionQueueManager, eventValue: string, customData: any): void;
}
/**
 * モーションの識別番号
 *
 * モーションの識別番号の定義
 */
export declare type CubismMotionQueueEntryHandle = any;
declare class CubismMotionQueueEntry {
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	/**
	 * フェードアウト時間と開始判定の設定
	 * @param fadeOutSeconds フェードアウトにかかる時間[秒]
	 */
	setFadeOut(fadeOutSeconds: number): void;
	/**
	 * フェードアウトの開始
	 * @param fadeOutSeconds フェードアウトにかかる時間[秒]
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 */
	startFadeOut(fadeOutSeconds: number, userTimeSeconds: number): void;
	/**
	 * モーションの終了の確認
	 *
	 * @return true モーションが終了した
	 * @return false 終了していない
	 */
	isFinished(): boolean;
	/**
	 * モーションの開始の確認
	 * @return true モーションが開始した
	 * @return false 開始していない
	 */
	isStarted(): boolean;
	/**
	 * モーションの開始時刻の取得
	 * @return モーションの開始時刻[秒]
	 */
	getStartTime(): number;
	/**
	 * フェードインの開始時刻の取得
	 * @return フェードインの開始時刻[秒]
	 */
	getFadeInStartTime(): number;
	/**
	 * フェードインの終了時刻の取得
	 * @return フェードインの終了時刻の取得
	 */
	getEndTime(): number;
	/**
	 * モーションの開始時刻の設定
	 * @param startTime モーションの開始時刻
	 */
	setStartTime(startTime: number): void;
	/**
	 * フェードインの開始時刻の設定
	 * @param startTime フェードインの開始時刻[秒]
	 */
	setFadeInStartTime(startTime: number): void;
	/**
	 * フェードインの終了時刻の設定
	 * @param endTime フェードインの終了時刻[秒]
	 */
	setEndTime(endTime: number): void;
	/**
	 * モーションの終了の設定
	 * @param f trueならモーションの終了
	 */
	setIsFinished(f: boolean): void;
	/**
	 * モーション開始の設定
	 * @param f trueならモーションの開始
	 */
	setIsStarted(f: boolean): void;
	/**
	 * モーションの有効性の確認
	 * @return true モーションは有効
	 * @return false モーションは無効
	 */
	isAvailable(): boolean;
	/**
	 * モーションの有効性の設定
	 * @param v trueならモーションは有効
	 */
	setIsAvailable(v: boolean): void;
	/**
	 * モーションの状態の設定
	 * @param timeSeconds 現在時刻[秒]
	 * @param weight モーション尾重み
	 */
	setState(timeSeconds: number, weight: number): void;
	/**
	 * モーションの現在時刻の取得
	 * @return モーションの現在時刻[秒]
	 */
	getStateTime(): number;
	/**
	 * モーションの重みの取得
	 * @return モーションの重み
	 */
	getStateWeight(): number;
	/**
	 * 最後にイベントの発火をチェックした時間を取得
	 *
	 * @return 最後にイベントの発火をチェックした時間[秒]
	 */
	getLastCheckEventSeconds(): number;
	/**
	 * 最後にイベントをチェックした時間を設定
	 * @param checkSeconds 最後にイベントをチェックした時間[秒]
	 */
	setLastCheckEventSeconds(checkSeconds: number): void;
	/**
	 * フェードアウト開始判定の取得
	 * @return フェードアウト開始するかどうか
	 */
	isTriggeredFadeOut(): boolean;
	/**
	 * フェードアウト時間の取得
	 * @return フェードアウト時間[秒]
	 */
	getFadeOutSeconds(): number;
	_autoDelete: boolean;
	_motion: ACubismMotion;
	_available: boolean;
	_finished: boolean;
	_started: boolean;
	_startTimeSeconds: number;
	_fadeInStartTimeSeconds: number;
	_endTimeSeconds: number;
	_stateTimeSeconds: number;
	_stateWeight: number;
	_lastEventCheckSeconds: number;
	private _fadeOutSeconds;
	private _isTriggeredFadeOut;
	_motionQueueEntryHandle: CubismMotionQueueEntryHandle;
}
declare abstract class ACubismMotion {
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	/**
	 * モデルのパラメータ
	 * @param model 対象のモデル
	 * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 */
	updateParameters(model: CubismModel, motionQueueEntry: CubismMotionQueueEntry, userTimeSeconds: number): void;
	/**
	 * フェードインの時間を設定する
	 * @param fadeInSeconds フェードインにかかる時間[秒]
	 */
	setFadeInTime(fadeInSeconds: number): void;
	/**
	 * フェードアウトの時間を設定する
	 * @param fadeOutSeconds フェードアウトにかかる時間[秒]
	 */
	setFadeOutTime(fadeOutSeconds: number): void;
	/**
	 * フェードアウトにかかる時間の取得
	 * @return フェードアウトにかかる時間[秒]
	 */
	getFadeOutTime(): number;
	/**
	 * フェードインにかかる時間の取得
	 * @return フェードインにかかる時間[秒]
	 */
	getFadeInTime(): number;
	/**
	 * モーション適用の重みの設定
	 * @param weight 重み（0.0 - 1.0）
	 */
	setWeight(weight: number): void;
	/**
	 * モーション適用の重みの取得
	 * @return 重み（0.0 - 1.0）
	 */
	getWeight(): number;
	/**
	 * モーションの長さの取得
	 * @return モーションの長さ[秒]
	 *
	 * @note ループの時は「-1」。
	 *       ループでない場合は、オーバーライドする。
	 *       正の値の時は取得される時間で終了する。
	 *       「-1」の時は外部から停止命令がない限り終わらない処理となる。
	 */
	getDuration(): number;
	/**
	 * モーションのループ1回分の長さの取得
	 * @return モーションのループ一回分の長さ[秒]
	 *
	 * @note ループしない場合は、getDuration()と同じ値を返す
	 *       ループ一回分の長さが定義できない場合(プログラム的に動き続けるサブクラスなど)の場合は「-1」を返す
	 */
	getLoopDuration(): number;
	/**
	 * モーション再生の開始時刻の設定
	 * @param offsetSeconds モーション再生の開始時刻[秒]
	 */
	setOffsetTime(offsetSeconds: number): void;
	/**
	 * モデルのパラメータ更新
	 *
	 * イベント発火のチェック。
	 * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
	 *
	 * @param beforeCheckTimeSeconds 前回のイベントチェック時間[秒]
	 * @param motionTimeSeconds 今回の再生時間[秒]
	 */
	getFiredEvent(beforeCheckTimeSeconds: number, motionTimeSeconds: number): string[];
	/**
	 * モーションを更新して、モデルにパラメータ値を反映する
	 * @param model 対象のモデル
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 * @param weight モーションの重み
	 * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
	 * @return true モデルへパラメータ値の反映あり
	 * @return false モデルへのパラメータ値の反映なし（モーションの変化なし）
	 */
	abstract doUpdateParameters(model: CubismModel, userTimeSeconds: number, weight: number, motionQueueEntry: CubismMotionQueueEntry): void;
	/**
	 * モーション再生終了コールバックの登録
	 *
	 * モーション再生終了コールバックを登録する。
	 * isFinishedフラグを設定するタイミングで呼び出される。
	 * 以下の状態の際には呼び出されない:
	 *   1. 再生中のモーションが「ループ」として設定されているとき
	 *   2. コールバックが登録されていない時
	 *
	 * @param onFinishedMotionHandler モーション再生終了コールバック関数
	 */
	setFinishedMotionHandler(onFinishedMotionHandler?: (self: ACubismMotion) => void): void;
	/**
	 * モーション再生終了コールバックの取得
	 *
	 * モーション再生終了コールバックを取得する。
	 *
	 * @return 登録されているモーション再生終了コールバック関数
	 */
	getFinishedMotionHandler(): ((self: ACubismMotion) => void) | undefined;
	_fadeInSeconds: number;
	_fadeOutSeconds: number;
	_weight: number;
	_offsetSeconds: number;
	_firedEventValues: string[];
	_onFinishedMotion?: (self: ACubismMotion) => void;
}
declare class CubismExpressionMotion extends ACubismMotion {
	/**
	 * インスタンスを作成する。
	 * @param json expファイルが読み込まれているバッファ
	 * @param size バッファのサイズ
	 * @return 作成されたインスタンス
	 */
	static create(json: CubismSpec.ExpressionJSON): CubismExpressionMotion;
	/**
	 * モデルのパラメータの更新の実行
	 * @param model 対象のモデル
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 * @param weight モーションの重み
	 * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
	 */
	doUpdateParameters(model: CubismModel, userTimeSeconds: number, weight: number, motionQueueEntry: CubismMotionQueueEntry): void;
	/**
	 * コンストラクタ
	 */
	constructor();
	_parameters: ExpressionParameter[];
}
declare enum ExpressionBlendType {
	ExpressionBlendType_Add = 0,
	ExpressionBlendType_Multiply = 1,
	ExpressionBlendType_Overwrite = 2
}
/**
 * 表情のパラメータ情報
 */
export interface ExpressionParameter {
	parameterId: string;
	blendType: ExpressionBlendType;
	value: number;
}
export declare class Cubism4ExpressionManager extends ExpressionManager<CubismExpressionMotion, CubismSpec.Expression> {
	readonly queueManager: CubismMotionQueueManager;
	readonly definitions: CubismSpec.Expression[];
	constructor(settings: Cubism4ModelSettings, options?: MotionManagerOptions);
	isFinished(): boolean;
	getExpressionIndex(name: string): number;
	getExpressionFile(definition: CubismSpec.Expression): string;
	createExpression(data: object, definition: CubismSpec.Expression | undefined): CubismExpressionMotion;
	protected _setExpression(motion: CubismExpressionMotion): number;
	protected stopAllExpressions(): void;
	protected updateParameters(model: CubismModel, now: DOMHighResTimeStamp): boolean;
}
declare enum CubismMotionCurveTarget {
	CubismMotionCurveTarget_Model = 0,
	CubismMotionCurveTarget_Parameter = 1,
	CubismMotionCurveTarget_PartOpacity = 2
}
declare class CubismMotionPoint {
	constructor(time?: number, value?: number);
	time: number;
	value: number;
}
/**
 * モーションカーブのセグメントの評価関数
 *
 * @param   points      モーションカーブの制御点リスト
 * @param   time        評価する時間[秒]
 */
export interface csmMotionSegmentEvaluationFunction {
	(points: CubismMotionPoint[], time: number): number;
}
declare class CubismMotionSegment {
	/**
	 * @brief コンストラクタ
	 *
	 * コンストラクタ。
	 */
	constructor();
	evaluate: csmMotionSegmentEvaluationFunction;
	basePointIndex: number;
	segmentType: number;
}
declare class CubismMotionCurve {
	constructor();
	type: CubismMotionCurveTarget;
	id: string;
	segmentCount: number;
	baseSegmentIndex: number;
	fadeInTime: number;
	fadeOutTime: number;
}
declare class CubismMotionEvent {
	fireTime: number;
	value: string;
}
declare class CubismMotionData {
	constructor();
	duration: number;
	loop: boolean;
	curveCount: number;
	eventCount: number;
	fps: number;
	curves: CubismMotionCurve[];
	segments: CubismMotionSegment[];
	points: CubismMotionPoint[];
	events: CubismMotionEvent[];
}
declare class CubismMotion extends ACubismMotion {
	/**
	 * インスタンスを作成する
	 *
	 * @param json motion3.jsonが読み込まれているバッファ
	 * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数
	 * @return 作成されたインスタンス
	 */
	static create(json: CubismSpec.MotionJSON, onFinishedMotionHandler?: (self: ACubismMotion) => void): CubismMotion;
	/**
	 * モデルのパラメータの更新の実行
	 * @param model             対象のモデル
	 * @param userTimeSeconds   現在の時刻[秒]
	 * @param fadeWeight        モーションの重み
	 * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション
	 */
	doUpdateParameters(model: CubismModel, userTimeSeconds: number, fadeWeight: number, motionQueueEntry: CubismMotionQueueEntry): void;
	/**
	 * ループ情報の設定
	 * @param loop ループ情報
	 */
	setIsLoop(loop: boolean): void;
	/**
	 * ループ情報の取得
	 * @return true ループする
	 * @return false ループしない
	 */
	isLoop(): boolean;
	/**
	 * ループ時のフェードイン情報の設定
	 * @param loopFadeIn  ループ時のフェードイン情報
	 */
	setIsLoopFadeIn(loopFadeIn: boolean): void;
	/**
	 * ループ時のフェードイン情報の取得
	 *
	 * @return  true    する
	 * @return  false   しない
	 */
	isLoopFadeIn(): boolean;
	/**
	 * モーションの長さを取得する。
	 *
	 * @return  モーションの長さ[秒]
	 */
	getDuration(): number;
	/**
	 * モーションのループ時の長さを取得する。
	 *
	 * @return  モーションのループ時の長さ[秒]
	 */
	getLoopDuration(): number;
	/**
	 * パラメータに対するフェードインの時間を設定する。
	 *
	 * @param parameterId     パラメータID
	 * @param value           フェードインにかかる時間[秒]
	 */
	setParameterFadeInTime(parameterId: string, value: number): void;
	/**
	 * パラメータに対するフェードアウトの時間の設定
	 * @param parameterId     パラメータID
	 * @param value           フェードアウトにかかる時間[秒]
	 */
	setParameterFadeOutTime(parameterId: string, value: number): void;
	/**
	 * パラメータに対するフェードインの時間の取得
	 * @param    parameterId     パラメータID
	 * @return   フェードインにかかる時間[秒]
	 */
	getParameterFadeInTime(parameterId: string): number;
	/**
	 * パラメータに対するフェードアウトの時間を取得
	 *
	 * @param   parameterId     パラメータID
	 * @return   フェードアウトにかかる時間[秒]
	 */
	getParameterFadeOutTime(parameterId: string): number;
	/**
	 * 自動エフェクトがかかっているパラメータIDリストの設定
	 * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト
	 * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト
	 */
	setEffectIds(eyeBlinkParameterIds: string[], lipSyncParameterIds: string[]): void;
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	/**
	 * motion3.jsonをパースする。
	 *
	 * @param motionJson  motion3.jsonが読み込まれているバッファ
	 */
	parse(motionJson: CubismSpec.MotionJSON): void;
	/**
	 * モデルのパラメータ更新
	 *
	 * イベント発火のチェック。
	 * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
	 *
	 * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]
	 * @param motionTimeSeconds        今回の再生時間[秒]
	 */
	getFiredEvent(beforeCheckTimeSeconds: number, motionTimeSeconds: number): string[];
	_sourceFrameRate: number;
	_loopDurationSeconds: number;
	_isLoop: boolean;
	_isLoopFadeIn: boolean;
	_lastWeight: number;
	_motionData: CubismMotionData;
	_eyeBlinkParameterIds: string[];
	_lipSyncParameterIds: string[];
	_modelCurveIdEyeBlink?: string;
	_modelCurveIdLipSync?: string;
}
export declare class Cubism4MotionManager extends MotionManager<CubismMotion, CubismSpec.Motion> {
	readonly definitions: Partial<Record<string, CubismSpec.Motion[]>>;
	readonly groups: {
		readonly idle: "Idle";
	};
	readonly motionDataType = "json";
	readonly queueManager: CubismMotionQueueManager;
	readonly settings: Cubism4ModelSettings;
	expressionManager?: Cubism4ExpressionManager;
	eyeBlinkIds: string[];
	lipSyncIds: string[];
	constructor(settings: Cubism4ModelSettings, options?: MotionManagerOptions);
	protected init(options?: MotionManagerOptions): void;
	isFinished(): boolean;
	protected _startMotion(motion: CubismMotion, onFinish?: (motion: CubismMotion) => void): number;
	protected _stopAllMotions(): void;
	createMotion(data: object, group: string, definition: CubismSpec.Motion): CubismMotion;
	getMotionFile(definition: CubismSpec.Motion): string;
	protected getMotionName(definition: CubismSpec.Motion): string;
	protected getSoundFile(definition: CubismSpec.Motion): string | undefined;
	protected updateParameters(model: CubismModel, now: DOMHighResTimeStamp): boolean;
	destroy(): void;
}
declare class CubismBreath {
	/**
	 * インスタンスの作成
	 */
	static create(): CubismBreath;
	/**
	 * 呼吸のパラメータの紐づけ
	 * @param breathParameters 呼吸を紐づけたいパラメータのリスト
	 */
	setParameters(breathParameters: BreathParameterData[]): void;
	/**
	 * 呼吸に紐づいているパラメータの取得
	 * @return 呼吸に紐づいているパラメータのリスト
	 */
	getParameters(): BreathParameterData[];
	/**
	 * モデルのパラメータの更新
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
	updateParameters(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * コンストラクタ
	 */
	constructor();
	_breathParameters: BreathParameterData[];
	_currentTime: number;
}
declare class BreathParameterData {
	/**
	 * コンストラクタ
	 * @param parameterId   呼吸をひもづけるパラメータID
	 * @param offset        呼吸を正弦波としたときの、波のオフセット
	 * @param peak          呼吸を正弦波としたときの、波の高さ
	 * @param cycle         呼吸を正弦波としたときの、波の周期
	 * @param weight        パラメータへの重み
	 */
	constructor(parameterId?: string, offset?: number, peak?: number, cycle?: number, weight?: number);
	parameterId?: string;
	offset: number;
	peak: number;
	cycle: number;
	weight: number;
}
declare class CubismEyeBlink {
	/**
	 * インスタンスを作成する
	 * @param modelSetting モデルの設定情報
	 * @return 作成されたインスタンス
	 * @note 引数がNULLの場合、パラメータIDが設定されていない空のインスタンスを作成する。
	 */
	static create(modelSetting: CubismModelSettingsJson): CubismEyeBlink;
	/**
	 * まばたきの間隔の設定
	 * @param blinkingInterval まばたきの間隔の時間[秒]
	 */
	setBlinkingInterval(blinkingInterval: number): void;
	/**
	 * まばたきのモーションの詳細設定
	 * @param closing   まぶたを閉じる動作の所要時間[秒]
	 * @param closed    まぶたを閉じている動作の所要時間[秒]
	 * @param opening   まぶたを開く動作の所要時間[秒]
	 */
	setBlinkingSetting(closing: number, closed: number, opening: number): void;
	/**
	 * まばたきさせるパラメータIDのリストの設定
	 * @param parameterIds パラメータのIDのリスト
	 */
	setParameterIds(parameterIds: string[]): void;
	/**
	 * まばたきさせるパラメータIDのリストの取得
	 * @return パラメータIDのリスト
	 */
	getParameterIds(): string[];
	/**
	 * モデルのパラメータの更新
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
	updateParameters(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * コンストラクタ
	 * @param modelSetting モデルの設定情報
	 */
	constructor(modelSetting: CubismModelSettingsJson);
	/**
	 * 次の瞬きのタイミングの決定
	 *
	 * @return 次のまばたきを行う時刻[秒]
	 */
	determinNextBlinkingTiming(): number;
	_blinkingState: number;
	_parameterIds: string[];
	_nextBlinkingTime: number;
	_stateStartTimeSeconds: number;
	_blinkingIntervalSeconds: number;
	_closingSeconds: number;
	_closedSeconds: number;
	_openingSeconds: number;
	_userTimeSeconds: number;
	/**
	 * IDで指定された目のパラメータが、0のときに閉じるなら true 、1の時に閉じるなら false 。
	 */
	static readonly CloseIfZero: boolean;
}
declare class CubismPose {
	/**
	 * インスタンスの作成
	 * @param pose3json pose3.jsonのデータ
	 * @return 作成されたインスタンス
	 */
	static create(pose3json: CubismSpec.PoseJSON): CubismPose;
	/**
	 * モデルのパラメータの更新
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
	updateParameters(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * 表示を初期化
	 * @param model 対象のモデル
	 * @note 不透明度の初期値が0でないパラメータは、不透明度を１に設定する
	 */
	reset(model: CubismModel): void;
	/**
	 * パーツの不透明度をコピー
	 *
	 * @param model 対象のモデル
	 */
	copyPartOpacities(model: CubismModel): void;
	/**
	 * パーツのフェード操作を行う。
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 * @param beginIndex フェード操作を行うパーツグループの先頭インデックス
	 * @param partGroupCount フェード操作を行うパーツグループの個数
	 */
	doFade(model: CubismModel, deltaTimeSeconds: number, beginIndex: number, partGroupCount: number): void;
	/**
	 * コンストラクタ
	 */
	constructor();
	_partGroups: PartData[];
	_partGroupCounts: number[];
	_fadeTimeSeconds: number;
	_lastModel?: CubismModel;
}
declare class PartData {
	/**
	 * コンストラクタ
	 */
	constructor(v?: PartData);
	/**
	 * =演算子のオーバーロード
	 */
	assignment(v: PartData): PartData;
	/**
	 * 初期化
	 * @param model 初期化に使用するモデル
	 */
	initialize(model: CubismModel): void;
	/**
	 * オブジェクトのコピーを生成する
	 */
	clone(): PartData;
	partId: string;
	parameterIndex: number;
	partIndex: number;
	link: PartData[];
}
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * ユーザーデータインターフェース
 *
 * Jsonから読み込んだユーザーデータを記録しておくための構造体
 */
export interface CubismModelUserDataNode {
	targetType: string;
	targetId: string;
	value: string;
}
declare class CubismModelUserData {
	/**
	 * インスタンスの作成
	 *
	 * @param json    userdata3.jsonが読み込まれているバッファ
	 * @param size      バッファのサイズ
	 * @return 作成されたインスタンス
	 */
	static create(json: CubismSpec.UserDataJSON, size: number): CubismModelUserData;
	/**
	 * ArtMeshのユーザーデータのリストの取得
	 *
	 * @return ユーザーデータリスト
	 */
	getArtMeshUserDatas(): CubismModelUserDataNode[];
	/**
	 * userdata3.jsonのパース
	 *
	 * @param data    userdata3.jsonが読み込まれているバッファ
	 * @param size      バッファのサイズ
	 */
	parseUserData(data: CubismSpec.UserDataJSON, size: number): void;
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ相当の処理
	 *
	 * ユーザーデータ構造体配列を解放する
	 */
	release(): void;
	private _userDataNodes;
	private _artMeshUserDataNode;
}
declare class CubismVector2 {
	x: number;
	y: number;
	/**
	 * コンストラクタ
	 */
	constructor(x?: number, y?: number);
	/**
	 * ベクトルの加算
	 *
	 * @param vector2 加算するベクトル値
	 * @return 加算結果 ベクトル値
	 */
	add(vector2: CubismVector2): CubismVector2;
	/**
	 * ベクトルの減算
	 *
	 * @param vector2 減算するベクトル値
	 * @return 減算結果 ベクトル値
	 */
	substract(vector2: CubismVector2): CubismVector2;
	/**
	 * ベクトルの乗算
	 *
	 * @param vector2 乗算するベクトル値
	 * @return 乗算結果 ベクトル値
	 */
	multiply(vector2: CubismVector2): CubismVector2;
	/**
	 * ベクトルの乗算(スカラー)
	 *
	 * @param scalar 乗算するスカラー値
	 * @return 乗算結果 ベクトル値
	 */
	multiplyByScaler(scalar: number): CubismVector2;
	/**
	 * ベクトルの除算
	 *
	 * @param vector2 除算するベクトル値
	 * @return 除算結果 ベクトル値
	 */
	division(vector2: CubismVector2): CubismVector2;
	/**
	 * ベクトルの除算(スカラー)
	 *
	 * @param scalar 除算するスカラー値
	 * @return 除算結果 ベクトル値
	 */
	divisionByScalar(scalar: number): CubismVector2;
	/**
	 * ベクトルの長さを取得する
	 *
	 * @return ベクトルの長さ
	 */
	getLength(): number;
	/**
	 * ベクトルの距離の取得
	 *
	 * @param a 点
	 * @return ベクトルの距離
	 */
	getDistanceWith(a: CubismVector2): number;
	/**
	 * ドット積の計算
	 *
	 * @param a 値
	 * @return 結果
	 */
	dot(a: CubismVector2): number;
	/**
	 * 正規化の適用
	 */
	normalize(): void;
	/**
	 * 等しさの確認（等しいか？）
	 *
	 * 値が等しいか？
	 *
	 * @param rhs 確認する値
	 * @return true 値は等しい
	 * @return false 値は等しくない
	 */
	isEqual(rhs: CubismVector2): boolean;
	/**
	 * 等しさの確認（等しくないか？）
	 *
	 * 値が等しくないか？
	 *
	 * @param rhs 確認する値
	 * @return true 値は等しくない
	 * @return false 値は等しい
	 */
	isNotEqual(rhs: CubismVector2): boolean;
}
declare enum CubismPhysicsTargetType {
	CubismPhysicsTargetType_Parameter = 0
}
declare enum CubismPhysicsSource {
	CubismPhysicsSource_X = 0,
	CubismPhysicsSource_Y = 1,
	CubismPhysicsSource_Angle = 2
}
/**
 * 物理演算のパラメータ情報
 */
export interface CubismPhysicsParameter {
	id: string;
	targetType: CubismPhysicsTargetType;
}
/**
 * 物理演算の正規化情報
 */
export interface CubismPhysicsNormalization {
	minimum: number;
	maximum: number;
	defalut: number;
}
declare class CubismPhysicsParticle {
	constructor();
	initialPosition: CubismVector2;
	mobility: number;
	delay: number;
	acceleration: number;
	radius: number;
	position: CubismVector2;
	lastPosition: CubismVector2;
	lastGravity: CubismVector2;
	force: CubismVector2;
	velocity: CubismVector2;
}
declare class CubismPhysicsSubRig {
	inputCount: number;
	outputCount: number;
	particleCount: number;
	baseInputIndex: number;
	baseOutputIndex: number;
	baseParticleIndex: number;
	normalizationPosition: CubismPhysicsNormalization;
	normalizationAngle: CubismPhysicsNormalization;
}
/**
 * 正規化されたパラメータの取得関数の宣言
 * @param targetTranslation     // 演算結果の移動値
 * @param targetAngle           // 演算結果の角度
 * @param value                 // パラメータの値
 * @param parameterMinimunValue // パラメータの最小値
 * @param parameterMaximumValue // パラメータの最大値
 * @param parameterDefaultValue // パラメータのデフォルト値
 * @param normalizationPosition // 正規化された位置
 * @param normalizationAngle    // 正規化された角度
 * @param isInverted            // 値が反転されているか？
 * @param weight                // 重み
 */
export interface normalizedPhysicsParameterValueGetter {
	(targetTranslation: CubismVector2, targetAngle: {
		angle: number;
	}, value: number, parameterMinimunValue: number, parameterMaximumValue: number, parameterDefaultValue: number, normalizationPosition: CubismPhysicsNormalization, normalizationAngle: CubismPhysicsNormalization, isInverted: boolean, weight: number): void;
}
/**
 * 物理演算の値の取得関数の宣言
 * @param translation 移動値
 * @param particles 物理点のリスト
 * @param isInverted 値が反映されているか
 * @param parentGravity 重力
 * @return 値
 */
export interface physicsValueGetter {
	(translation: CubismVector2, particles: CubismPhysicsParticle[], particleIndex: number, isInverted: boolean, parentGravity: CubismVector2): number;
}
/**
 * 物理演算のスケールの取得関数の宣言
 * @param translationScale 移動値のスケール
 * @param angleScale    角度のスケール
 * @return スケール値
 */
export interface physicsScaleGetter {
	(translationScale: CubismVector2, angleScale: number): number;
}
declare class CubismPhysicsInput {
	source: CubismPhysicsParameter;
	sourceParameterIndex: number;
	weight: number;
	type: number;
	reflect: boolean;
	getNormalizedParameterValue: normalizedPhysicsParameterValueGetter;
}
declare class CubismPhysicsOutput {
	destination: CubismPhysicsParameter;
	destinationParameterIndex: number;
	vertexIndex: number;
	translationScale: CubismVector2;
	angleScale: number;
	weight: number;
	type: CubismPhysicsSource;
	reflect: boolean;
	valueBelowMinimum: number;
	valueExceededMaximum: number;
	getValue: physicsValueGetter;
	getScale: physicsScaleGetter;
}
declare class CubismPhysicsRig {
	constructor();
	subRigCount: number;
	settings: CubismPhysicsSubRig[];
	inputs: CubismPhysicsInput[];
	outputs: CubismPhysicsOutput[];
	particles: CubismPhysicsParticle[];
	gravity: CubismVector2;
	wind: CubismVector2;
}
declare class CubismPhysics {
	/**
	 * インスタンスの作成
	 * @param json    physics3.jsonが読み込まれているバッファ
	 * @return 作成されたインスタンス
	 */
	static create(json: CubismSpec.PhysicsJSON): CubismPhysics;
	/**
	 * 物理演算の評価
	 * @param model 物理演算の結果を適用するモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
	evaluate(model: CubismModel, deltaTimeSeconds: number): void;
	/**
	 * オプションの設定
	 * @param options オプション
	 */
	setOptions(options: Options): void;
	/**
	 * オプションの取得
	 * @return オプション
	 */
	getOption(): Options;
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	/**
	 * physics3.jsonをパースする。
	 * @param physicsJson physics3.jsonが読み込まれているバッファ
	 */
	parse(physicsJson: CubismSpec.PhysicsJSON): void;
	/**
	 * 初期化する
	 */
	initialize(): void;
	_physicsRig: CubismPhysicsRig;
	_options: Options;
}
declare class Options {
	constructor();
	gravity: CubismVector2;
	wind: CubismVector2;
}
declare class csmRect {
	/**
	 * コンストラクタ
	 * @param x 左端X座標
	 * @param y 上端Y座標
	 * @param w 幅
	 * @param h 高さ
	 */
	constructor(x?: number, y?: number, w?: number, h?: number);
	/**
	 * 矩形中央のX座標を取得する
	 */
	getCenterX(): number;
	/**
	 * 矩形中央のY座標を取得する
	 */
	getCenterY(): number;
	/**
	 * 右側のX座標を取得する
	 */
	getRight(): number;
	/**
	 * 下端のY座標を取得する
	 */
	getBottom(): number;
	/**
	 * 矩形に値をセットする
	 * @param r 矩形のインスタンス
	 */
	setRect(r: csmRect): void;
	/**
	 * 矩形中央を軸にして縦横を拡縮する
	 * @param w 幅方向に拡縮する量
	 * @param h 高さ方向に拡縮する量
	 */
	expand(w: number, h: number): void;
	x: number;
	y: number;
	width: number;
	height: number;
}
declare class CubismClippingManager_WebGL {
	/**
	 * カラーチャンネル（RGBA）のフラグを取得する
	 * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）
	 */
	getChannelFlagAsColor(channelNo: number): CubismTextureColor;
	/**
	 * テンポラリのレンダーテクスチャのアドレスを取得する
	 * FrameBufferObjectが存在しない場合、新しく生成する
	 *
	 * @return レンダーテクスチャのアドレス
	 */
	getMaskRenderTexture(): WebGLFramebuffer | null;
	/**
	 * WebGLレンダリングコンテキストを設定する
	 * @param gl WebGLレンダリングコンテキスト
	 */
	setGL(gl: WebGLRenderingContext): void;
	/**
	 * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する
	 * @param model モデルのインスタンス
	 * @param clippingContext クリッピングマスクのコンテキスト
	 */
	calcClippedDrawTotalBounds(model: CubismModel, clippingContext: CubismClippingContext): void;
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	/**
	 * マネージャの初期化処理
	 * クリッピングマスクを使う描画オブジェクトの登録を行う
	 * @param model モデルのインスタンス
	 * @param drawableCount 描画オブジェクトの数
	 * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのインデックスのリスト
	 * @param drawableCounts 描画オブジェクトをマスクする描画オブジェクトの数
	 */
	initialize(model: CubismModel, drawableCount: number, drawableMasks: Int32Array[], drawableMaskCounts: Int32Array): void;
	/**
	 * クリッピングコンテキストを作成する。モデル描画時に実行する。
	 * @param model モデルのインスタンス
	 * @param renderer レンダラのインスタンス
	 */
	setupClippingContext(model: CubismModel, renderer: CubismRenderer_WebGL): void;
	/**
	 * 既にマスクを作っているかを確認
	 * 作っている様であれば該当するクリッピングマスクのインスタンスを返す
	 * 作っていなければNULLを返す
	 * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト
	 * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数
	 * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す
	 */
	findSameClip(drawableMasks: Int32Array, drawableMaskCounts: number): CubismClippingContext | null;
	/**
	 * クリッピングコンテキストを配置するレイアウト
	 * 一つのレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする
	 * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。
	 *
	 * @param usingClipCount 配置するクリッピングコンテキストの数
	 */
	setupLayoutBounds(usingClipCount: number): void;
	/**
	 * カラーバッファを取得する
	 * @return カラーバッファ
	 */
	getColorBuffer(): WebGLTexture | null;
	/**
	 * 画面描画に使用するクリッピングマスクのリストを取得する
	 * @return 画面描画に使用するクリッピングマスクのリスト
	 */
	getClippingContextListForDraw(): (CubismClippingContext | null)[];
	/**
	 * クリッピングマスクバッファのサイズを設定する
	 * @param size クリッピングマスクバッファのサイズ
	 */
	setClippingMaskBufferSize(size: number): void;
	/**
	 * クリッピングマスクバッファのサイズを取得する
	 * @return クリッピングマスクバッファのサイズ
	 */
	getClippingMaskBufferSize(): number;
	_maskRenderTexture: WebGLFramebuffer | null;
	_colorBuffer: WebGLTexture | null;
	_currentFrameNo: number;
	_channelColors: CubismTextureColor[];
	_maskTexture?: CubismRenderTextureResource;
	_clippingContextListForMask: CubismClippingContext[];
	_clippingContextListForDraw: (CubismClippingContext | null)[];
	_clippingMaskBufferSize: number;
	private _tmpMatrix;
	private _tmpMatrixForMask;
	private _tmpMatrixForDraw;
	private _tmpBoundsOnModel;
	gl: WebGLRenderingContext;
}
declare class CubismRenderTextureResource {
	/**
	 * 引数付きコンストラクタ
	 * @param frameNo レンダラーのフレーム番号
	 * @param texture テクスチャのアドレス
	 */
	constructor(frameNo: number, texture: WebGLFramebuffer | null);
	frameNo: number;
	texture: WebGLFramebuffer | null;
}
declare class CubismClippingContext {
	/**
	 * 引数付きコンストラクタ
	 */
	constructor(manager: CubismClippingManager_WebGL, clippingDrawableIndices: Int32Array, clipCount: number);
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	/**
	 * このマスクにクリップされる描画オブジェクトを追加する
	 *
	 * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス
	 */
	addClippedDrawable(drawableIndex: number): void;
	/**
	 * このマスクを管理するマネージャのインスタンスを取得する
	 * @return クリッピングマネージャのインスタンス
	 */
	getClippingManager(): CubismClippingManager_WebGL;
	setGl(gl: WebGLRenderingContext): void;
	_isUsing: boolean;
	readonly _clippingIdList: Int32Array;
	_clippingIdCount: number;
	_layoutChannelNo: number;
	_layoutBounds: csmRect;
	_allClippedDrawRect: csmRect;
	_matrixForMask: CubismMatrix44;
	_matrixForDraw: CubismMatrix44;
	_clippedDrawableIndexList: number[];
	private _owner;
}
declare class CubismRenderer_WebGL extends CubismRenderer {
	/**
	 * レンダラの初期化処理を実行する
	 * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
	 *
	 * @param model モデルのインスタンス
	 */
	initialize(model: CubismModel): void;
	/**
	 * WebGLテクスチャのバインド処理
	 * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする
	 * @param modelTextureNo セットするモデルテクスチャの番号
	 * @param glTextureNo WebGLテクスチャの番号
	 */
	bindTexture(modelTextureNo: number, glTexture: WebGLTexture): void;
	/**
	 * WebGLにバインドされたテクスチャのリストを取得する
	 * @return テクスチャのリスト
	 */
	getBindedTextures(): Record<number, WebGLTexture>;
	/**
	 * クリッピングマスクバッファのサイズを設定する
	 * マスク用のFrameBufferを破棄、再作成する為処理コストは高い
	 * @param size クリッピングマスクバッファのサイズ
	 */
	setClippingMaskBufferSize(size: number): void;
	/**
	 * クリッピングマスクバッファのサイズを取得する
	 * @return クリッピングマスクバッファのサイズ
	 */
	getClippingMaskBufferSize(): number;
	/**
	 * コンストラクタ
	 */
	constructor();
	/**
	 * デストラクタ相当の処理
	 */
	release(): void;
	/**
	 * モデルを描画する実際の処理
	 */
	doDrawModel(): void;
	/**
	 * [オーバーライド]
	 * 描画オブジェクト（アートメッシュ）を描画する。
	 * ポリゴンメッシュとテクスチャ番号をセットで渡す。
	 * @param textureNo 描画するテクスチャ番号
	 * @param indexCount 描画オブジェクトのインデックス値
	 * @param vertexCount ポリゴンメッシュの頂点数
	 * @param indexArray ポリゴンメッシュのインデックス配列
	 * @param vertexArray ポリゴンメッシュの頂点配列
	 * @param uvArray uv配列
	 * @param opacity 不透明度
	 * @param colorBlendMode カラー合成タイプ
	 * @param invertedMask マスク使用時のマスクの反転使用
	 */
	drawMesh(textureNo: number, indexCount: number, vertexCount: number, indexArray: Uint16Array, vertexArray: Float32Array, uvArray: Float32Array, opacity: number, colorBlendMode: CubismBlendMode, invertedMask: boolean): void;
	/**
	 * レンダラが保持する静的なリソースを解放する
	 * WebGLの静的なシェーダープログラムを解放する
	 */
	static doStaticRelease(): void;
	/**
	 * レンダーステートを設定する
	 * @param fbo アプリケーション側で指定しているフレームバッファ
	 * @param viewport ビューポート
	 */
	setRenderState(fbo: WebGLFramebuffer, viewport: number[]): void;
	/**
	 * 描画開始時の追加処理
	 * モデルを描画する前にクリッピングマスクに必要な処理を実装している
	 */
	preDraw(): void;
	/**
	 * マスクテクスチャに描画するクリッピングコンテキストをセットする
	 */
	setClippingContextBufferForMask(clip: CubismClippingContext | null): void;
	/**
	 * マスクテクスチャに描画するクリッピングコンテキストを取得する
	 * @return マスクテクスチャに描画するクリッピングコンテキスト
	 */
	getClippingContextBufferForMask(): CubismClippingContext | null;
	/**
	 * 画面上に描画するクリッピングコンテキストをセットする
	 */
	setClippingContextBufferForDraw(clip: CubismClippingContext | null): void;
	/**
	 * 画面上に描画するクリッピングコンテキストを取得する
	 * @return 画面上に描画するクリッピングコンテキスト
	 */
	getClippingContextBufferForDraw(): CubismClippingContext | null;
	/**
	 * glの設定
	 */
	startUp(gl: WebGLRenderingContext): void;
	_textures: Record<number, WebGLTexture>;
	_sortedDrawableIndexList: number[];
	_clippingManager: CubismClippingManager_WebGL;
	_clippingContextBufferForMask: CubismClippingContext | null;
	_clippingContextBufferForDraw: CubismClippingContext | null;
	firstDraw: boolean;
	_bufferData: {
		vertex: WebGLBuffer | null;
		uv: WebGLBuffer | null;
		index: WebGLBuffer | null;
	};
	gl: WebGLRenderingContext;
}
export declare class Cubism4InternalModel extends InternalModel {
	settings: Cubism4ModelSettings;
	coreModel: CubismModel;
	motionManager: Cubism4MotionManager;
	lipSync: boolean;
	breath: CubismBreath;
	eyeBlink?: CubismEyeBlink;
	pose?: CubismPose;
	physics?: CubismPhysics;
	userData?: CubismModelUserData;
	renderer: CubismRenderer_WebGL;
	idParamAngleX: string;
	idParamAngleY: string;
	idParamAngleZ: string;
	idParamEyeBallX: string;
	idParamEyeBallY: string;
	idParamBodyAngleX: string;
	idParamBreath: string;
	/**
	 * The model's internal scale, defined in the moc3 file.
	 */
	readonly pixelsPerUnit: number;
	/**
	 * Matrix that scales by {@link pixelsPerUnit}, and moves the origin from top-left to center.
	 *
	 * FIXME: This shouldn't be named as "centering"...
	 */
	protected centeringTransform: Matrix;
	constructor(coreModel: CubismModel, settings: Cubism4ModelSettings, options?: InternalModelOptions);
	protected init(): void;
	protected getSize(): [
		number,
		number
	];
	protected getLayout(): CommonLayout;
	protected setupLayout(): void;
	updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void;
	bindTexture(index: number, texture: WebGLTexture): void;
	protected getHitAreaDefs(): CommonHitArea[];
	getDrawableIDs(): string[];
	getDrawableIndex(id: string): number;
	getDrawableVertices(drawIndex: number | string): Float32Array;
	updateTransform(transform: Matrix): void;
	update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	updateFocus(): void;
	updateNaturalMovements(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void;
	draw(gl: WebGLRenderingContext): void;
	destroy(): void;
}
export interface CubismStartupOption {
	logFunction: Live2DCubismCore.csmLogFunction;
	loggingLevel: LogLevel;
}
declare enum LogLevel {
	LogLevel_Verbose = 0,
	LogLevel_Debug = 1,
	LogLevel_Info = 2,
	LogLevel_Warning = 3,
	LogLevel_Error = 4,
	LogLevel_Off = 5
}
/**
 * Promises the Cubism 4 runtime has been started up.
 * @return Promise that resolves if the startup has succeeded, rejects if failed.
 */
export declare function cubism4Ready(): Promise<void>;
/**
 * Starts up the Cubism 4 runtime.
 */
export declare function startUpCubism4(options?: CubismStartupOption): void;

export {};
