(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@pixi/utils"), require("@pixi/math"), require("@pixi/core"), require("lodash/pull"), require("@pixi/display"), require("lodash/mapKeys"));
	else if(typeof define === 'function' && define.amd)
		define(["@pixi/utils", "@pixi/math", "@pixi/core", "lodash/pull", "@pixi/display", "lodash/mapKeys"], factory);
	else if(typeof exports === 'object')
		exports["pixi-live2d-display"] = factory(require("@pixi/utils"), require("@pixi/math"), require("@pixi/core"), require("lodash/pull"), require("@pixi/display"), require("lodash/mapKeys"));
	else
		root["PIXI"] = root["PIXI"] || {}, root["PIXI"]["live2d"] = factory(root["PIXI"]["utils"], root["PIXI"], root["PIXI"], root["lodash/pull"], root["PIXI"], root["lodash/mapKeys"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__17__, __WEBPACK_EXTERNAL_MODULE__19__, __WEBPACK_EXTERNAL_MODULE__20__, __WEBPACK_EXTERNAL_MODULE__24__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 27);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ log_logger; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ clamp; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ rand; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ copyProperty; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ copyArray; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ applyMixins; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ folderName; });

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(1);

// CONCATENATED MODULE: ./src/utils/log.ts

/**
 * A simple tagged logger.
 *
 * You can replace the methods with your own ones.
 *
 * ```js
 * import { logger } from 'pixi-live2d-display';
 *
 * logger.log = (tag, ...messages) => {
 *     console.log(tag, 'says:', ...messages);
 * };
 * ```
 */
var log_logger;
(function (logger) {
    function log(tag, ...messages) {
        if (config["b" /* config */].logLevel <= config["b" /* config */].LOG_LEVEL_VERBOSE) {
            console.log(`[${tag}]`, ...messages);
        }
    }
    logger.log = log;
    function warn(tag, ...messages) {
        if (config["b" /* config */].logLevel <= config["b" /* config */].LOG_LEVEL_WARNING) {
            console.warn(`[${tag}]`, ...messages);
        }
    }
    logger.warn = warn;
    function error(tag, ...messages) {
        if (config["b" /* config */].logLevel <= config["b" /* config */].LOG_LEVEL_ERROR) {
            console.error(`[${tag}]`, ...messages);
        }
    }
    logger.error = error;
})(log_logger || (log_logger = {}));

// CONCATENATED MODULE: ./src/utils/math.ts
/**
 * These functions can be slightly faster than the ones in Lodash.
 * @packageDocumentation
 */
function clamp(num, lower, upper) {
    return num < lower ? lower : num > upper ? upper : num;
}
function rand(min, max) {
    return Math.random() * (max - min) + min;
}

// CONCATENATED MODULE: ./src/utils/obj.ts
/**
 * Copies a property at only if it matches the `type`.
 * @param type - Type expected to match `typeof` on the property.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the property in source object.
 * @param toKey - Key of the property in destination object.
 */
// TODO: lint and fix the formatting!
function copyProperty(type, from, to, fromKey, toKey) {
    const value = from[fromKey];
    if (value !== null && typeof value === type) {
        // a type error will occur here, have no idea
        to[toKey] = value;
    }
}
/**
 * Copies an array at `key`, filtering the items that match the `type`.
 * @param type - Type expected to match `typeof` on the items.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the array property in source object.
 * @param toKey - Key of the array property in destination object.
 */
function copyArray(type, from, to, fromKey, toKey) {
    const array = from[fromKey];
    if (Array.isArray(array)) {
        to[toKey] = array.filter(item => item !== null && typeof item === type);
    }
}
/**
 * @see {@link https://www.typescriptlang.org/docs/handbook/mixins.html}
 */
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            if (name !== 'constructor') {
                Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }
        });
    });
}

// CONCATENATED MODULE: ./src/utils/string.ts
/**
 * Gets the name of parent folder in a url.
 * @param url - URL of a file.
 * @return Name of the parent folder, or the file itself if it has no parent folder.
 */
function folderName(url) {
    let lastSlashIndex = url.lastIndexOf('/');
    if (lastSlashIndex != -1) {
        url = url.slice(0, lastSlashIndex);
    }
    lastSlashIndex = url.lastIndexOf('/');
    if (lastSlashIndex !== -1) {
        url = url.slice(lastSlashIndex + 1);
    }
    return url;
}

// CONCATENATED MODULE: ./src/utils/index.ts






/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VERSION; });
/**
 * Global configs.
 */
var config;
(function (config) {
    config.LOG_LEVEL_VERBOSE = 0;
    config.LOG_LEVEL_WARNING = 1;
    config.LOG_LEVEL_ERROR = 2;
    config.LOG_LEVEL_NONE = 999;
    /**
     * Global log level.
     * @default {@link LOG_LEVEL_WARNING}
     */
    config.logLevel =  true ? config.LOG_LEVEL_WARNING : undefined;
    /**
     * Enabling sound for motions.
     */
    config.sound = true;
    /**
     * Deferring motion and corresponding sound until both are loaded.
     */
    config.motionSync = true;
    /**
     * Default fading duration for motions without such value specified.
     */
    config.motionFadingDuration = 500;
    /**
     * Default fading duration for idle motions without such value specified.
     */
    config.idleMotionFadingDuration = 2000;
    /**
     * Default fading duration for expressions without such value specified.
     */
    config.expressionFadingDuration = 500;
})(config || (config = {}));
/**
 * Consistent with the `version` in package.json.
 */
const VERSION = "0.3.1";


/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Live2DLoader; });
/* harmony import */ var _factory_XHRLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _utils_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);


class Live2DLoader {
    /**
     * Loads a resource.
     * @return Promise that resolves with the loaded data in a format that's consistent with the specified `type`.
     */
    static load(context) {
        return Object(_utils_middleware__WEBPACK_IMPORTED_MODULE_1__[/* runMiddlewares */ "a"])(this.middlewares, context).then(() => context.result);
    }
}
Live2DLoader.middlewares = [_factory_XHRLoader__WEBPACK_IMPORTED_MODULE_0__[/* XHRLoader */ "a"].loader];


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Live2DFactory_Live2DFactory; });

// EXTERNAL MODULE: ./src/cubism-common/index.ts
var cubism_common = __webpack_require__(6);

// EXTERNAL MODULE: ./src/factory/Live2DLoader.ts
var Live2DLoader = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/index.ts + 4 modules
var utils = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/middleware.ts
var middleware = __webpack_require__(16);

// EXTERNAL MODULE: external {"commonjs":"@pixi/core","commonjs2":"@pixi/core","amd":"@pixi/core","root":"PIXI"}
var core_root_PIXI_ = __webpack_require__(17);

// CONCATENATED MODULE: ./src/factory/texture.ts

function createTexture(url, options = {}) {
    var _a;
    const textureOptions = { resourceOptions: { crossorigin: options.crossOrigin } };
    // there's already such a method since Pixi v5.3.0
    if (core_root_PIXI_["Texture"].fromURL) {
        return core_root_PIXI_["Texture"].fromURL(url, textureOptions).catch(e => {
            if (e instanceof Error) {
                throw e;
            }
            // assume e is an ErrorEvent, let's convert it to an Error
            const err = new Error('Texture loading error');
            err.event = e;
            throw err;
        });
    }
    // and in order to provide backward compatibility for older Pixi versions,
    // we have to manually implement this method
    // see https://github.com/pixijs/pixi.js/pull/6687/files
    textureOptions.resourceOptions.autoLoad = false;
    const texture = core_root_PIXI_["Texture"].from(url, textureOptions);
    if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
    }
    const resource = texture.baseTexture.resource;
    // before Pixi v5.2.2, the Promise will not be rejected when loading has failed,
    // we have to manually handle the "error" event
    // see https://github.com/pixijs/pixi.js/pull/6374
    (_a = resource._live2d_load) !== null && _a !== void 0 ? _a : (resource._live2d_load = new Promise((resolve, reject) => {
        const errorHandler = (event) => {
            resource.source.removeEventListener('error', errorHandler);
            // convert the ErrorEvent to an Error
            const err = new Error('Texture loading error');
            err.event = event;
            reject(err);
        };
        resource.source.addEventListener('error', errorHandler);
        resource.load().then(() => resolve(texture)).catch(errorHandler);
    }));
    return resource._live2d_load;
}

// CONCATENATED MODULE: ./src/factory/model-middlewares.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const TAG = 'Live2DFactory';
/**
 * A middleware that converts the source from a URL to a settings JSON object.
 */
const urlToJSON = (context, next) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof context.source === 'string') {
        const data = yield Live2DLoader["a" /* Live2DLoader */].load({
            url: context.source,
            type: 'json',
            target: context.live2dModel,
        });
        data.url = context.source;
        context.source = data;
        context.live2dModel.emit('settingsJSONLoaded', data);
    }
    return next();
});
/**
 * A middleware that converts the source from a settings JSON object to a ModelSettings instance.
 */
const jsonToSettings = (context, next) => __awaiter(void 0, void 0, void 0, function* () {
    if (context.source instanceof cubism_common["f" /* ModelSettings */]) {
        context.settings = context.source;
        return next();
    }
    else if (typeof context.source === 'object') {
        const runtime = Live2DFactory_Live2DFactory.findRuntime(context.source);
        if (runtime) {
            const settings = runtime.createModelSettings(context.source);
            context.settings = settings;
            context.live2dModel.emit('settingsLoaded', settings);
            return next();
        }
    }
    throw new TypeError('Unknown settings format.');
});
const waitUntilReady = (context, next) => {
    if (context.settings) {
        const runtime = Live2DFactory_Live2DFactory.findRuntime(context.settings);
        if (runtime) {
            return runtime.ready().then(next);
        }
    }
    return next();
};
/**
 * A middleware that populates the Live2DModel with optional resources.
 * Requires InternalModel in context when all the subsequent middlewares have finished.
 */
const setupOptionals = (context, next) => __awaiter(void 0, void 0, void 0, function* () {
    // wait until all has finished
    yield next();
    const internalModel = context.internalModel;
    if (internalModel) {
        const settings = context.settings;
        const runtime = Live2DFactory_Live2DFactory.findRuntime(settings);
        if (runtime) {
            const tasks = [];
            if (settings.pose) {
                tasks.push(Live2DLoader["a" /* Live2DLoader */].load({
                    settings,
                    url: settings.pose,
                    type: 'json',
                    target: internalModel,
                })
                    .then((data) => {
                    internalModel.pose = runtime.createPose(internalModel.coreModel, data);
                    context.live2dModel.emit('poseLoaded', internalModel.pose);
                })
                    .catch((e) => utils["f" /* logger */].warn(TAG, 'Failed to load pose.\n', e)));
            }
            if (settings.physics) {
                tasks.push(Live2DLoader["a" /* Live2DLoader */].load({
                    settings,
                    url: settings.physics,
                    type: 'json',
                    target: internalModel,
                })
                    .then((data) => {
                    internalModel.physics = runtime.createPhysics(internalModel.coreModel, data);
                    context.live2dModel.emit('physicsLoaded', internalModel.physics);
                })
                    .catch((e) => utils["f" /* logger */].warn(TAG, 'Failed to load physics.\n', e)));
            }
            if (tasks.length) {
                yield Promise.all(tasks);
            }
        }
    }
});
/**
 * A middleware that populates the Live2DModel with essential resources.
 * Requires ModelSettings in context immediately, and InternalModel in context
 * when all the subsequent middlewares have finished.
 */
const setupEssentials = (context, next) => __awaiter(void 0, void 0, void 0, function* () {
    if (context.settings) {
        const live2DModel = context.live2dModel;
        const textureLoadings = context.settings.textures.map(tex => {
            const url = context.settings.resolveURL(tex);
            return createTexture(url, { crossOrigin: context.options.crossOrigin });
        });
        // wait for the internal model to be created
        yield next();
        if (context.internalModel) {
            live2DModel.internalModel = context.internalModel;
            live2DModel.emit('modelLoaded', context.internalModel);
        }
        else {
            throw new TypeError('Missing internal model.');
        }
        live2DModel.textures = yield Promise.all(textureLoadings);
        live2DModel.emit('textureLoaded', live2DModel.textures);
    }
    else {
        throw new TypeError('Missing settings.');
    }
});
/**
 * A middleware that creates the InternalModel. Requires ModelSettings in context.
 */
const createInternalModel = (context, next) => __awaiter(void 0, void 0, void 0, function* () {
    const settings = context.settings;
    if (settings instanceof cubism_common["f" /* ModelSettings */]) {
        const runtime = Live2DFactory_Live2DFactory.findRuntime(settings);
        if (!runtime) {
            throw new TypeError('Unknown model settings.');
        }
        const modelData = yield Live2DLoader["a" /* Live2DLoader */].load({
            settings,
            url: settings.moc,
            type: 'arraybuffer',
            target: context.live2dModel,
        });
        if (!runtime.isValidMoc(modelData)) {
            throw new Error('Invalid moc data');
        }
        const coreModel = runtime.createCoreModel(modelData);
        context.internalModel = runtime.createInternalModel(coreModel, settings, context.options);
        return next();
    }
    throw new TypeError('Missing settings.');
});

// CONCATENATED MODULE: ./src/factory/Live2DFactory.ts
var Live2DFactory_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





/**
 * Handles all the network load tasks.
 *
 * - Model creation: requested by {@link Live2DModel.from}.
 * - Motion loading: implements the load method of MotionManager.
 * - Expression loading: implements the load method of ExpressionManager.
 */
class Live2DFactory_Live2DFactory {
    /**
     * Registers a Live2DRuntime.
     */
    static registerRuntime(runtime) {
        Live2DFactory_Live2DFactory.runtimes.push(runtime);
        // higher version as higher priority
        Live2DFactory_Live2DFactory.runtimes.sort((a, b) => b.version - a.version);
    }
    /**
     * Finds a runtime that matches given source.
     * @param source - Either a settings JSON object or a ModelSettings instance.
     * @return The Live2DRuntime, or undefined if not found.
     */
    static findRuntime(source) {
        for (const runtime of Live2DFactory_Live2DFactory.runtimes) {
            if (runtime.test(source)) {
                return runtime;
            }
        }
    }
    /**
     * Sets up a Live2DModel, populating it with all defined resources.
     * @param live2dModel - The Live2DModel instance.
     * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
     * @param options - Options for the process.
     * @return Promise that resolves when all resources have been loaded, rejects when error occurs.
     */
    static setupLive2DModel(live2dModel, source, options) {
        return Live2DFactory_awaiter(this, void 0, void 0, function* () {
            const textureLoaded = new Promise(resolve => live2dModel.once('textureLoaded', resolve));
            const modelLoaded = new Promise(resolve => live2dModel.once('modelLoaded', resolve));
            // because the "ready" event is supposed to be emitted after
            // both the internal model and textures have been loaded,
            // we should here wrap the emit() in a then() so it'll
            // be executed after all the handlers of "modelLoaded" and "textureLoaded"
            const readyEventEmitted = Promise.all([textureLoaded, modelLoaded]).then(() => live2dModel.emit('ready'));
            yield Object(middleware["a" /* runMiddlewares */])(Live2DFactory_Live2DFactory.live2DModelMiddlewares, {
                live2dModel,
                source,
                options: options || {},
            });
            // the "load" event should never be emitted before "ready"
            yield readyEventEmitted;
            live2dModel.emit('load');
        });
    }
    /**
     * Loads a Motion and registers the task to {@link motionTasksMap}. The task will be automatically
     * canceled when its owner - the MotionManager instance - has been destroyed.
     * @param motionManager - MotionManager that owns this Motion.
     * @param group - The motion group.
     * @param index - Index in the motion group.
     * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
     */
    static loadMotion(motionManager, group, index) {
        var _a, _b;
        // errors in this method are always handled
        const handleError = (e) => motionManager.emit('motionLoadError', group, index, e);
        try {
            const definition = (_a = motionManager.definitions[group]) === null || _a === void 0 ? void 0 : _a[index];
            if (!definition) {
                return Promise.resolve(undefined);
            }
            if (!motionManager.listeners('destroy').includes(Live2DFactory_Live2DFactory.releaseTasks)) {
                motionManager.once('destroy', Live2DFactory_Live2DFactory.releaseTasks);
            }
            let tasks = Live2DFactory_Live2DFactory.motionTasksMap.get(motionManager);
            if (!tasks) {
                tasks = {};
                Live2DFactory_Live2DFactory.motionTasksMap.set(motionManager, tasks);
            }
            let taskGroup = tasks[group];
            if (!taskGroup) {
                taskGroup = [];
                tasks[group] = taskGroup;
            }
            const path = motionManager.getMotionFile(definition);
            (_b = taskGroup[index]) !== null && _b !== void 0 ? _b : (taskGroup[index] = Live2DLoader["a" /* Live2DLoader */].load({
                url: path,
                settings: motionManager.settings,
                type: motionManager.motionDataType,
                target: motionManager,
            })
                .then(data => {
                var _a;
                const taskGroup = (_a = Live2DFactory_Live2DFactory.motionTasksMap.get(motionManager)) === null || _a === void 0 ? void 0 : _a[group];
                if (taskGroup) {
                    delete taskGroup[index];
                }
                const motion = motionManager.createMotion(data, group, definition);
                motionManager.emit('motionLoaded', group, index, motion);
                return motion;
            })
                .catch(e => {
                utils["f" /* logger */].warn(motionManager.tag, `Failed to load motion: ${path}\n`, e);
                handleError(e);
            }));
            return taskGroup[index];
        }
        catch (e) {
            utils["f" /* logger */].warn(motionManager.tag, `Failed to load motion at "${group}"[${index}]\n`, e);
            handleError(e);
        }
        return Promise.resolve(undefined);
    }
    /**
     * Loads an Expression and registers the task to {@link expressionTasksMap}. The task will be automatically
     * canceled when its owner - the ExpressionManager instance - has been destroyed.
     * @param expressionManager - ExpressionManager that owns this Expression.
     * @param index - Index of the Expression.
     * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
     */
    static loadExpression(expressionManager, index) {
        var _a;
        // errors in this method are always handled
        const handleError = (e) => expressionManager.emit('expressionLoadError', index, e);
        try {
            const definition = expressionManager.definitions[index];
            if (!definition) {
                return Promise.resolve(undefined);
            }
            if (!expressionManager.listeners('destroy').includes(Live2DFactory_Live2DFactory.releaseTasks)) {
                expressionManager.once('destroy', Live2DFactory_Live2DFactory.releaseTasks);
            }
            let tasks = Live2DFactory_Live2DFactory.expressionTasksMap.get(expressionManager);
            if (!tasks) {
                tasks = [];
                Live2DFactory_Live2DFactory.expressionTasksMap.set(expressionManager, tasks);
            }
            const path = expressionManager.getExpressionFile(definition);
            (_a = tasks[index]) !== null && _a !== void 0 ? _a : (tasks[index] = Live2DLoader["a" /* Live2DLoader */].load({
                url: path,
                settings: expressionManager.settings,
                type: 'json',
                target: expressionManager,
            })
                .then(data => {
                const tasks = Live2DFactory_Live2DFactory.expressionTasksMap.get(expressionManager);
                if (tasks) {
                    delete tasks[index];
                }
                const expression = expressionManager.createExpression(data, definition);
                expressionManager.emit('expressionLoaded', index, expression);
                return expression;
            })
                .catch(e => {
                utils["f" /* logger */].warn(expressionManager.tag, `Failed to load expression: ${path}\n`, e);
                handleError(e);
            }));
            return tasks[index];
        }
        catch (e) {
            utils["f" /* logger */].warn(expressionManager.tag, `Failed to load expression at [${index}]\n`, e);
            handleError(e);
        }
        return Promise.resolve(undefined);
    }
    static releaseTasks() {
        if (this instanceof cubism_common["g" /* MotionManager */]) {
            Live2DFactory_Live2DFactory.motionTasksMap.delete(this);
        }
        else {
            Live2DFactory_Live2DFactory.expressionTasksMap.delete(this);
        }
    }
}
/**
 * All registered runtimes, sorted by versions in descending order.
 */
Live2DFactory_Live2DFactory.runtimes = [];
Live2DFactory_Live2DFactory.urlToJSON = urlToJSON;
Live2DFactory_Live2DFactory.jsonToSettings = jsonToSettings;
Live2DFactory_Live2DFactory.waitUntilReady = waitUntilReady;
Live2DFactory_Live2DFactory.setupOptionals = setupOptionals;
Live2DFactory_Live2DFactory.setupEssentials = setupEssentials;
Live2DFactory_Live2DFactory.createInternalModel = createInternalModel;
/**
 * Middlewares to run through when setting up a Live2DModel.
 */
Live2DFactory_Live2DFactory.live2DModelMiddlewares = [
    urlToJSON, jsonToSettings, waitUntilReady, setupOptionals, setupEssentials, createInternalModel,
];
/**
 * load tasks of each motion. The structure of each value in this map
 * is the same as respective {@link MotionManager.definitions}.
 */
Live2DFactory_Live2DFactory.motionTasksMap = new WeakMap();
/**
 * Load tasks of each expression.
 */
Live2DFactory_Live2DFactory.expressionTasksMap = new WeakMap();
cubism_common["g" /* MotionManager */].prototype._loadMotion = function (group, index) {
    return Live2DFactory_Live2DFactory.loadMotion(this, group, index);
};
cubism_common["a" /* ExpressionManager */].prototype._loadExpression = function (index) {
    return Live2DFactory_Live2DFactory.loadExpression(this, index);
};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__5__;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "e", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony import */ var _ExpressionManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _ExpressionManager__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _FocusController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _FocusController__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _ModelSettings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "f", function() { return _ModelSettings__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony import */ var _MotionState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "i", function() { return _MotionState__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "j", function() { return _MotionState__WEBPACK_IMPORTED_MODULE_4__["b"]; });

/* harmony import */ var _MotionManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "g", function() { return _MotionManager__WEBPACK_IMPORTED_MODULE_5__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "h", function() { return _MotionManager__WEBPACK_IMPORTED_MODULE_5__["b"]; });

/* harmony import */ var _SoundManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "k", function() { return _SoundManager__WEBPACK_IMPORTED_MODULE_6__["a"]; });

/* harmony import */ var _InternalModel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _InternalModel__WEBPACK_IMPORTED_MODULE_7__["a"]; });











/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SoundManager; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var lodash_pull__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var lodash_pull__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_pull__WEBPACK_IMPORTED_MODULE_1__);


const TAG = 'SoundManager';
const VOLUME = 0.5;
/**
 * Manages all the sounds.
 */
class SoundManager {
    /**
     * Global volume that applies to all the sounds.
     */
    static get volume() {
        return this._volume;
    }
    static set volume(value) {
        this._volume = (value > 1 ? 1 : value < 0 ? 0 : value) || 0;
        this.audios.forEach(audio => (audio.volume = this._volume));
    }
    // TODO: return an ID?
    /**
     * Creates an audio element and adds it to the {@link audios}.
     * @param file - URL of the sound file.
     * @param onFinish - Callback invoked when the playback has finished.
     * @param onError - Callback invoked when error occurs.
     * @return Created audio element.
     */
    static add(file, onFinish, onError) {
        const audio = new Audio(file);
        audio.volume = this._volume;
        audio.preload = 'auto';
        audio.addEventListener('ended', () => {
            this.dispose(audio);
            onFinish === null || onFinish === void 0 ? void 0 : onFinish();
        });
        audio.addEventListener('error', (e) => {
            this.dispose(audio);
            _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].warn(TAG, `Error occurred on "${file}"`, e.error);
            onError === null || onError === void 0 ? void 0 : onError(e.error);
        });
        this.audios.push(audio);
        return audio;
    }
    /**
     * Plays the sound.
     * @param audio - An audio element.
     * @return Promise that resolves when the audio is ready to play, rejects when error occurs.
     */
    static play(audio) {
        return new Promise((resolve, reject) => {
            var _a;
            // see https://developers.google.com/web/updates/2017/09/autoplay-policy-changes
            (_a = audio.play()) === null || _a === void 0 ? void 0 : _a.catch(e => {
                audio.dispatchEvent(new ErrorEvent('error', { error: e }));
                reject(e);
            });
            if (audio.readyState === audio.HAVE_ENOUGH_DATA) {
                resolve();
            }
            else {
                audio.addEventListener('canplaythrough', resolve);
            }
        });
    }
    /**
     * Disposes an audio element and removes it from {@link audios}.
     * @param audio - An audio element.
     */
    static dispose(audio) {
        audio.pause();
        audio.removeAttribute('src');
        lodash_pull__WEBPACK_IMPORTED_MODULE_1___default()(this.audios, audio);
    }
    /**
     * Destroys all managed audios.
     */
    static destroy() {
        // dispose() removes given audio from the array, so the loop must be backward
        for (let i = this.audios.length - 1; i >= 0; i--) {
            this.dispose(this.audios[i]);
        }
    }
}
/**
 * Audio elements playing or pending to play. Finished audios will be removed automatically.
 */
SoundManager.audios = [];
SoundManager._volume = VOLUME;


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LOGICAL_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LOGICAL_HEIGHT; });
const LOGICAL_WIDTH = 2;
const LOGICAL_HEIGHT = 2;


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MotionPriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MotionState; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);

/**
 * Indicates the motion priority.
 */
var MotionPriority;
(function (MotionPriority) {
    /** States that the model is currently not playing any motion. This priority cannot be applied to a motion. */
    MotionPriority[MotionPriority["NONE"] = 0] = "NONE";
    /** Low priority, used when starting idle motions automatically. */
    MotionPriority[MotionPriority["IDLE"] = 1] = "IDLE";
    /** Medium priority. */
    MotionPriority[MotionPriority["NORMAL"] = 2] = "NORMAL";
    /** High priority. Motions as this priority will always be played regardless of the current priority. */
    MotionPriority[MotionPriority["FORCE"] = 3] = "FORCE";
})(MotionPriority || (MotionPriority = {}));
/**
 * Handles the state of a MotionManager.
 */
class MotionState {
    constructor() {
        /**
         * When enabled, the states will be dumped to the logger when an exception occurs.
         */
        this.debug = false;
        /**
         * Priority of the current motion. Will be `MotionPriority.NONE` if there's no playing motion.
         */
        this.currentPriority = MotionPriority.NONE;
        /**
         * Priority of the reserved motion, which is still in loading and will be played once loaded.
         * Will be `MotionPriority.NONE` if there's no reserved motion.
         */
        this.reservePriority = MotionPriority.NONE;
    }
    /**
     * Reserves the playback for a motion.
     * @param group - The motion group.
     * @param index - Index in the motion group.
     * @param priority - The priority to be applied.
     * @return True if the reserving has succeeded.
     */
    reserve(group, index, priority) {
        if (priority <= MotionPriority.NONE) {
            _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, `Cannot start a motion with MotionPriority.NONE.`);
            return false;
        }
        if (group === this.currentGroup && index === this.currentIndex) {
            _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, `Motion is already playing.`, this.dump(group, index));
            return false;
        }
        if ((group === this.reservedGroup && index === this.reservedIndex) || (group === this.reservedIdleGroup && index === this.reservedIdleIndex)) {
            _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, `Motion is already reserved.`, this.dump(group, index));
            return false;
        }
        if (priority === MotionPriority.IDLE) {
            if (this.currentPriority !== MotionPriority.NONE) {
                _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, `Cannot start idle motion because another motion is playing.`, this.dump(group, index));
                return false;
            }
            if (this.reservedIdleGroup !== undefined) {
                _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, `Cannot start idle motion because another idle motion has reserved.`, this.dump(group, index));
                return false;
            }
            this.setReservedIdle(group, index);
        }
        else {
            if (priority < MotionPriority.FORCE) {
                if (priority <= this.currentPriority) {
                    _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, 'Cannot start motion because another motion is playing as an equivalent or higher priority.', this.dump(group, index));
                    return false;
                }
                if (priority <= this.reservePriority) {
                    _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, 'Cannot start motion because another motion has reserved as an equivalent or higher priority.', this.dump(group, index));
                    return false;
                }
            }
            this.setReserved(group, index, priority);
        }
        return true;
    }
    /**
     * Requests the playback for a motion.
     * @param motion - The Motion, can be undefined.
     * @param group - The motion group.
     * @param index - Index in the motion group.
     * @param priority - The priority to be applied.
     * @return True if the request has been approved, i.e. the motion is allowed to play.
     */
    start(motion, group, index, priority) {
        if (priority === MotionPriority.IDLE) {
            this.setReservedIdle(undefined, undefined);
            if (this.currentPriority !== MotionPriority.NONE) {
                _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, 'Cannot start idle motion because another motion is playing.', this.dump(group, index));
                return false;
            }
        }
        else {
            if (group !== this.reservedGroup || index !== this.reservedIndex) {
                _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].log(this.tag, 'Cannot start motion because another motion has taken the place.', this.dump(group, index));
                return false;
            }
            this.setReserved(undefined, undefined, MotionPriority.NONE);
        }
        if (!motion) {
            return false;
        }
        this.setCurrent(group, index, priority);
        return true;
    }
    /**
     * Notifies the motion playback has finished.
     */
    complete() {
        this.setCurrent(undefined, undefined, MotionPriority.NONE);
    }
    /**
     * Sets the current motion.
     */
    setCurrent(group, index, priority) {
        this.currentPriority = priority;
        this.currentGroup = group;
        this.currentIndex = index;
    }
    /**
     * Sets the reserved motion.
     */
    setReserved(group, index, priority) {
        this.reservePriority = priority;
        this.reservedGroup = group;
        this.reservedIndex = index;
    }
    /**
     * Sets the reserved idle motion.
     */
    setReservedIdle(group, index) {
        this.reservedIdleGroup = group;
        this.reservedIdleIndex = index;
    }
    /**
     * Checks if a Motion is currently playing or has reserved.
     * @return True if active.
     */
    isActive(group, index) {
        return (group === this.currentGroup && index === this.currentIndex)
            || (group === this.reservedGroup && index === this.reservedIndex)
            || (group === this.reservedIdleGroup && index === this.reservedIdleIndex);
    }
    /**
     * Resets the state.
     */
    reset() {
        this.setCurrent(undefined, undefined, MotionPriority.NONE);
        // make sure the reserved motions (if existing) won't start when they are loaded
        this.setReserved(undefined, undefined, MotionPriority.NONE);
        this.setReservedIdle(undefined, undefined);
    }
    /**
     * Checks if an idle motion should be requests to play.
     */
    shouldRequestIdleMotion() {
        return this.currentGroup === undefined && this.reservedIdleGroup === undefined;
    }
    /**
     * Checks if the model's expression should be overridden by the motion.
     */
    shouldOverrideExpression() {
        return this.currentPriority > MotionPriority.IDLE;
    }
    /**
     * Dumps the state for debugging.
     */
    dump(requestedGroup, requestedIndex) {
        if (this.debug) {
            const keys = [
                'currentPriority',
                'reservePriority',
                'currentGroup',
                'currentIndex',
                'reservedGroup',
                'reservedIndex',
                'reservedIdleGroup',
                'reservedIdleIndex',
            ];
            return `\n<Requested> group = "${requestedGroup}", index = ${requestedIndex}\n` + keys.map(key => '[' + key + '] ' + this[key]).join('\n');
        }
        return '';
    }
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExpressionManager; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_pixi_utils__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


/**
 * Abstract expression manager.
 * @emits {@link ExpressionManagerEvents}
 */
class ExpressionManager extends _pixi_utils__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"] {
    constructor(settings, options) {
        super();
        /**
         * The Expressions. The structure is the same as {@link definitions}, initially there's only
         * an empty array, which means all expressions will be `undefined`. When an Expression has
         * been loaded, it'll fill the place in which it should be; when it fails to load,
         * the place will be filled with `null`.
         */
        this.expressions = [];
        /**
         * The pending Expression.
         */
        this.reserveExpressionIndex = -1;
        /**
         * Flags the instance has been destroyed.
         */
        this.destroyed = false;
        this.settings = settings;
        this.tag = `ExpressionManager(${settings.name})`;
    }
    /**
     * Should be called in the constructor of derived class.
     */
    init() {
        this.defaultExpression = this.createExpression({}, undefined);
        this.currentExpression = this.defaultExpression;
        this.stopAllExpressions();
    }
    /**
     * Loads an Expression. Errors in this method will not be thrown,
     * but be emitted with an "expressionLoadError" event.
     * @param index - Index of the expression in definitions.
     * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
     * @emits {@link ExpressionManagerEvents.expressionLoaded}
     * @emits {@link ExpressionManagerEvents.expressionLoadError}
     */
    loadExpression(index) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.definitions[index]) {
                _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].warn(this.tag, `Undefined expression at [${index}]`);
                return undefined;
            }
            if (this.expressions[index] === null) {
                _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].warn(this.tag, `Cannot set expression at [${index}] because it's already failed in loading.`);
                return undefined;
            }
            if (this.expressions[index]) {
                return this.expressions[index];
            }
            const expression = yield this._loadExpression(index);
            this.expressions[index] = expression;
            return expression;
        });
    }
    /**
     * Loads the Expression. Will be implemented by Live2DFactory.
     * @ignore
     */
    _loadExpression(index) {
        throw new Error('Not implemented.');
    }
    /**
     * Sets a random Expression that differs from current one.
     * @return Promise that resolves with true if succeeded, with false otherwise.
     */
    setRandomExpression() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.definitions.length) {
                const availableIndices = [];
                for (let i = 0; i < this.definitions.length; i++) {
                    if (this.expressions[i] !== null
                        && this.expressions[i] !== this.currentExpression
                        && i !== this.reserveExpressionIndex) {
                        availableIndices.push(i);
                    }
                }
                if (availableIndices.length) {
                    const index = Math.floor(Math.random() * availableIndices.length);
                    return this.setExpression(index);
                }
            }
            return false;
        });
    }
    /**
     * Resets model's expression using {@link defaultExpression}.
     */
    resetExpression() {
        this._setExpression(this.defaultExpression);
    }
    /**
     * Restores model's expression to {@link currentExpression}.
     */
    restoreExpression() {
        this._setExpression(this.currentExpression);
    }
    /**
     * Sets an Expression.
     * @param index - Either the index, or the name of the expression.
     * @return Promise that resolves with true if succeeded, with false otherwise.
     */
    setExpression(index) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof index !== 'number') {
                index = this.getExpressionIndex(index);
            }
            if (!(index > -1 && index < this.definitions.length)) {
                return false;
            }
            if (index === this.expressions.indexOf(this.currentExpression)) {
                return false;
            }
            this.reserveExpressionIndex = index;
            const expression = yield this.loadExpression(index);
            if (!expression || this.reserveExpressionIndex !== index) {
                return false;
            }
            this.reserveExpressionIndex = -1;
            this.currentExpression = expression;
            this._setExpression(expression);
            return true;
        });
    }
    /**
     * Updates parameters of the core model.
     * @return True if the parameters are actually updated.
     */
    update(model, now) {
        if (!this.isFinished()) {
            return this.updateParameters(model, now);
        }
        return false;
    }
    /**
     * Destroys the instance.
     * @emits {@link ExpressionManagerEvents.destroy}
     */
    destroy() {
        this.destroyed = true;
        this.emit('destroy');
        const self = this;
        self.definitions = undefined;
        self.expressions = undefined;
    }
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ModelSettings; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_pixi_utils__WEBPACK_IMPORTED_MODULE_1__);


/**
 * Parses, and provides access to the settings JSON.
 */
class ModelSettings {
    /**
     * @param json - The settings JSON object.
     * @param json.url - The `url` field must be defined to specify the settings file's URL.
     */
    constructor(json) {
        this.json = json;
        let url = json.url;
        if (typeof url !== 'string') {
            // this is not allowed because it'll typically result in errors, including a
            // fatal error - an OOM that crashes the browser while initializing this cubism2 model,
            // I'm not kidding!
            throw new TypeError('The `url` field in settings JSON must be defined as a string.');
        }
        this.url = url;
        // set default name to folder's name
        this.name = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* folderName */ "e"])(this.url);
    }
    /**
     * Resolves a relative path using the {@link url}. This is used to resolve the resource files
     * defined in the settings.
     * @param path - Relative path.
     * @return Resolved path.
     */
    resolveURL(path) {
        return _pixi_utils__WEBPACK_IMPORTED_MODULE_1__["url"].resolve(this.url, path);
    }
    /**
     * Replaces the resource files by running each file through the `replacer`.
     * @param replacer - Invoked with two arguments: `(file, path)`, where `file` is the file definition,
     * and `path` is its property path in the ModelSettings instance. A string must be returned to be the replacement.
     *
     * ```js
     * modelSettings.replaceFiles((file, path) => {
     *     // file = "foo.moc", path = "moc"
     *     // file = "foo.png", path = "textures[0]"
     *     // file = "foo.mtn", path = "motions.idle[0].file"
     *     // file = "foo.motion3.json", path = "motions.idle[0].File"
     *
     *     return "bar/" + file;
     * });
     * ```
     */
    replaceFiles(replacer) {
        this.moc = replacer(this.moc, 'moc');
        if (this.pose !== undefined) {
            (this.pose = replacer(this.pose, 'pose'));
        }
        if (this.physics !== undefined) {
            (this.physics = replacer(this.physics, 'physics'));
        }
        for (let i = 0; i < this.textures.length; i++) {
            this.textures[i] = replacer(this.textures[i], `textures[${i}]`);
        }
    }
    ;
    /**
     * Retrieves all resource files defined in the settings.
     * @return A flat array of the paths of all resource files.
     *
     * ```js
     * modelSettings.getDefinedFiles();
     * // returns: ["foo.moc", "foo.png", ...]
     * ```
     */
    getDefinedFiles() {
        const files = [];
        this.replaceFiles((file) => {
            files.push(file);
            return file;
        });
        return files;
    }
    /**
     * Validates that the files defined in the settings exist in given files. Each file will be
     * resolved by {@link resolveURL} before comparison.
     * @param files - A flat array of file paths.
     * @return All the files which are defined in the settings and also exist in given files,
     * *including the optional files*.
     * @throws Error if any *essential* file is defined in settings but not included in given files.
     */
    validateFiles(files) {
        const assertFileExists = (expectedFile, shouldThrow) => {
            const actualPath = this.resolveURL(expectedFile);
            if (!files.includes(actualPath)) {
                if (shouldThrow) {
                    throw new Error(`File "${expectedFile}" is defined in settings, but doesn't exist in given files`);
                }
                return false;
            }
            return true;
        };
        const essentialFiles = [this.moc, ...this.textures];
        essentialFiles.forEach(texture => assertFileExists(texture, true));
        const definedFiles = this.getDefinedFiles();
        return definedFiles.filter(file => assertFileExists(file, false));
    }
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MotionPreloadStrategy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MotionManager; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _cubism_common_MotionState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var _cubism_common_SoundManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_pixi_utils__WEBPACK_IMPORTED_MODULE_4__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





/**
 * Indicates how the motions will be preloaded.
 */
var MotionPreloadStrategy;
(function (MotionPreloadStrategy) {
    /** Preload all the motions. */
    MotionPreloadStrategy["ALL"] = "ALL";
    /** Preload only the idle motions. */
    MotionPreloadStrategy["IDLE"] = "IDLE";
    /** No preload. */
    MotionPreloadStrategy["NONE"] = "NONE";
})(MotionPreloadStrategy || (MotionPreloadStrategy = {}));
/**
 * Handles the motion playback.
 * @emits {@link MotionManagerEvents}
 */
class MotionManager extends _pixi_utils__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"] {
    constructor(settings, options) {
        super();
        /**
         * The Motions. The structure is the same as {@link definitions}, initially each group contains
         * an empty array, which means all motions will be `undefined`. When a Motion has been loaded,
         * it'll fill the place in which it should be; when it fails to load, the place will be filled
         * with `null`.
         */
        this.motionGroups = {};
        /**
         * Maintains the state of this MotionManager.
         */
        this.state = new _cubism_common_MotionState__WEBPACK_IMPORTED_MODULE_1__[/* MotionState */ "b"]();
        /**
         * Flags there's a motion playing.
         */
        this.playing = false;
        /**
         * Flags the instances has been destroyed.
         */
        this.destroyed = false;
        this.settings = settings;
        this.tag = `MotionManager(${settings.name})`;
        this.state.tag = this.tag;
    }
    /**
     * Should be called in the constructor of derived class.
     */
    init(options) {
        if (options === null || options === void 0 ? void 0 : options.idleMotionGroup) {
            this.groups.idle = options.idleMotionGroup;
        }
        this.setupMotions(options);
        this.stopAllMotions();
    }
    /**
     * Sets up motions from the definitions, and preloads them according to the preload strategy.
     */
    setupMotions(options) {
        for (const group of Object.keys(this.definitions)) {
            // init with the same structure of definitions
            this.motionGroups[group] = [];
        }
        // preload motions
        let groups;
        switch (options === null || options === void 0 ? void 0 : options.motionPreload) {
            case MotionPreloadStrategy.NONE:
                return;
            case MotionPreloadStrategy.ALL:
                groups = Object.keys(this.definitions);
                break;
            case MotionPreloadStrategy.IDLE:
            default:
                groups = [this.groups.idle];
                break;
        }
        for (const group of groups) {
            if (this.definitions[group]) {
                for (let i = 0; i < this.definitions[group].length; i++) {
                    this.loadMotion(group, i).then();
                }
            }
        }
    }
    /**
     * Loads a Motion in a motion group. Errors in this method will not be thrown,
     * but be emitted with a "motionLoadError" event.
     * @param group - The motion group.
     * @param index - Index in the motion group.
     * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
     * @emits {@link MotionManagerEvents.motionLoaded}
     * @emits {@link MotionManagerEvents.motionLoadError}
     */
    loadMotion(group, index) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = this.definitions[group]) === null || _a === void 0 ? void 0 : _a[index])) {
                _utils__WEBPACK_IMPORTED_MODULE_3__[/* logger */ "f"].warn(this.tag, `Undefined motion at "${group}"[${index}]`);
                return undefined;
            }
            if (this.motionGroups[group][index] === null) {
                _utils__WEBPACK_IMPORTED_MODULE_3__[/* logger */ "f"].warn(this.tag, `Cannot start motion at "${group}"[${index}] because it's already failed in loading.`);
                return undefined;
            }
            if (this.motionGroups[group][index]) {
                return this.motionGroups[group][index];
            }
            const motion = yield this._loadMotion(group, index);
            if (this.destroyed) {
                return;
            }
            this.motionGroups[group][index] = motion !== null && motion !== void 0 ? motion : null;
            return motion;
        });
    }
    // TODO: remove
    /**
     * Loads the Motion. Will be implemented by Live2DFactory.
     * @ignore
     */
    _loadMotion(group, index) {
        throw new Error('Not implemented.');
    }
    /**
     * Starts a motion as given priority.
     * @param group - The motion group.
     * @param index - Index in the motion group.
     * @param priority - The priority to be applied.
     * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
     */
    startMotion(group, index, priority = _cubism_common_MotionState__WEBPACK_IMPORTED_MODULE_1__[/* MotionPriority */ "a"].NORMAL) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.state.reserve(group, index, priority)) {
                return false;
            }
            const definition = (_a = this.definitions[group]) === null || _a === void 0 ? void 0 : _a[index];
            if (!definition) {
                return false;
            }
            if (this.currentAudio) {
                // TODO: reuse the audio?
                _cubism_common_SoundManager__WEBPACK_IMPORTED_MODULE_2__[/* SoundManager */ "a"].dispose(this.currentAudio);
            }
            let audio;
            if (_config__WEBPACK_IMPORTED_MODULE_0__[/* config */ "b"].sound) {
                const soundURL = this.getSoundFile(definition);
                if (soundURL) {
                    try {
                        // start to load the audio
                        audio = _cubism_common_SoundManager__WEBPACK_IMPORTED_MODULE_2__[/* SoundManager */ "a"].add(this.settings.resolveURL(soundURL), () => this.currentAudio = undefined, () => this.currentAudio = undefined);
                        this.currentAudio = audio;
                    }
                    catch (e) {
                        _utils__WEBPACK_IMPORTED_MODULE_3__[/* logger */ "f"].warn(this.tag, 'Failed to create audio', soundURL, e);
                    }
                }
            }
            const motion = yield this.loadMotion(group, index);
            if (audio) {
                const readyToPlay = _cubism_common_SoundManager__WEBPACK_IMPORTED_MODULE_2__[/* SoundManager */ "a"].play(audio)
                    .catch(e => _utils__WEBPACK_IMPORTED_MODULE_3__[/* logger */ "f"].warn(this.tag, 'Failed to play audio', audio.src, e));
                if (_config__WEBPACK_IMPORTED_MODULE_0__[/* config */ "b"].motionSync) {
                    // wait until the audio is ready
                    yield readyToPlay;
                }
            }
            if (!this.state.start(motion, group, index, priority)) {
                if (audio) {
                    _cubism_common_SoundManager__WEBPACK_IMPORTED_MODULE_2__[/* SoundManager */ "a"].dispose(audio);
                    this.currentAudio = undefined;
                }
                return false;
            }
            _utils__WEBPACK_IMPORTED_MODULE_3__[/* logger */ "f"].log(this.tag, 'Start motion:', this.getMotionName(definition));
            this.emit('motionStart', group, index, audio);
            if (this.state.shouldOverrideExpression()) {
                this.expressionManager && this.expressionManager.resetExpression();
            }
            this.playing = true;
            this._startMotion(motion);
            return true;
        });
    }
    /**
     * Starts a random Motion as given priority.
     * @param group - The motion group.
     * @param priority - The priority to be applied.
     * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
     */
    startRandomMotion(group, priority) {
        return __awaiter(this, void 0, void 0, function* () {
            const groupDefs = this.definitions[group];
            if (groupDefs === null || groupDefs === void 0 ? void 0 : groupDefs.length) {
                const availableIndices = [];
                for (let i = 0; i < groupDefs.length; i++) {
                    if (this.motionGroups[group][i] !== null && !this.state.isActive(group, i)) {
                        availableIndices.push(i);
                    }
                }
                if (availableIndices.length) {
                    const index = Math.floor(Math.random() * availableIndices.length);
                    return this.startMotion(group, availableIndices[index], priority);
                }
            }
            return false;
        });
    }
    /**
     * Stops all playing motions as well as the sound.
     */
    stopAllMotions() {
        this._stopAllMotions();
        this.state.reset();
        if (this.currentAudio) {
            _cubism_common_SoundManager__WEBPACK_IMPORTED_MODULE_2__[/* SoundManager */ "a"].dispose(this.currentAudio);
            this.currentAudio = undefined;
        }
    }
    /**
     * Updates parameters of the core model.
     * @param model - The core model.
     * @param now - Current time in milliseconds.
     * @return True if the parameters have been actually updated.
     */
    update(model, now) {
        var _a, _b;
        if (this.isFinished()) {
            if (this.playing) {
                this.playing = false;
                this.emit('motionFinish');
            }
            if (this.state.shouldOverrideExpression()) {
                (_a = this.expressionManager) === null || _a === void 0 ? void 0 : _a.restoreExpression();
            }
            this.state.complete();
            if (this.state.shouldRequestIdleMotion()) {
                // noinspection JSIgnoredPromiseFromCall
                this.startRandomMotion(this.groups.idle, _cubism_common_MotionState__WEBPACK_IMPORTED_MODULE_1__[/* MotionPriority */ "a"].IDLE);
            }
        }
        let updated = this.updateParameters(model, now);
        updated = ((_b = this.expressionManager) === null || _b === void 0 ? void 0 : _b.update(model, now)) || updated;
        return updated;
    }
    /**
     * Destroys the instance.
     * @emits {@link MotionManagerEvents.destroy}
     */
    destroy() {
        var _a;
        this.destroyed = true;
        this.emit('destroy');
        this.stopAllMotions();
        (_a = this.expressionManager) === null || _a === void 0 ? void 0 : _a.destroy();
        const self = this;
        self.definitions = undefined;
        self.motionGroups = undefined;
    }
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InternalModel; });
/* harmony import */ var _cubism_common_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _cubism_common_FocusController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_pixi_math__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_pixi_utils__WEBPACK_IMPORTED_MODULE_3__);




const tempBounds = { x: 0, y: 0, width: 0, height: 0 };
/**
 * A wrapper that manages the states of a Live2D core model, and delegates all operations to it.
 * @emits {@link InternalModelEvents}
 */
class InternalModel extends _pixi_utils__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"] {
    constructor() {
        super(...arguments);
        this.focusController = new _cubism_common_FocusController__WEBPACK_IMPORTED_MODULE_1__[/* FocusController */ "a"]();
        /**
         * Original canvas width of the model. Note this doesn't represent the model's real size,
         * as the model can overflow from its canvas.
         */
        this.originalWidth = 0;
        /**
         * Original canvas height of the model. Note this doesn't represent the model's real size,
         * as the model can overflow from its canvas.
         */
        this.originalHeight = 0;
        /**
         * Canvas width of the model, scaled by the `width` of the model's layout.
         */
        this.width = 0;
        /**
         * Canvas height of the model, scaled by the `height` of the model's layout.
         */
        this.height = 0;
        /**
         * Local transformation, calculated from the model's layout.
         */
        this.localTransform = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__["Matrix"]();
        /**
         * The final matrix to draw the model.
         */
        this.drawingMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__["Matrix"]();
        // TODO: change structure
        /**
         * The hit area definitions, keyed by their names.
         */
        this.hitAreas = {};
        /**
         * Flags whether `gl.UNPACK_FLIP_Y_WEBGL` should be enabled when binding the textures.
         */
        this.textureFlipY = false;
        /**
         * WebGL viewport when drawing the model. The format is `[x, y, width, height]`.
         */
        this.viewport = [0, 0, 0, 0];
        /**
         * Flags this instance has been destroyed.
         */
        this.destroyed = false;
    }
    /**
     * Should be called in the constructor of derived class.
     */
    init() {
        this.setupLayout();
        this.setupHitAreas();
    }
    /**
     * Sets up the model's size and local transform by the model's layout.
     */
    setupLayout() {
        // cast `this` to be mutable
        const self = this;
        const size = this.getSize();
        self.originalWidth = size[0];
        self.originalHeight = size[1];
        const layout = Object.assign({
            width: _cubism_common_constants__WEBPACK_IMPORTED_MODULE_0__[/* LOGICAL_WIDTH */ "b"],
            height: _cubism_common_constants__WEBPACK_IMPORTED_MODULE_0__[/* LOGICAL_HEIGHT */ "a"],
        }, this.getLayout());
        this.localTransform.scale(layout.width / _cubism_common_constants__WEBPACK_IMPORTED_MODULE_0__[/* LOGICAL_WIDTH */ "b"], layout.height / _cubism_common_constants__WEBPACK_IMPORTED_MODULE_0__[/* LOGICAL_HEIGHT */ "a"]);
        self.width = this.originalWidth * this.localTransform.a;
        self.height = this.originalHeight * this.localTransform.d;
        // this calculation differs from Live2D SDK...
        const offsetX = (layout.x !== undefined && layout.x - layout.width / 2)
            || (layout.centerX !== undefined && layout.centerX)
            || (layout.left !== undefined && layout.left - layout.width / 2)
            || (layout.right !== undefined && layout.right + layout.width / 2)
            || 0;
        const offsetY = (layout.y !== undefined && layout.y - layout.height / 2)
            || (layout.centerY !== undefined && layout.centerY)
            || (layout.top !== undefined && layout.top - layout.height / 2)
            || (layout.bottom !== undefined && layout.bottom + layout.height / 2)
            || 0;
        this.localTransform.translate(this.width * offsetX, -this.height * offsetY);
    }
    /**
     * Sets up the hit areas by their definitions in settings.
     */
    setupHitAreas() {
        const definitions = this.getHitAreaDefs().filter(hitArea => hitArea.index >= 0);
        for (const def of definitions) {
            this.hitAreas[def.name] = def;
        }
    }
    /**
     * Hit-test on the model.
     * @param x - Position in model canvas.
     * @param y - Position in model canvas.
     * @return The names of the *hit* hit areas. Can be empty if none is hit.
     */
    hitTest(x, y) {
        return Object.keys(this.hitAreas).filter(hitAreaName => this.isHit(hitAreaName, x, y));
    }
    /**
     * Hit-test for a single hit area.
     * @param hitAreaName - The hit area's name.
     * @param x - Position in model canvas.
     * @param y - Position in model canvas.
     * @return True if hit.
     */
    isHit(hitAreaName, x, y) {
        if (!this.hitAreas[hitAreaName]) {
            return false;
        }
        const drawIndex = this.hitAreas[hitAreaName].index;
        const bounds = this.getDrawableBounds(drawIndex, tempBounds);
        return bounds.x <= x && x <= bounds.x + bounds.width && bounds.y <= y && y <= bounds.y + bounds.height;
    }
    /**
     * Gets a drawable's bounds.
     * @param index - Index of the drawable.
     * @param bounds - Object to store the output values.
     * @return The bounds in model canvas space.
     */
    getDrawableBounds(index, bounds) {
        const vertices = this.getDrawableVertices(index);
        let left = vertices[0];
        let right = vertices[0];
        let top = vertices[1];
        let bottom = vertices[1];
        for (let i = 0; i < vertices.length; i += 2) {
            const vx = vertices[i];
            const vy = vertices[i + 1];
            left = Math.min(vx, left);
            right = Math.max(vx, right);
            top = Math.min(vy, top);
            bottom = Math.max(vy, bottom);
        }
        bounds !== null && bounds !== void 0 ? bounds : (bounds = {});
        bounds.x = left;
        bounds.y = top;
        bounds.width = right - left;
        bounds.height = bottom - top;
        return bounds;
    }
    /**
     * Updates the model's transform.
     * @param transform - The world transform.
     */
    updateTransform(transform) {
        this.drawingMatrix.copyFrom(transform).append(this.localTransform);
    }
    /**
     * Updates the model's parameters.
     * @param dt - Elapsed time in milliseconds from last frame.
     * @param now - Current time in milliseconds.
     */
    update(dt, now) {
        this.focusController.update(dt);
    }
    ;
    /**
     * Destroys the model and all related resources.
     * @emits {@link InternalModelEvents.destroy | destroy}
     */
    destroy() {
        this.destroyed = true;
        this.emit('destroy');
        this.motionManager.destroy();
        this.motionManager = undefined;
    }
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FocusController; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);

// Minimum distance to respond
const EPSILON = 0.01;
const MAX_SPEED = 40 / 7.5;
// the time to accelerate to max speed
const ACCELERATION_TIME = 1 / (0.15 * 1000);
/**
 * Interpolates the transition of focus position.
 */
class FocusController {
    constructor() {
        /** The focus position. */
        this.targetX = 0;
        /** The focus position. */
        this.targetY = 0;
        /** Current position. */
        this.x = 0;
        /** Current position. */
        this.y = 0;
        /** Current velocity. */
        this.vx = 0;
        /** Current velocity. */
        this.vy = 0;
    }
    /**
     * Sets the focus position.
     * @param x - X position in range `[-1, 1]`.
     * @param y - Y position in range `[-1, 1]`.
     * @param instant - Should the focus position be instantly applied.
     */
    focus(x, y, instant = false) {
        this.targetX = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* clamp */ "b"])(x, -1, 1);
        this.targetY = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* clamp */ "b"])(y, -1, 1);
        if (instant) {
            this.x = this.targetX;
            this.y = this.targetY;
        }
    }
    /**
     * Updates the interpolation.
     * @param dt - Delta time in milliseconds.
     */
    update(dt) {
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        if (Math.abs(dx) < EPSILON && Math.abs(dy) < EPSILON)
            return;
        const d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        const maxSpeed = MAX_SPEED / (1000 / dt);
        let ax = maxSpeed * (dx / d) - this.vx;
        let ay = maxSpeed * (dy / d) - this.vy;
        const a = Math.sqrt(Math.pow(ax, 2) + Math.pow(ay, 2));
        const maxA = maxSpeed * ACCELERATION_TIME * dt;
        if (a > maxA) {
            ax *= maxA / a;
            ay *= maxA / a;
        }
        this.vx += ax;
        this.vy += ay;
        const v = Math.sqrt(Math.pow(this.vx, 2) + Math.pow(this.vy, 2));
        const maxV = 0.5 * (Math.sqrt(Math.pow(maxA, 2) + 8 * maxA * d) - maxA);
        if (v > maxV) {
            this.vx *= maxV / v;
            this.vy *= maxV / v;
        }
        this.x += this.vx;
        this.y += this.vy;
    }
}


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return XHRLoader; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);

const TAG = 'XHRLoader';
class NetworkError extends Error {
    constructor(message, url, status, aborted = false) {
        super(message);
        this.url = url;
        this.status = status;
        this.aborted = aborted;
    }
}
/**
 * The basic XHR loader.
 *
 * A network error will be thrown with the following properties:
 * - `url` - The request URL.
 * - `status` - The HTTP status.
 * - `aborted` - True if the error is caused by aborting the XHR.
 */
class XHRLoader {
    /**
     * Creates a managed XHR.
     * @param target - If provided, the XHR will be canceled when receiving an "destroy" event from the target.
     * @param url - The URL.
     * @param type - The XHR response type.
     * @param onload - Load listener.
     * @param onerror - Error handler.
     */
    static createXHR(target, url, type, onload, onerror) {
        const xhr = new XMLHttpRequest();
        XHRLoader.allXhrSet.add(xhr);
        if (target) {
            let xhrSet = XHRLoader.xhrMap.get(target);
            if (!xhrSet) {
                xhrSet = new Set([xhr]);
                XHRLoader.xhrMap.set(target, xhrSet);
            }
            else {
                xhrSet.add(xhr);
            }
            if (!target.listeners('destroy').includes(XHRLoader.cancelXHRs)) {
                target.once('destroy', XHRLoader.cancelXHRs);
            }
        }
        xhr.open('GET', url);
        xhr.responseType = type;
        xhr.onload = () => {
            if ((xhr.status === 200 || xhr.status === 0) && xhr.response) {
                onload(xhr.response);
            }
            else {
                xhr.onerror();
            }
        };
        xhr.onerror = () => {
            _utils__WEBPACK_IMPORTED_MODULE_0__[/* logger */ "f"].warn(TAG, `Failed to load resource as ${xhr.responseType} (Status ${xhr.status}): ${url}`);
            onerror(new NetworkError('Network error.', url, xhr.status));
        };
        xhr.onabort = () => onerror(new NetworkError('Aborted.', url, xhr.status, true));
        xhr.onloadend = () => {
            var _a;
            XHRLoader.allXhrSet.delete(xhr);
            if (target) {
                (_a = XHRLoader.xhrMap.get(target)) === null || _a === void 0 ? void 0 : _a.delete(xhr);
            }
        };
        return xhr;
    }
    /**
     * Cancels all XHRs related to this target.
     */
    static cancelXHRs() {
        var _a;
        (_a = XHRLoader.xhrMap.get(this)) === null || _a === void 0 ? void 0 : _a.forEach(xhr => {
            xhr.abort();
            XHRLoader.allXhrSet.delete(xhr);
        });
        XHRLoader.xhrMap.delete(this);
    }
    /**
     * Release all XHRs.
     */
    static release() {
        XHRLoader.allXhrSet.forEach(xhr => xhr.abort());
        XHRLoader.allXhrSet.clear();
        XHRLoader.xhrMap = new WeakMap();
    }
}
/**
 * All the created XHRs, keyed by their owners respectively.
 */
XHRLoader.xhrMap = new WeakMap();
/**
 * All the created XHRs as a flat array.
 */
XHRLoader.allXhrSet = new Set();
/**
 * Middleware for Live2DLoader.
 */
XHRLoader.loader = (context, next) => {
    return new Promise((resolve, reject) => {
        const xhr = XHRLoader.createXHR(context.target, context.settings ? context.settings.resolveURL(context.url) : context.url, context.type, data => {
            context.result = data;
            resolve();
        }, reject);
        xhr.send();
    });
};


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return runMiddlewares; });
/**
 * Run middlewares with given context.
 * @see https://github.com/koajs/compose/blob/master/index.js
 *
 * @param middleware
 * @param context
 */
function runMiddlewares(middleware, context) {
    // last called middleware #
    let index = -1;
    return dispatch(0);
    function dispatch(i, err) {
        if (err)
            return Promise.reject(err);
        if (i <= index)
            return Promise.reject(new Error('next() called multiple times'));
        index = i;
        const fn = middleware[i];
        if (!fn)
            return Promise.resolve();
        try {
            return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
}


/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__17__;

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ cubism_common["e" /* LOGICAL_WIDTH */]; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ cubism_common["d" /* LOGICAL_HEIGHT */]; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ cubism_common["a" /* ExpressionManager */]; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ cubism_common["b" /* FocusController */]; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ cubism_common["f" /* ModelSettings */]; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* reexport */ cubism_common["i" /* MotionPriority */]; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* reexport */ cubism_common["j" /* MotionState */]; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ cubism_common["h" /* MotionPreloadStrategy */]; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ cubism_common["g" /* MotionManager */]; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* reexport */ cubism_common["k" /* SoundManager */]; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ cubism_common["c" /* InternalModel */]; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ Live2DModel_Live2DModel; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ Live2DTransform_Live2DTransform; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ InteractionMixin; });
__webpack_require__.d(__webpack_exports__, "w", function() { return /* reexport */ config["b" /* config */]; });
__webpack_require__.d(__webpack_exports__, "r", function() { return /* reexport */ config["a" /* VERSION */]; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ Live2DFactory["a" /* Live2DFactory */]; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ Live2DLoader["a" /* Live2DLoader */]; });
__webpack_require__.d(__webpack_exports__, "s", function() { return /* reexport */ XHRLoader["a" /* XHRLoader */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ FileLoader_FileLoader; });
__webpack_require__.d(__webpack_exports__, "t", function() { return /* reexport */ ZipLoader_ZipLoader; });
__webpack_require__.d(__webpack_exports__, "A", function() { return /* reexport */ utils["f" /* logger */]; });
__webpack_require__.d(__webpack_exports__, "v", function() { return /* reexport */ utils["b" /* clamp */]; });
__webpack_require__.d(__webpack_exports__, "B", function() { return /* reexport */ utils["g" /* rand */]; });
__webpack_require__.d(__webpack_exports__, "y", function() { return /* reexport */ utils["d" /* copyProperty */]; });
__webpack_require__.d(__webpack_exports__, "x", function() { return /* reexport */ utils["c" /* copyArray */]; });
__webpack_require__.d(__webpack_exports__, "u", function() { return /* reexport */ utils["a" /* applyMixins */]; });
__webpack_require__.d(__webpack_exports__, "z", function() { return /* reexport */ utils["e" /* folderName */]; });

// EXTERNAL MODULE: ./src/cubism-common/index.ts
var cubism_common = __webpack_require__(6);

// EXTERNAL MODULE: ./src/factory/Live2DFactory.ts + 2 modules
var Live2DFactory = __webpack_require__(4);

// EXTERNAL MODULE: external {"commonjs":"@pixi/display","commonjs2":"@pixi/display","amd":"@pixi/display","root":"PIXI"}
var display_root_PIXI_ = __webpack_require__(20);

// EXTERNAL MODULE: external {"commonjs":"@pixi/math","commonjs2":"@pixi/math","amd":"@pixi/math","root":"PIXI"}
var math_root_PIXI_ = __webpack_require__(5);

// CONCATENATED MODULE: ./src/InteractionMixin.ts
/**
 * The interaction control split from Live2DModel class for code clarity. This mixin should *only*
 * be used on the Live2DModel.
 */
class InteractionMixin {
    constructor() {
        this._autoInteract = false;
    }
    /**
     * Enables automatic interaction. Only takes effect if Pixi's interaction
     * feature has been enabled (by registering the `PIXI.InteractionManager` into `PIXI.Renderer`).
     */
    get autoInteract() {
        return this._autoInteract;
    }
    set autoInteract(autoInteract) {
        if (autoInteract !== this._autoInteract) {
            if (autoInteract) {
                this.on('pointertap', onTap, this);
            }
            else {
                this.off('pointertap', onTap, this);
            }
            this._autoInteract = autoInteract;
        }
    }
    /**
     * Registers interaction by subscribing to the `PIXI.InteractionManager`.
     */
    registerInteraction(manager) {
        if (manager !== this.interactionManager) {
            this.unregisterInteraction();
            if (this._autoInteract && manager) {
                this.interactionManager = manager;
                manager.on('pointermove', onPointerMove, this);
            }
        }
    }
    /**
     * Unregisters interaction.
     */
    unregisterInteraction() {
        var _a;
        if (this.interactionManager) {
            (_a = this.interactionManager) === null || _a === void 0 ? void 0 : _a.off('pointermove', onPointerMove, this);
            this.interactionManager = undefined;
        }
    }
}
function onTap(event) {
    this.tap(event.data.global.x, event.data.global.y);
}
function onPointerMove(event) {
    this.focus(event.data.global.x, event.data.global.y);
}

// CONCATENATED MODULE: ./src/Live2DTransform.ts

/**
 * Useless class. May be useful in the future.
 */
class Live2DTransform_Live2DTransform extends math_root_PIXI_["Transform"] {
}

// EXTERNAL MODULE: ./src/utils/index.ts + 4 modules
var utils = __webpack_require__(0);

// CONCATENATED MODULE: ./src/Live2DModel.ts
var _a;






const tempPoint = new math_root_PIXI_["Point"]();
const tempMatrix = new math_root_PIXI_["Matrix"]();
// a reference to Ticker class, defaults to window.PIXI.Ticker (when loaded by a <script> tag)
let TickerClass = (_a = window.PIXI) === null || _a === void 0 ? void 0 : _a.Ticker;
/**
 * A wrapper that allows the Live2D model to be used as a DisplayObject in PixiJS.
 *
 * ```js
 * const model = await Live2DModel.from('shizuku.model.json');
 * container.add(model);
 * ```
 * @emits {@link Live2DModelEvents}
 */
class Live2DModel_Live2DModel extends display_root_PIXI_["Container"] {
    constructor(options) {
        super();
        /**
         * Tag for logging.
         */
        this.tag = 'Live2DModel(uninitialized)';
        /**
         * Pixi textures.
         */
        this.textures = [];
        /** @override */
        this.transform = new Live2DTransform_Live2DTransform();
        /**
         * The anchor behaves like the one in `PIXI.Sprite`, where `(0, 0)` means the top left
         * and `(1, 1)` means the bottom right.
         */
        this.anchor = new math_root_PIXI_["ObservablePoint"](this.onAnchorChange, this, 0, 0);
        /**
         * An ID of Gl context that syncs with `renderer.CONTEXT_UID`. Used to check if the GL context has changed.
         */
        this.glContextID = -1;
        /**
         * Elapsed time in milliseconds since created.
         */
        this.elapsedTime = performance.now();
        /**
         * Elapsed time in milliseconds from last frame to this frame.
         */
        this.deltaTime = 0;
        this._autoUpdate = false;
        this.once('modelLoaded', () => this.init(options));
    }
    /**
     * Creates a Live2DModel from given source.
     * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
     * @param options - Options for the creation.
     * @return Promise that resolves with the Live2DModel.
     */
    static from(source, options) {
        const model = new this(options);
        return Live2DFactory["a" /* Live2DFactory */].setupLive2DModel(model, source, options).then(() => model);
    }
    /**
     * Synchronous version of `Live2DModel.from()`. This method immediately returns a Live2DModel instance,
     * whose resources have not been loaded. Therefore this model can't be manipulated or rendered
     * until the "load" event has been emitted.
     *
     * ```js
     * // no `await` here as it's not a Promise
     * const model = Live2DModel.fromSync('shizuku.model.json');
     *
     * // these will cause errors!
     * // app.stage.addChild(model);
     * // model.motion('tap_body');
     *
     * model.once('load', () => {
     *     // now it's safe
     *     app.stage.addChild(model);
     *     model.motion('tap_body');
     * });
     * ```
     */
    static fromSync(source, options) {
        const model = new this(options);
        Live2DFactory["a" /* Live2DFactory */].setupLive2DModel(model, source, options).then(options === null || options === void 0 ? void 0 : options.onLoad).catch(options === null || options === void 0 ? void 0 : options.onError);
        return model;
    }
    /**
     * Registers the class of `PIXI.Ticker` for auto updating.
     */
    static registerTicker(tickerClass) {
        TickerClass = tickerClass;
    }
    /**
     * Enables automatic updating. Requires {@link Live2DModel.registerTicker} or the global `window.PIXI.Ticker`.
     */
    get autoUpdate() {
        return this._autoUpdate;
    }
    set autoUpdate(autoUpdate) {
        if (autoUpdate) {
            if (!this._destroyed) {
                if (TickerClass) {
                    TickerClass.shared.add(this.onTickerUpdate, this);
                    this._autoUpdate = true;
                }
                else {
                    utils["f" /* logger */].warn(this.tag, 'No Ticker registered, please call Live2DModel.registerTicker(Ticker).');
                }
            }
        }
        else {
            TickerClass === null || TickerClass === void 0 ? void 0 : TickerClass.shared.remove(this.onTickerUpdate, this);
            this._autoUpdate = false;
        }
    }
    // TODO: rename
    /**
     * A handler of the "modelLoaded" event, invoked when the internal model has been loaded.
     */
    init(options) {
        this.tag = `Live2DModel(${this.internalModel.settings.name})`;
        const _options = Object.assign({
            autoUpdate: true,
            autoInteract: true,
        }, options);
        if (_options.autoInteract) {
            this.interactive = true;
        }
        this.autoInteract = _options.autoInteract;
        this.autoUpdate = _options.autoUpdate;
    }
    /**
     * A callback that observes {@link anchor}, invoked when the anchor's values have been changed.
     */
    onAnchorChange() {
        this.pivot.set(this.anchor.x * this.internalModel.width, this.anchor.y * this.internalModel.height);
    }
    /**
     * Shorthand to start a motion.
     * @param group - The motion group.
     * @param index - The index in this group. If not presented, a random motion will be started.
     * @param priority - The motion priority. Defaults to `MotionPriority.NORMAL`.
     * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
     */
    motion(group, index, priority) {
        return index === undefined
            ? this.internalModel.motionManager.startRandomMotion(group, priority)
            : this.internalModel.motionManager.startMotion(group, index, priority);
    }
    /**
     * Shorthand to set an expression.
     * @param id - Either the index, or the name of the expression. If not presented, a random expression will be set.
     * @return Promise that resolves with true if succeeded, with false otherwise.
     */
    expression(id) {
        if (this.internalModel.motionManager.expressionManager) {
            return id === undefined
                ? this.internalModel.motionManager.expressionManager.setRandomExpression()
                : this.internalModel.motionManager.expressionManager.setExpression(id);
        }
        return Promise.resolve(false);
    }
    /**
     * Updates the focus position. This will not cause the model to immediately look at the position,
     * instead the movement will be interpolated.
     * @param x - Position in world space.
     * @param y - Position in world space.
     * @param instant - Should the focus position be instantly applied.
     */
    focus(x, y, instant = false) {
        tempPoint.x = x;
        tempPoint.y = y;
        // we can pass `true` as the third argument to skip the update transform
        // because focus won't take effect until the model is rendered,
        // and a model being rendered will always get transform updated
        this.toModelPosition(tempPoint, tempPoint, true);
        this.internalModel.focusController.focus((tempPoint.x / this.internalModel.originalWidth) * 2 - 1, -((tempPoint.y / this.internalModel.originalHeight) * 2 - 1), instant);
    }
    /**
     * Tap on the model. This will perform a hit-testing, and emit a "hit" event
     * if at least one of the hit areas is hit.
     * @param x - Position in world space.
     * @param y - Position in world space.
     * @emits {@link Live2DModelEvents.hit}
     */
    tap(x, y) {
        const hitAreaNames = this.hitTest(x, y);
        if (hitAreaNames.length) {
            utils["f" /* logger */].log(this.tag, `Hit`, hitAreaNames);
            this.emit('hit', hitAreaNames);
        }
    }
    /**
     * Hit-test on the model.
     * @param x - Position in world space.
     * @param y - Position in world space.
     * @return The names of the *hit* hit areas. Can be empty if none is hit.
     */
    hitTest(x, y) {
        tempPoint.x = x;
        tempPoint.y = y;
        this.toModelPosition(tempPoint, tempPoint);
        return this.internalModel.hitTest(tempPoint.x, tempPoint.y);
    }
    /**
     * Calculates the position in the canvas of original, unscaled Live2D model.
     * @param position - A Point in world space.
     * @param result - A Point to store the new value. Defaults to a new Point.
     * @param skipUpdate - True to skip the update transform.
     * @return The Point in model canvas space.
     */
    toModelPosition(position, result = position.clone(), skipUpdate) {
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        this.transform.worldTransform.applyInverse(position, result);
        this.internalModel.localTransform.applyInverse(result, result);
        return result;
    }
    /**
     * A method required by `PIXI.InteractionManager` to perform hit-testing.
     * @param point - A Point in world space.
     * @return True if the point is inside this model.
     */
    containsPoint(point) {
        return this.getBounds(true).contains(point.x, point.y);
    }
    /** @override */
    _calculateBounds() {
        this._bounds.addFrame(this.transform, 0, 0, this.internalModel.width, this.internalModel.height);
    }
    /**
     * An update callback to be added to `PIXI.Ticker` and invoked every tick.
     */
    onTickerUpdate() {
        this.update(TickerClass.shared.deltaMS);
    }
    /**
     * Updates the model. Note this method just updates the timer,
     * and the actual update will be done right before rendering the model.
     * @param dt - The elapsed time in milliseconds since last frame.
     */
    update(dt) {
        this.deltaTime += dt;
        this.elapsedTime += dt;
        // don't call `this.internalModel.update()` here, because it requires WebGL context
    }
    /** @override */
    _render(renderer) {
        this.registerInteraction(renderer.plugins.interaction);
        // reset certain systems in renderer to make Live2D's drawing system compatible with Pixi
        renderer.batch.reset();
        renderer.geometry.reset();
        renderer.shader.reset();
        renderer.state.reset();
        let shouldUpdateTexture = false;
        // when the WebGL context has changed
        if (this.glContextID !== renderer.CONTEXT_UID) {
            this.glContextID = renderer.CONTEXT_UID;
            this.internalModel.updateWebGLContext(renderer.gl, this.glContextID);
            shouldUpdateTexture = true;
        }
        for (let i = 0; i < this.textures.length; i++) {
            const texture = this.textures[i];
            if (!texture.valid) {
                continue;
            }
            if (shouldUpdateTexture || !texture.baseTexture._glTextures[this.glContextID]) {
                renderer.gl.pixelStorei(WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, this.internalModel.textureFlipY);
                // let the TextureSystem generate corresponding WebGLTexture, and bind to an arbitrary location
                renderer.texture.bind(texture.baseTexture, 0);
            }
            // bind the WebGLTexture into Live2D core.
            // because the Texture in Pixi can be shared between multiple DisplayObjects,
            // it's unable to know if the WebGLTexture in this Texture has been destroyed (GCed) and regenerated,
            // and therefore we always bind the texture at this moment no matter what
            this.internalModel.bindTexture(i, texture.baseTexture._glTextures[this.glContextID].texture);
            // manually update the GC counter so they won't be GCed while using this model
            texture.baseTexture.touched = renderer.textureGC.count;
        }
        const viewport = renderer.framebuffer.viewport;
        this.internalModel.viewport = [viewport.x, viewport.y, viewport.width, viewport.height];
        // update only if the time has changed, as the model will possibly be updated once but rendered multiple times
        if (this.deltaTime) {
            this.internalModel.update(this.deltaTime, this.elapsedTime);
            this.deltaTime = 0;
        }
        const internalTransform = tempMatrix
            .copyFrom(renderer.globalUniforms.uniforms.projectionMatrix)
            .append(this.worldTransform);
        this.internalModel.updateTransform(internalTransform);
        this.internalModel.draw(renderer.gl);
        // reset WebGL state and texture bindings
        renderer.state.reset();
        renderer.texture.reset();
    }
    /**
     * Destroys the model and all related resources. This takes the same options and also
     * behaves the same as `PIXI.Container#destroy`.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        this.emit('destroy');
        // the setters will do the cleanup
        this.autoUpdate = false;
        this.unregisterInteraction();
        if (options === null || options === void 0 ? void 0 : options.texture) {
            this.textures.forEach(texture => texture.destroy(options.baseTexture));
        }
        this.internalModel.destroy();
        super.destroy(options);
    }
}
Object(utils["a" /* applyMixins */])(Live2DModel_Live2DModel, [InteractionMixin]);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(1);

// EXTERNAL MODULE: ./src/factory/Live2DLoader.ts
var Live2DLoader = __webpack_require__(3);

// EXTERNAL MODULE: ./src/factory/XHRLoader.ts
var XHRLoader = __webpack_require__(15);

// EXTERNAL MODULE: external {"commonjs":"@pixi/utils","commonjs2":"@pixi/utils","amd":"@pixi/utils","root":["PIXI","utils"]}
var utils_root_PIXI_utils_ = __webpack_require__(2);

// CONCATENATED MODULE: ./src/factory/FileLoader.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


/**
 * Experimental loader to load resources from uploaded files.
 *
 * This loader relies on
 * [webkitRelativePath](https://developer.mozilla.org/en-US/docs/Web/API/File/webkitRelativePath)
 * to recognize the file path.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
class FileLoader_FileLoader {
    /**
     * Resolves the path of a resource file to the object URL.
     * @param settingsURL - Object URL of the settings file.
     * @param filePath - Resource file path.
     * @return Resolved object URL.
     */
    static resolveURL(settingsURL, filePath) {
        var _a;
        const resolved = (_a = FileLoader_FileLoader.filesMap[settingsURL]) === null || _a === void 0 ? void 0 : _a[filePath];
        if (resolved === undefined) {
            throw new Error('Cannot find this file from uploaded files: ' + filePath);
        }
        return resolved;
    }
    /**
     * Consumes the files by storing their object URLs. Files not defined in the settings will be ignored.
     */
    static upload(files, settings) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileMap = {};
            // only consume the files defined in settings
            for (const definedFile of settings.getDefinedFiles()) {
                const actualPath = decodeURI(utils_root_PIXI_utils_["url"].resolve(settings.url, definedFile));
                const actualFile = files.find(file => file.webkitRelativePath === actualPath);
                if (actualFile) {
                    fileMap[definedFile] = URL.createObjectURL(actualFile);
                }
            }
            FileLoader_FileLoader.filesMap[settings._objectURL] = fileMap;
        });
    }
    /**
     * Creates a ModelSettings by given files.
     * @return Promise that resolves with the created ModelSettings.
     */
    static createSettings(files) {
        return __awaiter(this, void 0, void 0, function* () {
            const settingsFile = files.find(file => file.name.endsWith('model.json') || file.name.endsWith('model3.json'));
            if (!settingsFile) {
                throw new TypeError('Settings file not found');
            }
            const settingsText = yield FileLoader_FileLoader.readText(settingsFile);
            const settingsJSON = JSON.parse(settingsText);
            settingsJSON.url = settingsFile.webkitRelativePath;
            const runtime = Live2DFactory["a" /* Live2DFactory */].findRuntime(settingsJSON);
            if (!runtime) {
                throw new Error('Unknown settings JSON');
            }
            const settings = runtime.createModelSettings(settingsJSON);
            settings._objectURL = URL.createObjectURL(settingsFile);
            return settings;
        });
    }
    /**
     * Reads a file as text in UTF-8.
     */
    static readText(file) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsText(file, 'utf8');
            });
        });
    }
}
/**
 * Stores all the object URLs of uploaded files.
 */
FileLoader_FileLoader.filesMap = {};
/**
 * Middleware for Live2DFactory.
 */
FileLoader_FileLoader.factory = (context, next) => __awaiter(void 0, void 0, void 0, function* () {
    if (Array.isArray(context.source) && context.source[0] instanceof File) {
        const files = context.source;
        let settings = files.settings;
        if (!settings) {
            settings = yield FileLoader_FileLoader.createSettings(files);
        }
        else if (!settings._objectURL) {
            throw new Error('"_objectURL" must be specified in ModelSettings');
        }
        settings.validateFiles(files.map(file => encodeURI(file.webkitRelativePath)));
        yield FileLoader_FileLoader.upload(files, settings);
        // override the default method to resolve URL from uploaded files
        settings.resolveURL = function (url) {
            return FileLoader_FileLoader.resolveURL(this._objectURL, url);
        };
        context.source = settings;
        // clean up when destroying the model
        context.live2dModel.once('modelLoaded', (internalModel) => {
            internalModel.once('destroy', function () {
                const objectURL = this.settings._objectURL;
                URL.revokeObjectURL(objectURL);
                if (FileLoader_FileLoader.filesMap[objectURL]) {
                    for (const resourceObjectURL of Object.values(FileLoader_FileLoader.filesMap[objectURL])) {
                        URL.revokeObjectURL(resourceObjectURL);
                    }
                }
                delete FileLoader_FileLoader.filesMap[objectURL];
            });
        });
    }
    return next();
});
Live2DFactory["a" /* Live2DFactory */].live2DModelMiddlewares.unshift(FileLoader_FileLoader.factory);

// CONCATENATED MODULE: ./src/factory/ZipLoader.ts
var ZipLoader_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



/**
 * Experimental loader to load resources from a zip file.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
class ZipLoader_ZipLoader {
    static unzip(reader, settings) {
        return ZipLoader_awaiter(this, void 0, void 0, function* () {
            const filePaths = yield ZipLoader_ZipLoader.getFilePaths(reader);
            const requiredFilePaths = [];
            // only consume the files defined in settings
            for (const definedFile of settings.getDefinedFiles()) {
                const actualPath = decodeURI(utils_root_PIXI_utils_["url"].resolve(settings.url, definedFile));
                if (filePaths.includes(actualPath)) {
                    requiredFilePaths.push(actualPath);
                }
            }
            const files = yield ZipLoader_ZipLoader.getFiles(reader, requiredFilePaths);
            for (let i = 0; i < files.length; i++) {
                const path = requiredFilePaths[i];
                const file = files[i];
                // let's borrow this property...
                Object.defineProperty(file, 'webkitRelativePath', {
                    value: path,
                });
            }
            return files;
        });
    }
    static createSettings(reader) {
        return ZipLoader_awaiter(this, void 0, void 0, function* () {
            const filePaths = yield ZipLoader_ZipLoader.getFilePaths(reader);
            const settingsFilePath = filePaths.find(path => path.endsWith('model.json') || path.endsWith('model3.json'));
            if (!settingsFilePath) {
                throw new Error('Settings file not found');
            }
            const settingsText = yield ZipLoader_ZipLoader.readText(reader, settingsFilePath);
            if (!settingsText) {
                throw new Error('Empty settings file: ' + settingsFilePath);
            }
            const settingsJSON = JSON.parse(settingsText);
            settingsJSON.url = settingsFilePath;
            const runtime = Live2DFactory["a" /* Live2DFactory */].findRuntime(settingsJSON);
            if (!runtime) {
                throw new Error('Unknown settings JSON');
            }
            return runtime.createModelSettings(settingsJSON);
        });
    }
    static zipReader(data, url) {
        return ZipLoader_awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    static getFilePaths(reader) {
        return ZipLoader_awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    static getFiles(reader, paths) {
        return ZipLoader_awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    static readText(reader, path) {
        return ZipLoader_awaiter(this, void 0, void 0, function* () {
            throw new Error('Not implemented');
        });
    }
    static releaseReader(reader) {
        // this method is optional
    }
}
ZipLoader_ZipLoader.ZIP_PROTOCOL = 'zip://';
ZipLoader_ZipLoader.uid = 0;
ZipLoader_ZipLoader.factory = (context, next) => ZipLoader_awaiter(void 0, void 0, void 0, function* () {
    const source = context.source;
    let sourceURL;
    let zipBlob;
    let settings;
    if (typeof source === 'string' && (source.endsWith('.zip') || source.startsWith(ZipLoader_ZipLoader.ZIP_PROTOCOL))) {
        if (source.startsWith(ZipLoader_ZipLoader.ZIP_PROTOCOL)) {
            sourceURL = source.slice(ZipLoader_ZipLoader.ZIP_PROTOCOL.length);
        }
        else {
            sourceURL = source;
        }
        zipBlob = yield Live2DLoader["a" /* Live2DLoader */].load({
            url: sourceURL,
            type: 'blob',
            target: context.live2dModel,
        });
    }
    else if (Array.isArray(source)
        && source.length === 1
        && source[0] instanceof File
        && source[0].name.endsWith('.zip')) {
        zipBlob = source[0];
        sourceURL = URL.createObjectURL(zipBlob);
        settings = source.settings;
    }
    if (zipBlob) {
        if (!zipBlob.size) {
            throw new Error('Empty zip file');
        }
        const reader = yield ZipLoader_ZipLoader.zipReader(zipBlob, sourceURL);
        if (!settings) {
            settings = yield ZipLoader_ZipLoader.createSettings(reader);
        }
        // a fake URL, the only requirement is it should be unique,
        // as FileLoader will use it as the ID of all uploaded files
        settings._objectURL = ZipLoader_ZipLoader.ZIP_PROTOCOL + ZipLoader_ZipLoader.uid + '/' + settings.url;
        const files = yield ZipLoader_ZipLoader.unzip(reader, settings);
        files.settings = settings;
        // pass files to the FileLoader
        context.source = files;
        // clean up when destroying the model
        if (sourceURL.startsWith('blob:')) {
            context.live2dModel.once('modelLoaded', (internalModel) => {
                internalModel.once('destroy', function () {
                    URL.revokeObjectURL(sourceURL);
                });
            });
        }
        ZipLoader_ZipLoader.releaseReader(reader);
    }
    return next();
});
Live2DFactory["a" /* Live2DFactory */].live2DModelMiddlewares.unshift(ZipLoader_ZipLoader.factory);

// CONCATENATED MODULE: ./src/factory/index.ts






// CONCATENATED MODULE: ./src/common.ts
/// <reference path="../core/live2d.d.ts"/>
/// <reference path="../core/live2dcubismcore.d.ts"/>
/// <reference path="../cubism/src/CubismSpec.d.ts"/>
/// <reference path="types/Cubism2Spec.d.ts"/>
/// <reference path="types/helpers.d.ts"/>
/// <reference path="types/shim.d.ts"/>









/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__19__;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__20__;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const originalUpdateParam = Live2DMotion.prototype.updateParam;
Live2DMotion.prototype.updateParam = function (model, entry) {
    originalUpdateParam.call(this, model, entry);
    if (entry.isFinished() && this.onFinishHandler) {
        this.onFinishHandler(this);
        delete this.onFinishHandler;
    }
};


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ Cubism4ExpressionManager_Cubism4ExpressionManager; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ Cubism4ModelSettings_Cubism4ModelSettings; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ Cubism4MotionManager_Cubism4MotionManager; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ Cubism4InternalModel_Cubism4InternalModel; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ cubism4Ready; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ startUpCubism4; });

// EXTERNAL MODULE: ./src/cubism4/check-runtime.ts
var check_runtime = __webpack_require__(26);

// EXTERNAL MODULE: ./src/cubism-common/ExpressionManager.ts
var ExpressionManager = __webpack_require__(10);

// CONCATENATED MODULE: ./cubism/src/math/cubismvector2.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * 2
 *
 * 2
 */
class CubismVector2 {
    /**
     * 
     */
    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    add(vector2) {
        const ret = new CubismVector2(0.0, 0.0);
        ret.x = this.x + vector2.x;
        ret.y = this.y + vector2.y;
        return ret;
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    substract(vector2) {
        const ret = new CubismVector2(0.0, 0.0);
        ret.x = this.x - vector2.x;
        ret.y = this.y - vector2.y;
        return ret;
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    multiply(vector2) {
        const ret = new CubismVector2(0.0, 0.0);
        ret.x = this.x * vector2.x;
        ret.y = this.y * vector2.y;
        return ret;
    }
    /**
     * ()
     *
     * @param scalar 
     * @return  
     */
    multiplyByScaler(scalar) {
        return this.multiply(new CubismVector2(scalar, scalar));
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    division(vector2) {
        const ret = new CubismVector2(0.0, 0.0);
        ret.x = this.x / vector2.x;
        ret.y = this.y / vector2.y;
        return ret;
    }
    /**
     * ()
     *
     * @param scalar 
     * @return  
     */
    divisionByScalar(scalar) {
        return this.division(new CubismVector2(scalar, scalar));
    }
    /**
     * 
     *
     * @return 
     */
    getLength() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * 
     *
     * @param a 
     * @return 
     */
    getDistanceWith(a) {
        return Math.sqrt((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));
    }
    /**
     * 
     *
     * @param a 
     * @return 
     */
    dot(a) {
        return this.x * a.x + this.y * a.y;
    }
    /**
     * 
     */
    normalize() {
        const length = Math.pow(this.x * this.x + this.y * this.y, 0.5);
        this.x = this.x / length;
        this.y = this.y / length;
    }
    /**
     * 
     *
     * 
     *
     * @param rhs 
     * @return true 
     * @return false 
     */
    isEqual(rhs) {
        return this.x == rhs.x && this.y == rhs.y;
    }
    /**
     * 
     *
     * 
     *
     * @param rhs 
     * @return true 
     * @return false 
     */
    isNotEqual(rhs) {
        return !this.isEqual(rhs);
    }
}

// CONCATENATED MODULE: ./cubism/src/math/cubismmath.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

/**
 * 
 */
class cubismmath_CubismMath {
    /**
     * 
     *
     * @param value 
     * @param min   
     * @param max   
     * @return 
     */
    static range(value, min, max) {
        if (value < min) {
            value = min;
        }
        else if (value > max) {
            value = max;
        }
        return value;
    }
    /**
     * 
     *
     * @param x 
     * @return sin(x)
     */
    static sin(x) {
        return Math.sin(x);
    }
    /**
     * 
     *
     * @param x ()
     * @return cos(x)
     */
    static cos(x) {
        return Math.cos(x);
    }
    /**
     * 
     *
     * @param x 
     * @return 
     */
    static abs(x) {
        return Math.abs(x);
    }
    /**
     * ()
     * @param x -> 
     * @return 
     */
    static sqrt(x) {
        return Math.sqrt(x);
    }
    /**
     * 
     * 
     *
     * @param value 
     * @return 
     */
    static getEasingSine(value) {
        if (value < 0.0) {
            return 0.0;
        }
        else if (value > 1.0) {
            return 1.0;
        }
        return 0.5 - 0.5 * this.cos(value * Math.PI);
    }
    /**
     * 
     *
     * @param left 
     * @param right 
     * @return 
     */
    static max(left, right) {
        return left > right ? left : right;
    }
    /**
     * 
     *
     * @param left  
     * @param right 
     * @return 
     */
    static min(left, right) {
        return left > right ? right : left;
    }
    /**
     * 
     *
     * @param degrees   
     * @return 
     */
    static degreesToRadian(degrees) {
        return (degrees / 180.0) * Math.PI;
    }
    /**
     * 
     *
     * @param radian    
     * @return 
     */
    static radianToDegrees(radian) {
        return (radian * 180.0) / Math.PI;
    }
    /**
     * 
     *
     * @param from  
     * @param to    
     * @return 
     */
    static directionToRadian(from, to) {
        const q1 = Math.atan2(to.y, to.x);
        const q2 = Math.atan2(from.y, from.x);
        let ret = q1 - q2;
        while (ret < -Math.PI) {
            ret += Math.PI * 2.0;
        }
        while (ret > Math.PI) {
            ret -= Math.PI * 2.0;
        }
        return ret;
    }
    /**
     * 
     *
     * @param from  
     * @param to    
     * @return 
     */
    static directionToDegrees(from, to) {
        const radian = this.directionToRadian(from, to);
        let degree = this.radianToDegrees(radian);
        if (to.x - from.x > 0.0) {
            degree = -degree;
        }
        return degree;
    }
    /**
     * 
     *
     * @param totalAngle    
     * @return 
     */
    static radianToDirection(totalAngle) {
        const ret = new CubismVector2();
        ret.x = this.sin(totalAngle);
        ret.y = this.cos(totalAngle);
        return ret;
    }
    /**
     * 
     */
    constructor() { }
}

// CONCATENATED MODULE: ./cubism/src/math/cubismmatrix44.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * 4x4
 *
 * 4x4
 */
class CubismMatrix44 {
    /**
     * 
     */
    constructor() {
        this._tr = new Float32Array(16); // 4 * 4
        this.loadIdentity();
    }
    /**
     * 
     *
     * @param a a
     * @param b b
     * @return 
     */
    static multiply(a, b, dst) {
        const c = new Float32Array([
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
        ]);
        const n = 4;
        for (let i = 0; i < n; ++i) {
            for (let j = 0; j < n; ++j) {
                for (let k = 0; k < n; ++k) {
                    c[j + i * 4] += a[k + i * 4] * b[j + k * 4];
                }
            }
        }
        for (let i = 0; i < 16; ++i) {
            dst[i] = c[i];
        }
    }
    /**
     * 
     */
    loadIdentity() {
        const c = new Float32Array([
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
        ]);
        this.setMatrix(c);
    }
    /**
     * 
     *
     * @param tr 164x4
     */
    setMatrix(tr) {
        for (let i = 0; i < 16; ++i) {
            this._tr[i] = tr[i];
        }
    }
    /**
     * 
     *
     * @return 164x4
     */
    getArray() {
        return this._tr;
    }
    /**
     * X
     * @return X
     */
    getScaleX() {
        return this._tr[0];
    }
    /**
     * Y
     *
     * @return Y
     */
    getScaleY() {
        return this._tr[5];
    }
    /**
     * X
     * @return X
     */
    getTranslateX() {
        return this._tr[12];
    }
    /**
     * Y
     * @return Y
     */
    getTranslateY() {
        return this._tr[13];
    }
    /**
     * X
     *
     * @param src X
     * @return X
     */
    transformX(src) {
        return this._tr[0] * src + this._tr[12];
    }
    /**
     * Y
     *
     * @param src Y
     * @return Y
     */
    transformY(src) {
        return this._tr[5] * src + this._tr[13];
    }
    /**
     * X
     */
    invertTransformX(src) {
        return (src - this._tr[12]) / this._tr[0];
    }
    /**
     * Y
     */
    invertTransformY(src) {
        return (src - this._tr[13]) / this._tr[5];
    }
    /**
     * 
     *
     * 
     *
     * @param x X
     * @param y Y
     */
    translateRelative(x, y) {
        const tr1 = new Float32Array([
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            x,
            y,
            0.0,
            1.0,
        ]);
        CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 
     *
     * 
     *
     * @param x X
     * @param y y
     */
    translate(x, y) {
        this._tr[12] = x;
        this._tr[13] = y;
    }
    /**
     * X
     *
     * @param x X
     */
    translateX(x) {
        this._tr[12] = x;
    }
    /**
     * Y
     *
     * @param y Y
     */
    translateY(y) {
        this._tr[13] = y;
    }
    /**
     * 
     *
     * @param x X
     * @param y Y
     */
    scaleRelative(x, y) {
        const tr1 = new Float32Array([
            x,
            0.0,
            0.0,
            0.0,
            0.0,
            y,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
        ]);
        CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 
     *
     * @param x X
     * @param y Y
     */
    scale(x, y) {
        this._tr[0] = x;
        this._tr[5] = y;
    }
    /**
     * 
     *
     * @param m 
     */
    multiplyByMatrix(m) {
        CubismMatrix44.multiply(m.getArray(), this._tr, this._tr);
    }
    /**
     * 
     */
    clone() {
        const cloneMatrix = new CubismMatrix44();
        for (let i = 0; i < this._tr.length; i++) {
            cloneMatrix._tr[i] = this._tr[i];
        }
        return cloneMatrix;
    }
}

// CONCATENATED MODULE: ./cubism/src/rendering/cubismrenderer.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

/**
 * 
 *
 * 
 */
class cubismrenderer_CubismRenderer {
    /**
     * 
     */
    constructor() {
        this._isCulling = false;
        this._isPremultipliedAlpha = false;
        this._anisortopy = 0.0;
        this._modelColor = new CubismTextureColor();
        // 
        this._mvpMatrix4x4 = new CubismMatrix44();
        this._mvpMatrix4x4.loadIdentity();
    }
    /**
     * 
     * 
     * @param model 
     */
    initialize(model) {
        this._model = model;
    }
    /**
     * 
     */
    drawModel() {
        if (this.getModel() == null)
            return;
        this.doDrawModel();
    }
    /**
     * Model-View-Projection 
     * 
     * @param matrix44 Model-View-Projection 
     */
    setMvpMatrix(matrix44) {
        this._mvpMatrix4x4.setMatrix(matrix44.getArray());
    }
    /**
     * Model-View-Projection 
     * @return Model-View-Projection 
     */
    getMvpMatrix() {
        return this._mvpMatrix4x4;
    }
    /**
     * 
     * 0.0~1.01.0
     * @param red 
     * @param green 
     * @param blue 
     * @param alpha 
     */
    setModelColor(red, green, blue, alpha) {
        if (red < 0.0) {
            red = 0.0;
        }
        else if (red > 1.0) {
            red = 1.0;
        }
        if (green < 0.0) {
            green = 0.0;
        }
        else if (green > 1.0) {
            green = 1.0;
        }
        if (blue < 0.0) {
            blue = 0.0;
        }
        else if (blue > 1.0) {
            blue = 1.0;
        }
        if (alpha < 0.0) {
            alpha = 0.0;
        }
        else if (alpha > 1.0) {
            alpha = 1.0;
        }
        this._modelColor.R = red;
        this._modelColor.G = green;
        this._modelColor.B = blue;
        this._modelColor.A = alpha;
    }
    /**
     * 
     * 0.0~1.0(1.0)
     *
     * @return RGBA
     */
    getModelColor() {
        return Object.assign({}, this._modelColor);
    }
    /**
     * 
     * truefalse
     */
    setIsPremultipliedAlpha(enable) {
        this._isPremultipliedAlpha = enable;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isPremultipliedAlpha() {
        return this._isPremultipliedAlpha;
    }
    /**
     * 
     * truefalse
     */
    setIsCulling(culling) {
        this._isCulling = culling;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isCulling() {
        return this._isCulling;
    }
    /**
     * 
     * 
     * @param n 
     */
    setAnisotropy(n) {
        this._anisortopy = n;
    }
    /**
     * 
     * @return 
     */
    getAnisotropy() {
        return this._anisortopy;
    }
    /**
     * 
     * @return 
     */
    getModel() {
        return this._model;
    }
}
var CubismBlendMode;
(function (CubismBlendMode) {
    CubismBlendMode[CubismBlendMode["CubismBlendMode_Normal"] = 0] = "CubismBlendMode_Normal";
    CubismBlendMode[CubismBlendMode["CubismBlendMode_Additive"] = 1] = "CubismBlendMode_Additive";
    CubismBlendMode[CubismBlendMode["CubismBlendMode_Multiplicative"] = 2] = "CubismBlendMode_Multiplicative"; // 
})(CubismBlendMode || (CubismBlendMode = {}));
/**
 * RGBA
 */
class CubismTextureColor {
    /**
     * 
     */
    constructor() {
        this.R = 1.0;
        this.G = 1.0;
        this.B = 1.0;
        this.A = 1.0;
    }
}

// CONCATENATED MODULE: ./cubism/src/live2dcubismframework.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */


// 
let s_isStarted = false;
let s_isInitialized = false;
let s_option = undefined;
/**
 * Framework
 */
var Constant;
(function (Constant) {
    Constant.vertexOffset = 0; // 
    Constant.vertexStep = 2; // 
})(Constant || (Constant = {}));
/**
 * Live2D Cubism SDK Original Workflow SDK
 * CubismFramework.initialize()CubismFramework.dispose()
 */
class live2dcubismframework_CubismFramework {
    /**
     * Cubism FrameworkAPI
     *  API
     *  
     *
     * @param    option      Option
     *
     * @return   true
     */
    static startUp(option) {
        if (s_isStarted) {
            CubismLogInfo('CubismFramework.startUp() is already done.');
            return s_isStarted;
        }
        if (Live2DCubismCore._isStarted) {
            s_isStarted = true;
            return true;
        }
        Live2DCubismCore._isStarted = true;
        s_option = option;
        if (s_option) {
            Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);
        }
        s_isStarted = true;
        // Live2D Cubism Core
        if (s_isStarted) {
            const version = Live2DCubismCore.Version.csmGetVersion();
            const major = (version & 0xff000000) >> 24;
            const minor = (version & 0x00ff0000) >> 16;
            const patch = version & 0x0000ffff;
            const versionNumber = version;
            CubismLogInfo(`Live2D Cubism Core version: {0}.{1}.{2} ({3})`, ('00' + major).slice(-2), ('00' + minor).slice(-2), ('0000' + patch).slice(-4), versionNumber);
        }
        CubismLogInfo('CubismFramework.startUp() is complete.');
        return s_isStarted;
    }
    /**
     * StartUp()CubismFramework
     * Dispose()CubismFramework
     */
    static cleanUp() {
        s_isStarted = false;
        s_isInitialized = false;
        s_option = undefined;
    }
    /**
     * Cubism Framework<br>
     *     Initialize()Dispose()
     */
    static initialize() {
        if (!s_isStarted) {
            CubismLogWarning('CubismFramework is not started.');
            return;
        }
        // --- s_isInitialized ---
        // 
        // Initialize()Dispose()
        if (s_isInitialized) {
            CubismLogWarning('CubismFramework.initialize() skipped, already initialized.');
            return;
        }
        s_isInitialized = true;
        CubismLogInfo('CubismFramework.initialize() is complete.');
    }
    /**
     * Cubism Framework
     *      
     *      
     */
    static dispose() {
        if (!s_isStarted) {
            CubismLogWarning('CubismFramework is not started.');
            return;
        }
        // --- s_isInitialized ---
        // dispose()initialize()
        if (!s_isInitialized) {
            // false...
            CubismLogWarning('CubismFramework.dispose() skipped, not initialized.');
            return;
        }
        // 
        cubismrenderer_CubismRenderer.staticRelease();
        s_isInitialized = false;
        CubismLogInfo('CubismFramework.dispose() is complete.');
    }
    /**
     * Cubism FrameworkAPI
     * @return APItrue
     */
    static isStarted() {
        return s_isStarted;
    }
    /**
     * Cubism Framework
     * @return true
     */
    static isInitialized() {
        return s_isInitialized;
    }
    /**
     * Core API
     *
     * @praram message 
     */
    static coreLogFunction(message) {
        // Return if logging not possible.
        if (!Live2DCubismCore.Logging.csmGetLogFunction()) {
            return;
        }
        Live2DCubismCore.Logging.csmGetLogFunction()(message);
    }
    /**
     * 
     *
     * @return  
     */
    static getLoggingLevel() {
        if (s_option != null) {
            return s_option.loggingLevel;
        }
        return LogLevel.LogLevel_Off;
    }
    /**
     * 
     * 
     */
    constructor() { }
}
/**
 * 
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["LogLevel_Verbose"] = 0] = "LogLevel_Verbose";
    LogLevel[LogLevel["LogLevel_Debug"] = 1] = "LogLevel_Debug";
    LogLevel[LogLevel["LogLevel_Info"] = 2] = "LogLevel_Info";
    LogLevel[LogLevel["LogLevel_Warning"] = 3] = "LogLevel_Warning";
    LogLevel[LogLevel["LogLevel_Error"] = 4] = "LogLevel_Error";
    LogLevel[LogLevel["LogLevel_Off"] = 5] = "LogLevel_Off"; // 
})(LogLevel || (LogLevel = {}));

// CONCATENATED MODULE: ./cubism/src/utils/cubismdebug.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

const CSM_ASSERT =  true ? () => { } : undefined;
function CubismLogVerbose(fmt, ...args) {
    cubismdebug_CubismDebug.print(LogLevel.LogLevel_Verbose, '[CSM][V]' + fmt + '\n', args);
}
function CubismLogDebug(fmt, ...args) {
    cubismdebug_CubismDebug.print(LogLevel.LogLevel_Debug, '[CSM][D]' + fmt + '\n', args);
}
function CubismLogInfo(fmt, ...args) {
    cubismdebug_CubismDebug.print(LogLevel.LogLevel_Info, '[CSM][I]' + fmt + '\n', args);
}
function CubismLogWarning(fmt, ...args) {
    cubismdebug_CubismDebug.print(LogLevel.LogLevel_Warning, '[CSM][W]' + fmt + '\n', args);
}
function CubismLogError(fmt, ...args) {
    cubismdebug_CubismDebug.print(LogLevel.LogLevel_Error, '[CSM][E]' + fmt + '\n', args);
}
/**
 * 
 * 
 */
class cubismdebug_CubismDebug {
    /**
     * 
     * CubismFramework.initialize()
     *
     * @param logLevel 
     * @param format 
     * @param args 
     */
    static print(logLevel, format, args) {
        // 
        if (logLevel < live2dcubismframework_CubismFramework.getLoggingLevel()) {
            return;
        }
        const logPrint = live2dcubismframework_CubismFramework.coreLogFunction;
        if (!logPrint)
            return;
        const buffer = format.replace(/{(\d+)}/g, (m, k) => {
            return args[k];
        });
        logPrint(buffer);
    }
    /**
     * 
     * CubismFramework.initialize()
     *
     * @param logLevel 
     * @param data 
     * @param length 
     */
    static dumpBytes(logLevel, data, length) {
        for (let i = 0; i < length; i++) {
            if (i % 16 == 0 && i > 0)
                this.print(logLevel, '\n');
            else if (i % 8 == 0 && i > 0)
                this.print(logLevel, '  ');
            this.print(logLevel, '{0} ', [data[i] & 0xff]);
        }
        this.print(logLevel, '\n');
    }
    /**
     * private 
     */
    constructor() { }
}

// CONCATENATED MODULE: ./cubism/src/motion/acubismmotion.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */


/**
 * 
 *
 * MotionQueueManager
 */
class acubismmotion_ACubismMotion {
    /**
     * 
     */
    constructor() {
        this._fadeInSeconds = -1.0;
        this._fadeOutSeconds = -1.0;
        this._weight = 1.0;
        this._offsetSeconds = 0.0; // 
        this._firedEventValues = [];
    }
    /**
     * 
     */
    release() {
        this._weight = 0.0;
    }
    /**
     * 
     * @param model 
     * @param motionQueueEntry CubismMotionQueueManager
     * @param userTimeSeconds []
     */
    updateParameters(model, motionQueueEntry, userTimeSeconds) {
        if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {
            return;
        }
        if (!motionQueueEntry.isStarted()) {
            motionQueueEntry.setIsStarted(true);
            motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds); // 
            motionQueueEntry.setFadeInStartTime(userTimeSeconds); // 
            const duration = this.getDuration();
            if (motionQueueEntry.getEndTime() < 0) {
                // 
                motionQueueEntry.setEndTime(duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration);
                // duration == -1 
            }
        }
        let fadeWeight = this._weight; // 
        //----  ----
        // 
        const fadeIn = this._fadeInSeconds == 0.0
            ? 1.0
            : cubismmath_CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /
                this._fadeInSeconds);
        const fadeOut = this._fadeOutSeconds == 0.0 || motionQueueEntry.getEndTime() < 0.0
            ? 1.0
            : cubismmath_CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /
                this._fadeOutSeconds);
        fadeWeight = fadeWeight * fadeIn * fadeOut;
        motionQueueEntry.setState(userTimeSeconds, fadeWeight);
        CSM_ASSERT(0.0 <= fadeWeight && fadeWeight <= 1.0);
        //---- ID ----
        this.doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry);
        // 
        // (CubismMotionQueueManager)
        if (motionQueueEntry.getEndTime() > 0 &&
            motionQueueEntry.getEndTime() < userTimeSeconds) {
            motionQueueEntry.setIsFinished(true); // 
        }
    }
    /**
     * 
     * @param fadeInSeconds []
     */
    setFadeInTime(fadeInSeconds) {
        this._fadeInSeconds = fadeInSeconds;
    }
    /**
     * 
     * @param fadeOutSeconds []
     */
    setFadeOutTime(fadeOutSeconds) {
        this._fadeOutSeconds = fadeOutSeconds;
    }
    /**
     * 
     * @return []
     */
    getFadeOutTime() {
        return this._fadeOutSeconds;
    }
    /**
     * 
     * @return []
     */
    getFadeInTime() {
        return this._fadeInSeconds;
    }
    /**
     * 
     * @param weight 0.0 - 1.0
     */
    setWeight(weight) {
        this._weight = weight;
    }
    /**
     * 
     * @return 0.0 - 1.0
     */
    getWeight() {
        return this._weight;
    }
    /**
     * 
     * @return []
     *
     * @note -1
     *       
     *       
     *       -1
     */
    getDuration() {
        return -1.0;
    }
    /**
     * 1
     * @return []
     *
     * @note getDuration()
     *       ()-1
     */
    getLoopDuration() {
        return -1.0;
    }
    /**
     * 
     * @param offsetSeconds []
     */
    setOffsetTime(offsetSeconds) {
        this._offsetSeconds = offsetSeconds;
    }
    /**
     * 
     *
     * 
     * 
     *
     * @param beforeCheckTimeSeconds []
     * @param motionTimeSeconds []
     */
    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
        return this._firedEventValues;
    }
    /**
     * 
     *
     * 
     * isFinished
     * :
     *   1. 
     *   2. 
     *
     * @param onFinishedMotionHandler 
     */
    setFinishedMotionHandler(onFinishedMotionHandler) {
        this._onFinishedMotion = onFinishedMotionHandler;
    }
    ;
    /**
     * 
     *
     * 
     *
     * @return 
     */
    getFinishedMotionHandler() {
        return this._onFinishedMotion;
    }
    ;
}

// CONCATENATED MODULE: ./cubism/src/motion/cubismexpressionmotion.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

// exp3.json
const DefaultFadeTime = 1.0;
/**
 * 
 *
 * 
 */
class cubismexpressionmotion_CubismExpressionMotion extends acubismmotion_ACubismMotion {
    /**
     * 
     */
    constructor() {
        super();
        this._parameters = [];
    }
    /**
     * 
     * @param json exp
     * @param size 
     * @return 
     */
    static create(json) {
        const expression = new cubismexpressionmotion_CubismExpressionMotion();
        const fadeInTime = json.FadeInTime;
        const fadeOutTime = json.FadeOutTime;
        expression.setFadeInTime(fadeInTime !== undefined ? fadeInTime : DefaultFadeTime); // 
        expression.setFadeOutTime(fadeOutTime !== undefined ? fadeOutTime : DefaultFadeTime); // 
        // 
        const parameters = json.Parameters || [];
        for (let i = 0; i < parameters.length; ++i) {
            const param = parameters[i];
            const parameterId = param.Id; // ID
            const value = param.Value; // 
            // 
            let blendType;
            switch (param.Blend) {
                case 'Multiply':
                    blendType = ExpressionBlendType.ExpressionBlendType_Multiply;
                    break;
                case 'Overwrite':
                    blendType = ExpressionBlendType.ExpressionBlendType_Overwrite;
                    break;
                case 'Add':
                //  
                default:
                    blendType = ExpressionBlendType.ExpressionBlendType_Add;
                    break;
            }
            // 
            const item = {
                parameterId: parameterId,
                blendType: blendType,
                value: value,
            };
            expression._parameters.push(item);
        }
        return expression;
    }
    /**
     * 
     * @param model 
     * @param userTimeSeconds []
     * @param weight 
     * @param motionQueueEntry CubismMotionQueueManager
     */
    doUpdateParameters(model, userTimeSeconds, weight, motionQueueEntry) {
        for (let i = 0; i < this._parameters.length; ++i) {
            const parameter = this._parameters[i];
            switch (parameter.blendType) {
                case ExpressionBlendType.ExpressionBlendType_Add: {
                    model.addParameterValueById(parameter.parameterId, parameter.value, weight);
                    break;
                }
                case ExpressionBlendType.ExpressionBlendType_Multiply: {
                    model.multiplyParameterValueById(parameter.parameterId, parameter.value, weight);
                    break;
                }
                case ExpressionBlendType.ExpressionBlendType_Overwrite: {
                    model.setParameterValueById(parameter.parameterId, parameter.value, weight);
                    break;
                }
                default:
                    // 
                    break;
            }
        }
    }
}
/**
 * 
 */
var ExpressionBlendType;
(function (ExpressionBlendType) {
    ExpressionBlendType[ExpressionBlendType["ExpressionBlendType_Add"] = 0] = "ExpressionBlendType_Add";
    ExpressionBlendType[ExpressionBlendType["ExpressionBlendType_Multiply"] = 1] = "ExpressionBlendType_Multiply";
    ExpressionBlendType[ExpressionBlendType["ExpressionBlendType_Overwrite"] = 2] = "ExpressionBlendType_Overwrite"; // 
})(ExpressionBlendType || (ExpressionBlendType = {}));

// CONCATENATED MODULE: ./cubism/src/motion/cubismmotionqueueentry.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * CubismMotionQueueManager
 */
class CubismMotionQueueEntry {
    /**
     * 
     */
    constructor() {
        this._autoDelete = false;
        this._available = true;
        this._finished = false;
        this._started = false;
        this._startTimeSeconds = -1.0;
        this._fadeInStartTimeSeconds = 0.0;
        this._endTimeSeconds = -1.0;
        this._stateTimeSeconds = 0.0;
        this._stateWeight = 0.0;
        this._lastEventCheckSeconds = 0.0;
        this._motionQueueEntryHandle = this;
        this._fadeOutSeconds = 0.0;
        this._isTriggeredFadeOut = false;
    }
    /**
     * 
     */
    release() {
        if (this._autoDelete && this._motion) {
            this._motion.release();
        }
    }
    /**
     * 
     * @param fadeOutSeconds []
     */
    setFadeOut(fadeOutSeconds) {
        this._fadeOutSeconds = fadeOutSeconds;
        this._isTriggeredFadeOut = true;
    }
    /**
     * 
     * @param fadeOutSeconds []
     * @param userTimeSeconds []
     */
    startFadeOut(fadeOutSeconds, userTimeSeconds) {
        const newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;
        this._isTriggeredFadeOut = true;
        if (this._endTimeSeconds < 0.0 ||
            newEndTimeSeconds < this._endTimeSeconds) {
            this._endTimeSeconds = newEndTimeSeconds;
        }
    }
    /**
     * 
     *
     * @return true 
     * @return false 
     */
    isFinished() {
        return this._finished;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isStarted() {
        return this._started;
    }
    /**
     * 
     * @return []
     */
    getStartTime() {
        return this._startTimeSeconds;
    }
    /**
     * 
     * @return []
     */
    getFadeInStartTime() {
        return this._fadeInStartTimeSeconds;
    }
    /**
     * 
     * @return 
     */
    getEndTime() {
        return this._endTimeSeconds;
    }
    /**
     * 
     * @param startTime 
     */
    setStartTime(startTime) {
        this._startTimeSeconds = startTime;
    }
    /**
     * 
     * @param startTime []
     */
    setFadeInStartTime(startTime) {
        this._fadeInStartTimeSeconds = startTime;
    }
    /**
     * 
     * @param endTime []
     */
    setEndTime(endTime) {
        this._endTimeSeconds = endTime;
    }
    /**
     * 
     * @param f true
     */
    setIsFinished(f) {
        this._finished = f;
    }
    /**
     * 
     * @param f true
     */
    setIsStarted(f) {
        this._started = f;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isAvailable() {
        return this._available;
    }
    /**
     * 
     * @param v true
     */
    setIsAvailable(v) {
        this._available = v;
    }
    /**
     * 
     * @param timeSeconds []
     * @param weight 
     */
    setState(timeSeconds, weight) {
        this._stateTimeSeconds = timeSeconds;
        this._stateWeight = weight;
    }
    /**
     * 
     * @return []
     */
    getStateTime() {
        return this._stateTimeSeconds;
    }
    /**
     * 
     * @return 
     */
    getStateWeight() {
        return this._stateWeight;
    }
    /**
     * 
     *
     * @return []
     */
    getLastCheckEventSeconds() {
        return this._lastEventCheckSeconds;
    }
    /**
     * 
     * @param checkSeconds []
     */
    setLastCheckEventSeconds(checkSeconds) {
        this._lastEventCheckSeconds = checkSeconds;
    }
    /**
     * 
     * @return 
     */
    isTriggeredFadeOut() {
        return this._isTriggeredFadeOut && this._endTimeSeconds < 0.0;
    }
    /**
     * 
     * @return []
     */
    getFadeOutSeconds() {
        return this._fadeOutSeconds;
    }
}

// CONCATENATED MODULE: ./cubism/src/motion/cubismmotionqueuemanager.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

/**
 * 
 *
 * CubismMotionACubismMotion
 *
 * @note  StartMotion()
 *       
 *       CubismMotionQueueManager
 */
class cubismmotionqueuemanager_CubismMotionQueueManager {
    /**
     * 
     */
    constructor() {
        this._userTimeSeconds = 0.0;
        this._eventCustomData = null;
        this._motions = [];
    }
    /**
     * 
     */
    release() {
        for (let i = 0; i < this._motions.length; ++i) {
            if (this._motions[i]) {
                this._motions[i].release();
            }
        }
        this._motions = undefined;
    }
    /**
     * 
     *
     * 
     *
     * @param   motion          
     * @param   autoDelete       true
     * @param   userTimeSeconds []
     * @return                      IsFinished()-1
     */
    startMotion(motion, autoDelete, userTimeSeconds) {
        if (motion == null) {
            return InvalidMotionQueueEntryHandleValue;
        }
        let motionQueueEntry;
        // 
        for (let i = 0; i < this._motions.length; ++i) {
            motionQueueEntry = this._motions[i];
            if (motionQueueEntry == null) {
                continue;
            }
            motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime()); // 
        }
        motionQueueEntry = new CubismMotionQueueEntry(); // 
        motionQueueEntry._autoDelete = autoDelete;
        motionQueueEntry._motion = motion;
        this._motions.push(motionQueueEntry);
        return motionQueueEntry._motionQueueEntryHandle;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isFinished() {
        // -------  -------
        // 
        let i = 0;
        while (i < this._motions.length) {
            const motionQueueEntry = this._motions[i];
            if (motionQueueEntry == null) {
                this._motions.splice(i, 1); // 
                continue;
            }
            const motion = motionQueueEntry._motion;
            if (motion == null) {
                motionQueueEntry.release();
                this._motions.splice(i, 1); // 
                continue;
            }
            // -----  ------
            if (!motionQueueEntry.isFinished()) {
                return false;
            }
            i++;
        }
        return true;
    }
    /**
     * 
     * @param motionQueueEntryNumber 
     * @return true 
     * @return false 
     */
    isFinishedByHandle(motionQueueEntryNumber) {
        // 
        for (let i = 0; i < this._motions.length; i++) {
            const motionQueueEntry = this._motions[i];
            if (motionQueueEntry == null) {
                continue;
            }
            if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber &&
                !motionQueueEntry.isFinished()) {
                return false;
            }
        }
        return true;
    }
    /**
     * 
     */
    stopAllMotions() {
        // -------  -------
        // 
        for (let i = 0; i < this._motions.length; i++) {
            const motionQueueEntry = this._motions[i];
            if (motionQueueEntry != null) {
                // -----  ------
                motionQueueEntry.release();
            }
        }
        this._motions = [];
    }
    /**
     * CubismMotionQueueEntry
  
     * @param   motionQueueEntryNumber  
     * @return  CubismMotionQueueEntry
     * @return  null   
     */
    getCubismMotionQueueEntry(motionQueueEntryNumber) {
        //-------  -------
        // 
        return this._motions.find(entry => entry != null && entry._motionQueueEntryHandle == motionQueueEntryNumber);
    }
    /**
     * Callback
     *
     * @param callback 
     * @param customData 
     */
    setEventCallback(callback, customData = null) {
        this._eventCallBack = callback;
        this._eventCustomData = customData;
    }
    /**
     * 
     *
     * @param   model   
     * @param   userTimeSeconds   []
     * @return  true    
     * @return  false   ()
     */
    doUpdateMotion(model, userTimeSeconds) {
        let updated = false;
        // -------  --------
        // 
        let i = 0;
        while (i < this._motions.length) {
            const motionQueueEntry = this._motions[i];
            if (motionQueueEntry == null) {
                this._motions.splice(i, 1); // 
                continue;
            }
            const motion = motionQueueEntry._motion;
            if (motion == null) {
                motionQueueEntry.release();
                this._motions.splice(i, 1); // 
                continue;
            }
            // ------  ------
            motion.updateParameters(model, motionQueueEntry, userTimeSeconds);
            updated = true;
            // ------  ----
            const firedList = motion.getFiredEvent(motionQueueEntry.getLastCheckEventSeconds() -
                motionQueueEntry.getStartTime(), userTimeSeconds - motionQueueEntry.getStartTime());
            for (let i = 0; i < firedList.length; ++i) {
                this._eventCallBack(this, firedList[i], this._eventCustomData);
            }
            motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);
            // ------  ------
            if (motionQueueEntry.isFinished()) {
                motionQueueEntry.release();
                this._motions.splice(i, 1); // 
            }
            else {
                if (motionQueueEntry.isTriggeredFadeOut()) {
                    motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), userTimeSeconds);
                }
                i++;
            }
        }
        return updated;
    }
}
const InvalidMotionQueueEntryHandleValue = -1;

// CONCATENATED MODULE: ./src/cubism4/Cubism4ExpressionManager.ts



class Cubism4ExpressionManager_Cubism4ExpressionManager extends ExpressionManager["a" /* ExpressionManager */] {
    constructor(settings, options) {
        var _a;
        super(settings, options);
        this.queueManager = new cubismmotionqueuemanager_CubismMotionQueueManager();
        this.definitions = (_a = settings.expressions) !== null && _a !== void 0 ? _a : [];
        this.init();
    }
    isFinished() {
        return this.queueManager.isFinished();
    }
    getExpressionIndex(name) {
        return this.definitions.findIndex(def => def.Name === name);
    }
    getExpressionFile(definition) {
        return definition.File;
    }
    createExpression(data, definition) {
        return cubismexpressionmotion_CubismExpressionMotion.create(data);
    }
    _setExpression(motion) {
        return this.queueManager.startMotion(motion, false, performance.now());
    }
    stopAllExpressions() {
        this.queueManager.stopAllMotions();
    }
    updateParameters(model, now) {
        return this.queueManager.doUpdateMotion(model, now);
    }
}

// EXTERNAL MODULE: ./src/cubism-common/ModelSettings.ts
var ModelSettings = __webpack_require__(11);

// EXTERNAL MODULE: ./src/utils/index.ts + 4 modules
var utils = __webpack_require__(0);

// CONCATENATED MODULE: ./cubism/src/settings/cubismmodelsettingsjson.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * Model3Json
 *
 * model3.json
 */
class CubismModelSettingsJson {
    constructor(json) {
        this.groups = json.Groups;
        this.hitAreas = json.HitAreas;
        this.layout = json.Layout;
        this.moc = json.FileReferences.Moc;
        this.expressions = json.FileReferences.Expressions;
        this.motions = json.FileReferences.Motions;
        this.textures = json.FileReferences.Textures;
        this.physics = json.FileReferences.Physics;
        this.pose = json.FileReferences.Pose;
    }
    getEyeBlinkParameters() {
        var _a, _b;
        return (_b = (_a = this.groups) === null || _a === void 0 ? void 0 : _a.find(group => group.Name === 'EyeBlink')) === null || _b === void 0 ? void 0 : _b.Ids;
    }
    getLipSyncParameters() {
        var _a, _b;
        return (_b = (_a = this.groups) === null || _a === void 0 ? void 0 : _a.find(group => group.Name === 'LipSync')) === null || _b === void 0 ? void 0 : _b.Ids;
    }
}

// CONCATENATED MODULE: ./src/cubism4/Cubism4ModelSettings.ts



class Cubism4ModelSettings_Cubism4ModelSettings extends ModelSettings["a" /* ModelSettings */] {
    constructor(json) {
        super(json);
        if (!Cubism4ModelSettings_Cubism4ModelSettings.isValidJSON(json)) {
            throw new TypeError('Invalid JSON.');
        }
        // this doesn't seem to be allowed in ES6 and above, calling it will cause an error:
        // "Class constructor CubismModelSettingsJson cannot be invoked without 'new'"
        //
        // CubismModelSettingsJson.call(this, json);
        Object.assign(this, new CubismModelSettingsJson(json));
    }
    static isValidJSON(json) {
        var _a;
        return !!(json === null || json === void 0 ? void 0 : json.FileReferences)
            && typeof json.FileReferences.Moc === 'string'
            && ((_a = json.FileReferences.Textures) === null || _a === void 0 ? void 0 : _a.length) > 0
            // textures must be an array of strings
            && json.FileReferences.Textures.every((item) => typeof item === 'string');
    }
    replaceFiles(replace) {
        super.replaceFiles(replace);
        if (this.motions) {
            for (const [group, motions] of Object.entries(this.motions)) {
                for (let i = 0; i < motions.length; i++) {
                    motions[i].File = replace(motions[i].File, `motions.${group}[${i}].File`);
                    if (motions[i].Sound !== undefined) {
                        motions[i].Sound = replace(motions[i].Sound, `motions.${group}[${i}].Sound`);
                    }
                }
            }
        }
        if (this.expressions) {
            for (let i = 0; i < this.expressions.length; i++) {
                this.expressions[i].File = replace(this.expressions[i].File, `expressions[${i}].File`);
            }
        }
    }
}
Object(utils["a" /* applyMixins */])(Cubism4ModelSettings_Cubism4ModelSettings, [CubismModelSettingsJson]);

// EXTERNAL MODULE: ./src/cubism-common/MotionManager.ts
var MotionManager = __webpack_require__(12);

// CONCATENATED MODULE: ./cubism/src/motion/cubismmotioninternal.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * @brief 
 *
 * 
 */
var CubismMotionCurveTarget;
(function (CubismMotionCurveTarget) {
    CubismMotionCurveTarget[CubismMotionCurveTarget["CubismMotionCurveTarget_Model"] = 0] = "CubismMotionCurveTarget_Model";
    CubismMotionCurveTarget[CubismMotionCurveTarget["CubismMotionCurveTarget_Parameter"] = 1] = "CubismMotionCurveTarget_Parameter";
    CubismMotionCurveTarget[CubismMotionCurveTarget["CubismMotionCurveTarget_PartOpacity"] = 2] = "CubismMotionCurveTarget_PartOpacity"; // 
})(CubismMotionCurveTarget || (CubismMotionCurveTarget = {}));
/**
 * @brief 
 *
 * 
 */
var CubismMotionSegmentType;
(function (CubismMotionSegmentType) {
    CubismMotionSegmentType[CubismMotionSegmentType["CubismMotionSegmentType_Linear"] = 0] = "CubismMotionSegmentType_Linear";
    CubismMotionSegmentType[CubismMotionSegmentType["CubismMotionSegmentType_Bezier"] = 1] = "CubismMotionSegmentType_Bezier";
    CubismMotionSegmentType[CubismMotionSegmentType["CubismMotionSegmentType_Stepped"] = 2] = "CubismMotionSegmentType_Stepped";
    CubismMotionSegmentType[CubismMotionSegmentType["CubismMotionSegmentType_InverseStepped"] = 3] = "CubismMotionSegmentType_InverseStepped"; // 
})(CubismMotionSegmentType || (CubismMotionSegmentType = {}));
/**
 * @brief 
 *
 * 
 */
class CubismMotionPoint {
    constructor(time = 0.0, value = 0.0) {
        this.time = time;
        this.value = value;
    }
}
/**
 * @brief 
 *
 * 
 */
class CubismMotionSegment {
    /**
     * @brief 
     *
     * 
     */
    constructor() {
        this.basePointIndex = 0;
        this.segmentType = 0;
    }
}
/**
 * @brief 
 *
 * 
 */
class CubismMotionCurve {
    constructor() {
        this.id = ''; // ID
        this.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
        this.segmentCount = 0;
        this.baseSegmentIndex = 0;
        this.fadeInTime = 0.0;
        this.fadeOutTime = 0.0;
    }
}
/**
 * 
 */
class CubismMotionEvent {
    constructor() {
        this.fireTime = 0.0;
        this.value = '';
    }
}
/**
 * @brief 
 *
 * 
 */
class CubismMotionData {
    constructor() {
        this.duration = 0.0;
        this.loop = false;
        this.curveCount = 0;
        this.eventCount = 0;
        this.fps = 0.0;
        this.curves = [];
        this.segments = [];
        this.points = [];
        this.events = [];
    }
}

// CONCATENATED MODULE: ./cubism/src/motion/cubismmotionjson.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * motion3.json
 */
class CubismMotionJson {
    /**
     * 
     * @param json motion3.json
     */
    constructor(json) {
        this._json = json;
    }
    /**
     * 
     */
    release() {
        this._json = undefined;
    }
    /**
     * 
     * @return []
     */
    getMotionDuration() {
        return this._json.Meta.Duration;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isMotionLoop() {
        return this._json.Meta.Loop || false;
    }
    /**
     * 
     * @return 
     */
    getMotionCurveCount() {
        return this._json.Meta.CurveCount;
    }
    /**
     * 
     * @return [FPS]
     */
    getMotionFps() {
        return this._json.Meta.Fps;
    }
    /**
     * 
     * @return 
     */
    getMotionTotalSegmentCount() {
        return this._json.Meta.TotalSegmentCount;
    }
    /**
     * 
     * @return 
     */
    getMotionTotalPointCount() {
        return this._json.Meta.TotalPointCount;
    }
    /**
     * 
     * @return []
     */
    getMotionFadeInTime() {
        return this._json.Meta.FadeInTime;
    }
    /**
     * 
     * @return []
     */
    getMotionFadeOutTime() {
        return this._json.Meta.FadeOutTime;
    }
    /**
     * 
     * @param curveIndex 
     * @return 
     */
    getMotionCurveTarget(curveIndex) {
        return this._json.Curves[curveIndex].Target;
    }
    /**
     * ID
     * @param curveIndex 
     * @return ID
     */
    getMotionCurveId(curveIndex) {
        return this._json.Curves[curveIndex].Id;
    }
    /**
     * 
     * @param curveIndex 
     * @return []
     */
    getMotionCurveFadeInTime(curveIndex) {
        return this._json.Curves[curveIndex].FadeInTime;
    }
    /**
     * 
     * @param curveIndex 
     * @return []
     */
    getMotionCurveFadeOutTime(curveIndex) {
        return this._json.Curves[curveIndex].FadeOutTime;
    }
    /**
     * 
     * @param curveIndex 
     * @return 
     */
    getMotionCurveSegmentCount(curveIndex) {
        return this._json.Curves[curveIndex].Segments.length;
    }
    /**
     * 
     * @param curveIndex 
     * @param segmentIndex 
     * @return 
     */
    getMotionCurveSegment(curveIndex, segmentIndex) {
        return this._json.Curves[curveIndex].Segments[segmentIndex];
    }
    /**
     * 
     * @return 
     */
    getEventCount() {
        return this._json.Meta.UserDataCount || 0;
    }
    /**
     *  
     * @return 
     */
    getTotalEventValueSize() {
        return this._json.Meta.TotalUserDataSize;
    }
    /**
     * 
     * @param userDataIndex 
     * @return []
     */
    getEventTime(userDataIndex) {
        return this._json.UserData[userDataIndex].Time;
    }
    /**
     * 
     * @param userDataIndex 
     * @return 
     */
    getEventValue(userDataIndex) {
        return this._json.UserData[userDataIndex].Value;
    }
}

// CONCATENATED MODULE: ./cubism/src/motion/cubismmotion.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */





const EffectNameEyeBlink = 'EyeBlink';
const EffectNameLipSync = 'LipSync';
const TargetNameModel = 'Model';
const TargetNameParameter = 'Parameter';
const TargetNamePartOpacity = 'PartOpacity';
function lerpPoints(a, b, t) {
    const result = new CubismMotionPoint();
    result.time = a.time + (b.time - a.time) * t;
    result.value = a.value + (b.value - a.value) * t;
    return result;
}
function linearEvaluate(points, time) {
    let t = (time - points[0].time) / (points[1].time - points[0].time);
    if (t < 0.0) {
        t = 0.0;
    }
    return points[0].value + (points[1].value - points[0].value) * t;
}
function bezierEvaluate(points, time) {
    let t = (time - points[0].time) / (points[3].time - points[0].time);
    if (t < 0.0) {
        t = 0.0;
    }
    const p01 = lerpPoints(points[0], points[1], t);
    const p12 = lerpPoints(points[1], points[2], t);
    const p23 = lerpPoints(points[2], points[3], t);
    const p012 = lerpPoints(p01, p12, t);
    const p123 = lerpPoints(p12, p23, t);
    return lerpPoints(p012, p123, t).value;
}
function steppedEvaluate(points, time) {
    return points[0].value;
}
function inverseSteppedEvaluate(points, time) {
    return points[1].value;
}
function evaluateCurve(motionData, index, time) {
    // Find segment to evaluate.
    const curve = motionData.curves[index];
    let target = -1;
    const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;
    let pointPosition = 0;
    for (let i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {
        // Get first point of next segment.
        pointPosition =
            motionData.segments[i].basePointIndex +
                (motionData.segments[i].segmentType ==
                    CubismMotionSegmentType.CubismMotionSegmentType_Bezier
                    ? 3
                    : 1);
        // Break if time lies within current segment.
        if (motionData.points[pointPosition].time > time) {
            target = i;
            break;
        }
    }
    if (target == -1) {
        return motionData.points[pointPosition].value;
    }
    const segment = motionData.segments[target];
    return segment.evaluate(motionData.points.slice(segment.basePointIndex), time);
}
/**
 * 
 *
 * 
 */
class cubismmotion_CubismMotion extends acubismmotion_ACubismMotion {
    /**
     * 
     */
    constructor() {
        super();
        this._eyeBlinkParameterIds = []; // ID  
        this._lipSyncParameterIds = []; // ID  
        this._sourceFrameRate = 30.0;
        this._loopDurationSeconds = -1.0;
        this._isLoop = false; // true false 
        this._isLoopFadeIn = true; // 
        this._lastWeight = 0.0;
    }
    /**
     * 
     *
     * @param json motion3.json
     * @param onFinishedMotionHandler 
     * @return 
     */
    static create(json, onFinishedMotionHandler) {
        const ret = new cubismmotion_CubismMotion();
        ret.parse(json);
        ret._sourceFrameRate = ret._motionData.fps;
        ret._loopDurationSeconds = ret._motionData.duration;
        ret._onFinishedMotion = onFinishedMotionHandler;
        // NOTE: Editor
        // ret->_loop = (ret->_motionData->Loop > 0);
        return ret;
    }
    /**
     * 
     * @param model             
     * @param userTimeSeconds   []
     * @param fadeWeight        
     * @param motionQueueEntry  CubismMotionQueueManager
     */
    doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {
        if (this._modelCurveIdEyeBlink == null) {
            this._modelCurveIdEyeBlink = EffectNameEyeBlink;
        }
        if (this._modelCurveIdLipSync == null) {
            this._modelCurveIdLipSync = EffectNameLipSync;
        }
        let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();
        if (timeOffsetSeconds < 0.0) {
            timeOffsetSeconds = 0.0; // 
        }
        let lipSyncValue = Number.MAX_VALUE;
        let eyeBlinkValue = Number.MAX_VALUE;
        //maxFlagCount
        const MaxTargetSize = 64;
        let lipSyncFlags = 0;
        let eyeBlinkFlags = 0;
        //
        if (this._eyeBlinkParameterIds.length > MaxTargetSize) {
            CubismLogDebug('too many eye blink targets : {0}', this._eyeBlinkParameterIds.length);
        }
        if (this._lipSyncParameterIds.length > MaxTargetSize) {
            CubismLogDebug('too many lip sync targets : {0}', this._lipSyncParameterIds.length);
        }
        const tmpFadeIn = this._fadeInSeconds <= 0.0
            ? 1.0
            : cubismmath_CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /
                this._fadeInSeconds);
        const tmpFadeOut = this._fadeOutSeconds <= 0.0 || motionQueueEntry.getEndTime() < 0.0
            ? 1.0
            : cubismmath_CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /
                this._fadeOutSeconds);
        let value;
        let c, parameterIndex;
        // 'Repeat' time as necessary.
        let time = timeOffsetSeconds;
        if (this._isLoop) {
            while (time > this._motionData.duration) {
                time -= this._motionData.duration;
            }
        }
        const curves = this._motionData.curves;
        // Evaluate model curves.
        for (c = 0; c < this._motionData.curveCount &&
            curves[c].type ==
                CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c) {
            // Evaluate curve and call handler.
            value = evaluateCurve(this._motionData, c, time);
            if (curves[c].id == this._modelCurveIdEyeBlink) {
                eyeBlinkValue = value;
            }
            else if (curves[c].id == this._modelCurveIdLipSync) {
                lipSyncValue = value;
            }
        }
        let parameterMotionCurveCount = 0;
        for (; c < this._motionData.curveCount &&
            curves[c].type ==
                CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c) {
            parameterMotionCurveCount++;
            // Find parameter index.
            parameterIndex = model.getParameterIndex(curves[c].id);
            // Skip curve evaluation if no value in sink.
            if (parameterIndex == -1) {
                continue;
            }
            const sourceValue = model.getParameterValueByIndex(parameterIndex);
            // Evaluate curve and apply value.
            value = evaluateCurve(this._motionData, c, time);
            if (eyeBlinkValue != Number.MAX_VALUE) {
                for (let i = 0; i < this._eyeBlinkParameterIds.length && i < MaxTargetSize; ++i) {
                    if (this._eyeBlinkParameterIds[i] == curves[c].id) {
                        value *= eyeBlinkValue;
                        eyeBlinkFlags |= 1 << i;
                        break;
                    }
                }
            }
            if (lipSyncValue != Number.MAX_VALUE) {
                for (let i = 0; i < this._lipSyncParameterIds.length && i < MaxTargetSize; ++i) {
                    if (this._lipSyncParameterIds[i] == curves[c].id) {
                        value += lipSyncValue;
                        lipSyncFlags |= 1 << i;
                        break;
                    }
                }
            }
            let v;
            // 
            if (curves[c].fadeInTime < 0.0 && curves[c].fadeOutTime < 0.0) {
                // 
                v = sourceValue + (value - sourceValue) * fadeWeight;
            }
            else {
                // 
                let fin;
                let fout;
                if (curves[c].fadeInTime < 0.0) {
                    fin = tmpFadeIn;
                }
                else {
                    fin =
                        curves[c].fadeInTime == 0.0
                            ? 1.0
                            : cubismmath_CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /
                                curves[c].fadeInTime);
                }
                if (curves[c].fadeOutTime < 0.0) {
                    fout = tmpFadeOut;
                }
                else {
                    fout =
                        curves[c].fadeOutTime == 0.0 ||
                            motionQueueEntry.getEndTime() < 0.0
                            ? 1.0
                            : cubismmath_CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /
                                curves[c].fadeOutTime);
                }
                const paramWeight = this._weight * fin * fout;
                // 
                v = sourceValue + (value - sourceValue) * paramWeight;
            }
            model.setParameterValueByIndex(parameterIndex, v, 1.0);
        }
        {
            if (eyeBlinkValue != Number.MAX_VALUE) {
                for (let i = 0; i < this._eyeBlinkParameterIds.length && i < MaxTargetSize; ++i) {
                    const sourceValue = model.getParameterValueById(this._eyeBlinkParameterIds[i]);
                    // 
                    if ((eyeBlinkFlags >> i) & 0x01) {
                        continue;
                    }
                    const v = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;
                    model.setParameterValueById(this._eyeBlinkParameterIds[i], v);
                }
            }
            if (lipSyncValue != Number.MAX_VALUE) {
                for (let i = 0; i < this._lipSyncParameterIds.length && i < MaxTargetSize; ++i) {
                    const sourceValue = model.getParameterValueById(this._lipSyncParameterIds[i]);
                    // 
                    if ((lipSyncFlags >> i) & 0x01) {
                        continue;
                    }
                    const v = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;
                    model.setParameterValueById(this._lipSyncParameterIds[i], v);
                }
            }
        }
        for (; c < this._motionData.curveCount &&
            curves[c].type ==
                CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c) {
            // Find parameter index.
            parameterIndex = model.getParameterIndex(curves[c].id);
            // Skip curve evaluation if no value in sink.
            if (parameterIndex == -1) {
                continue;
            }
            // Evaluate curve and apply value.
            value = evaluateCurve(this._motionData, c, time);
            model.setParameterValueByIndex(parameterIndex, value);
        }
        if (timeOffsetSeconds >= this._motionData.duration) {
            if (this._isLoop) {
                motionQueueEntry.setStartTime(userTimeSeconds); // 
                if (this._isLoopFadeIn) {
                    // 
                    motionQueueEntry.setFadeInStartTime(userTimeSeconds);
                }
            }
            else {
                if (this._onFinishedMotion) {
                    this._onFinishedMotion(this);
                }
                motionQueueEntry.setIsFinished(true);
            }
        }
        this._lastWeight = fadeWeight;
    }
    /**
     * 
     * @param loop 
     */
    setIsLoop(loop) {
        this._isLoop = loop;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isLoop() {
        return this._isLoop;
    }
    /**
     * 
     * @param loopFadeIn  
     */
    setIsLoopFadeIn(loopFadeIn) {
        this._isLoopFadeIn = loopFadeIn;
    }
    /**
     * 
     *
     * @return  true    
     * @return  false   
     */
    isLoopFadeIn() {
        return this._isLoopFadeIn;
    }
    /**
     * 
     *
     * @return  []
     */
    getDuration() {
        return this._isLoop ? -1.0 : this._loopDurationSeconds;
    }
    /**
     * 
     *
     * @return  []
     */
    getLoopDuration() {
        return this._loopDurationSeconds;
    }
    /**
     * 
     *
     * @param parameterId     ID
     * @param value           []
     */
    setParameterFadeInTime(parameterId, value) {
        const curves = this._motionData.curves;
        for (let i = 0; i < this._motionData.curveCount; ++i) {
            if (parameterId == curves[i].id) {
                curves[i].fadeInTime = value;
                return;
            }
        }
    }
    /**
     * 
     * @param parameterId     ID
     * @param value           []
     */
    setParameterFadeOutTime(parameterId, value) {
        const curves = this._motionData.curves;
        for (let i = 0; i < this._motionData.curveCount; ++i) {
            if (parameterId == curves[i].id) {
                curves[i].fadeOutTime = value;
                return;
            }
        }
    }
    /**
     * 
     * @param    parameterId     ID
     * @return   []
     */
    getParameterFadeInTime(parameterId) {
        const curves = this._motionData.curves;
        for (let i = 0; i < this._motionData.curveCount; ++i) {
            if (parameterId == curves[i].id) {
                return curves[i].fadeInTime;
            }
        }
        return -1;
    }
    /**
     * 
     *
     * @param   parameterId     ID
     * @return   []
     */
    getParameterFadeOutTime(parameterId) {
        const curves = this._motionData.curves;
        for (let i = 0; i < this._motionData.curveCount; ++i) {
            if (parameterId == curves[i].id) {
                return curves[i].fadeOutTime;
            }
        }
        return -1;
    }
    /**
     * ID
     * @param eyeBlinkParameterIds    ID
     * @param lipSyncParameterIds     ID
     */
    setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {
        this._eyeBlinkParameterIds = eyeBlinkParameterIds;
        this._lipSyncParameterIds = lipSyncParameterIds;
    }
    /**
     * 
     */
    release() {
        this._motionData = undefined;
    }
    /**
     * motion3.json
     *
     * @param motionJson  motion3.json
     */
    parse(motionJson) {
        this._motionData = new CubismMotionData();
        let json = new CubismMotionJson(motionJson);
        this._motionData.duration = json.getMotionDuration();
        this._motionData.loop = json.isMotionLoop();
        this._motionData.curveCount = json.getMotionCurveCount();
        this._motionData.fps = json.getMotionFps();
        this._motionData.eventCount = json.getEventCount();
        const fadeInSeconds = json.getMotionFadeInTime();
        const fadeOutSeconds = json.getMotionFadeOutTime();
        if (fadeInSeconds !== undefined) {
            this._fadeInSeconds = fadeInSeconds < 0.0 ? 1.0 : fadeInSeconds;
        }
        else {
            this._fadeInSeconds = 1.0;
        }
        if (fadeOutSeconds !== undefined) {
            this._fadeOutSeconds = fadeOutSeconds < 0.0 ? 1.0 : fadeOutSeconds;
        }
        else {
            this._fadeOutSeconds = 1.0;
        }
        this._motionData.curves = Array.from({ length: this._motionData.curveCount }).map(() => new CubismMotionCurve());
        this._motionData.segments = Array.from({ length: json.getMotionTotalSegmentCount() }).map(() => new CubismMotionSegment());
        this._motionData.events = Array.from({ length: this._motionData.eventCount }).map(() => new CubismMotionEvent());
        this._motionData.points = [];
        let totalPointCount = 0;
        let totalSegmentCount = 0;
        // Curves
        for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {
            const curve = this._motionData.curves[curveCount];
            switch (json.getMotionCurveTarget(curveCount)) {
                case TargetNameModel:
                    curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
                    break;
                case TargetNameParameter:
                    curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;
                    break;
                case TargetNamePartOpacity:
                    curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;
                    break;
            }
            curve.id = json.getMotionCurveId(curveCount);
            curve.baseSegmentIndex = totalSegmentCount;
            const fadeInTime = json.getMotionCurveFadeInTime(curveCount);
            const fadeOutTime = json.getMotionCurveFadeOutTime(curveCount);
            curve.fadeInTime = fadeInTime !== undefined ? fadeInTime : -1.0;
            curve.fadeOutTime = fadeOutTime !== undefined ? fadeOutTime : -1.0;
            // Segments
            for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount);) {
                if (segmentPosition == 0) {
                    this._motionData.segments[totalSegmentCount].basePointIndex = totalPointCount;
                    this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition), json.getMotionCurveSegment(curveCount, segmentPosition + 1));
                    totalPointCount += 1;
                    segmentPosition += 2;
                }
                else {
                    this._motionData.segments[totalSegmentCount].basePointIndex =
                        totalPointCount - 1;
                }
                const segment = json.getMotionCurveSegment(curveCount, segmentPosition);
                switch (segment) {
                    case CubismMotionSegmentType.CubismMotionSegmentType_Linear: {
                        this._motionData.segments[totalSegmentCount].segmentType =
                            CubismMotionSegmentType.CubismMotionSegmentType_Linear;
                        this._motionData.segments[totalSegmentCount].evaluate = linearEvaluate;
                        this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));
                        totalPointCount += 1;
                        segmentPosition += 3;
                        break;
                    }
                    case CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {
                        this._motionData.segments[totalSegmentCount].segmentType =
                            CubismMotionSegmentType.CubismMotionSegmentType_Bezier;
                        this._motionData.segments[totalSegmentCount].evaluate = bezierEvaluate;
                        this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));
                        this._motionData.points[totalPointCount + 1] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 3), json.getMotionCurveSegment(curveCount, segmentPosition + 4));
                        this._motionData.points[totalPointCount + 2] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 5), json.getMotionCurveSegment(curveCount, segmentPosition + 6));
                        totalPointCount += 3;
                        segmentPosition += 7;
                        break;
                    }
                    case CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {
                        this._motionData.segments[totalSegmentCount].segmentType =
                            CubismMotionSegmentType.CubismMotionSegmentType_Stepped;
                        this._motionData.segments[totalSegmentCount].evaluate = steppedEvaluate;
                        this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));
                        totalPointCount += 1;
                        segmentPosition += 3;
                        break;
                    }
                    case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {
                        this._motionData.segments[totalSegmentCount].segmentType =
                            CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;
                        this._motionData.segments[totalSegmentCount].evaluate = inverseSteppedEvaluate;
                        this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));
                        totalPointCount += 1;
                        segmentPosition += 3;
                        break;
                    }
                    default: {
                        CSM_ASSERT(0);
                        break;
                    }
                }
                ++curve.segmentCount;
                ++totalSegmentCount;
            }
            this._motionData.curves.push(curve);
        }
        for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {
            this._motionData.events[userdatacount].fireTime = json.getEventTime(userdatacount);
            this._motionData.events[userdatacount].value = json.getEventValue(userdatacount);
        }
        json.release();
    }
    /**
     * 
     *
     * 
     * 
     *
     * @param beforeCheckTimeSeconds   []
     * @param motionTimeSeconds        []
     */
    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
        this._firedEventValues.length = 0;
        // 
        for (let u = 0; u < this._motionData.eventCount; ++u) {
            if (this._motionData.events[u].fireTime > beforeCheckTimeSeconds &&
                this._motionData.events[u].fireTime <= motionTimeSeconds) {
                this._firedEventValues.push(this._motionData.events[u].value);
            }
        }
        return this._firedEventValues;
    }
}

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(1);

// CONCATENATED MODULE: ./src/cubism4/Cubism4MotionManager.ts





class Cubism4MotionManager_Cubism4MotionManager extends MotionManager["a" /* MotionManager */] {
    constructor(settings, options) {
        var _a;
        super(settings, options);
        this.groups = { idle: 'Idle' };
        this.motionDataType = 'json';
        this.queueManager = new cubismmotionqueuemanager_CubismMotionQueueManager();
        this.definitions = (_a = settings.motions) !== null && _a !== void 0 ? _a : {};
        this.eyeBlinkIds = settings.getEyeBlinkParameters() || [];
        this.lipSyncIds = settings.getLipSyncParameters() || [];
        this.init(options);
    }
    init(options) {
        super.init(options);
        if (this.settings.expressions) {
            this.expressionManager = new Cubism4ExpressionManager_Cubism4ExpressionManager(this.settings, options);
        }
        this.queueManager.setEventCallback((caller, eventValue, customData) => {
            this.emit('motion:' + eventValue);
        });
    }
    isFinished() {
        return this.queueManager.isFinished();
    }
    _startMotion(motion, onFinish) {
        motion.setFinishedMotionHandler(onFinish);
        this.queueManager.stopAllMotions();
        return this.queueManager.startMotion(motion, false, performance.now());
    }
    _stopAllMotions() {
        this.queueManager.stopAllMotions();
    }
    createMotion(data, group, definition) {
        const motion = cubismmotion_CubismMotion.create(data);
        const defaultFadingDuration = (group === this.groups.idle
            ? config["b" /* config */].idleMotionFadingDuration
            : config["b" /* config */].motionFadingDuration) / 1000;
        motion.setFadeInTime(definition.FadeInTime > 0 ? definition.FadeInTime : defaultFadingDuration);
        motion.setFadeOutTime(definition.FadeOutTime > 0 ? definition.FadeOutTime : defaultFadingDuration);
        motion.setEffectIds(this.eyeBlinkIds, this.lipSyncIds);
        return motion;
    }
    getMotionFile(definition) {
        return definition.File;
    }
    getMotionName(definition) {
        return definition.File;
    }
    getSoundFile(definition) {
        return definition.Sound;
    }
    updateParameters(model, now) {
        return this.queueManager.doUpdateMotion(model, now);
    }
    destroy() {
        super.destroy();
        this.queueManager.release();
        this.queueManager = undefined;
    }
}

// EXTERNAL MODULE: ./src/cubism-common/InternalModel.ts
var InternalModel = __webpack_require__(13);

// CONCATENATED MODULE: ./cubism/src/cubismdefaultparameterid.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * @brief ID<br>
 *         <br>
 *         https://docs.live2d.com/cubism-editor-manual/standard-parametor-list/
 */
// ID
const HitAreaPrefix = 'HitArea';
const HitAreaHead = 'Head';
const HitAreaBody = 'Body';
const PartsIdCore = 'Parts01Core';
const PartsArmPrefix = 'Parts01Arm_';
const PartsArmLPrefix = 'Parts01ArmL_';
const PartsArmRPrefix = 'Parts01ArmR_';
// ID
const ParamAngleX = 'ParamAngleX';
const ParamAngleY = 'ParamAngleY';
const ParamAngleZ = 'ParamAngleZ';
const ParamEyeLOpen = 'ParamEyeLOpen';
const ParamEyeLSmile = 'ParamEyeLSmile';
const ParamEyeROpen = 'ParamEyeROpen';
const ParamEyeRSmile = 'ParamEyeRSmile';
const ParamEyeBallX = 'ParamEyeBallX';
const ParamEyeBallY = 'ParamEyeBallY';
const ParamEyeBallForm = 'ParamEyeBallForm';
const ParamBrowLY = 'ParamBrowLY';
const ParamBrowRY = 'ParamBrowRY';
const ParamBrowLX = 'ParamBrowLX';
const ParamBrowRX = 'ParamBrowRX';
const ParamBrowLAngle = 'ParamBrowLAngle';
const ParamBrowRAngle = 'ParamBrowRAngle';
const ParamBrowLForm = 'ParamBrowLForm';
const ParamBrowRForm = 'ParamBrowRForm';
const ParamMouthForm = 'ParamMouthForm';
const ParamMouthOpenY = 'ParamMouthOpenY';
const ParamCheek = 'ParamCheek';
const ParamBodyAngleX = 'ParamBodyAngleX';
const ParamBodyAngleY = 'ParamBodyAngleY';
const ParamBodyAngleZ = 'ParamBodyAngleZ';
const ParamBreath = 'ParamBreath';
const ParamArmLA = 'ParamArmLA';
const ParamArmRA = 'ParamArmRA';
const ParamArmLB = 'ParamArmLB';
const ParamArmRB = 'ParamArmRB';
const ParamHandL = 'ParamHandL';
const ParamHandR = 'ParamHandR';
const ParamHairFront = 'ParamHairFront';
const ParamHairSide = 'ParamHairSide';
const ParamHairBack = 'ParamHairBack';
const ParamHairFluffy = 'ParamHairFluffy';
const ParamShoulderY = 'ParamShoulderY';
const ParamBustX = 'ParamBustX';
const ParamBustY = 'ParamBustY';
const ParamBaseX = 'ParamBaseX';
const ParamBaseY = 'ParamBaseY';
const ParamNONE = 'NONE:';

// CONCATENATED MODULE: ./cubism/src/effect/cubismbreath.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * 
 *
 * 
 */
class CubismBreath {
    /**
     * 
     */
    constructor() {
        this._breathParameters = []; // 
        this._currentTime = 0.0;
    }
    /**
     * 
     */
    static create() {
        return new CubismBreath();
    }
    /**
     * 
     * @param breathParameters 
     */
    setParameters(breathParameters) {
        this._breathParameters = breathParameters;
    }
    /**
     * 
     * @return 
     */
    getParameters() {
        return this._breathParameters;
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     */
    updateParameters(model, deltaTimeSeconds) {
        this._currentTime += deltaTimeSeconds;
        const t = this._currentTime * 2.0 * 3.14159;
        for (let i = 0; i < this._breathParameters.length; ++i) {
            const data = this._breathParameters[i];
            model.addParameterValueById(data.parameterId, data.offset + data.peak * Math.sin(t / data.cycle), data.weight);
        }
    }
}
/**
 * 
 */
class BreathParameterData {
    /**
     * 
     * @param parameterId   ID
     * @param offset        
     * @param peak          
     * @param cycle         
     * @param weight        
     */
    constructor(parameterId, offset, peak, cycle, weight) {
        this.parameterId = parameterId == undefined ? undefined : parameterId;
        this.offset = offset == undefined ? 0.0 : offset;
        this.peak = peak == undefined ? 0.0 : peak;
        this.cycle = cycle == undefined ? 0.0 : cycle;
        this.weight = weight == undefined ? 0.0 : weight;
    }
}

// CONCATENATED MODULE: ./cubism/src/effect/cubismeyeblink.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * 
 *
 * 
 */
class CubismEyeBlink {
    /**
     * 
     * @param modelSetting 
     */
    constructor(modelSetting) {
        var _a, _b;
        this._blinkingState = EyeState.EyeState_First;
        this._nextBlinkingTime = 0.0;
        this._stateStartTimeSeconds = 0.0;
        this._blinkingIntervalSeconds = 4.0;
        this._closingSeconds = 0.1;
        this._closedSeconds = 0.05;
        this._openingSeconds = 0.15;
        this._userTimeSeconds = 0.0;
        this._parameterIds = [];
        if (modelSetting == null) {
            return;
        }
        this._parameterIds = (_b = (_a = modelSetting.getEyeBlinkParameters()) === null || _a === void 0 ? void 0 : _a.slice()) !== null && _b !== void 0 ? _b : this._parameterIds;
    }
    /**
     * 
     * @param modelSetting 
     * @return 
     * @note NULLID
     */
    static create(modelSetting) {
        return new CubismEyeBlink(modelSetting);
    }
    /**
     * 
     * @param blinkingInterval []
     */
    setBlinkingInterval(blinkingInterval) {
        this._blinkingIntervalSeconds = blinkingInterval;
    }
    /**
     * 
     * @param closing   []
     * @param closed    []
     * @param opening   []
     */
    setBlinkingSetting(closing, closed, opening) {
        this._closingSeconds = closing;
        this._closedSeconds = closed;
        this._openingSeconds = opening;
    }
    /**
     * ID
     * @param parameterIds ID
     */
    setParameterIds(parameterIds) {
        this._parameterIds = parameterIds;
    }
    /**
     * ID
     * @return ID
     */
    getParameterIds() {
        return this._parameterIds;
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     */
    updateParameters(model, deltaTimeSeconds) {
        this._userTimeSeconds += deltaTimeSeconds;
        let parameterValue;
        let t = 0.0;
        switch (this._blinkingState) {
            case EyeState.EyeState_Closing:
                t =
                    (this._userTimeSeconds - this._stateStartTimeSeconds) /
                        this._closingSeconds;
                if (t >= 1.0) {
                    t = 1.0;
                    this._blinkingState = EyeState.EyeState_Closed;
                    this._stateStartTimeSeconds = this._userTimeSeconds;
                }
                parameterValue = 1.0 - t;
                break;
            case EyeState.EyeState_Closed:
                t =
                    (this._userTimeSeconds - this._stateStartTimeSeconds) /
                        this._closedSeconds;
                if (t >= 1.0) {
                    this._blinkingState = EyeState.EyeState_Opening;
                    this._stateStartTimeSeconds = this._userTimeSeconds;
                }
                parameterValue = 0.0;
                break;
            case EyeState.EyeState_Opening:
                t =
                    (this._userTimeSeconds - this._stateStartTimeSeconds) /
                        this._openingSeconds;
                if (t >= 1.0) {
                    t = 1.0;
                    this._blinkingState = EyeState.EyeState_Interval;
                    this._nextBlinkingTime = this.determinNextBlinkingTiming();
                }
                parameterValue = t;
                break;
            case EyeState.EyeState_Interval:
                if (this._nextBlinkingTime < this._userTimeSeconds) {
                    this._blinkingState = EyeState.EyeState_Closing;
                    this._stateStartTimeSeconds = this._userTimeSeconds;
                }
                parameterValue = 1.0;
                break;
            case EyeState.EyeState_First:
            default:
                this._blinkingState = EyeState.EyeState_Interval;
                this._nextBlinkingTime = this.determinNextBlinkingTiming();
                parameterValue = 1.0;
                break;
        }
        if (!CubismEyeBlink.CloseIfZero) {
            parameterValue = -parameterValue;
        }
        for (let i = 0; i < this._parameterIds.length; ++i) {
            model.setParameterValueById(this._parameterIds[i], parameterValue);
        }
    }
    /**
     * 
     *
     * @return []
     */
    determinNextBlinkingTiming() {
        const r = Math.random();
        return (this._userTimeSeconds + r * (2.0 * this._blinkingIntervalSeconds - 1.0));
    }
}
/**
 * ID0 true 1 false 
 */
CubismEyeBlink.CloseIfZero = true;
/**
 * 
 *
 * 
 */
var EyeState;
(function (EyeState) {
    EyeState[EyeState["EyeState_First"] = 0] = "EyeState_First";
    EyeState[EyeState["EyeState_Interval"] = 1] = "EyeState_Interval";
    EyeState[EyeState["EyeState_Closing"] = 2] = "EyeState_Closing";
    EyeState[EyeState["EyeState_Closed"] = 3] = "EyeState_Closed";
    EyeState[EyeState["EyeState_Opening"] = 4] = "EyeState_Opening"; // 
})(EyeState || (EyeState = {}));

// CONCATENATED MODULE: ./cubism/src/type/csmrectf.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
/**
 * float
 */
class csmRect {
    /**
     * 
     * @param x X
     * @param y Y
     * @param w 
     * @param h 
     */
    constructor(x = 0, y = 0, w = 0, h = 0) {
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h;
    }
    /**
     * X
     */
    getCenterX() {
        return this.x + 0.5 * this.width;
    }
    /**
     * Y
     */
    getCenterY() {
        return this.y + 0.5 * this.height;
    }
    /**
     * X
     */
    getRight() {
        return this.x + this.width;
    }
    /**
     * Y
     */
    getBottom() {
        return this.y + this.height;
    }
    /**
     * 
     * @param r 
     */
    setRect(r) {
        this.x = r.x;
        this.y = r.y;
        this.width = r.width;
        this.height = r.height;
    }
    /**
     * 
     * @param w 
     * @param h 
     */
    expand(w, h) {
        this.x -= w;
        this.y -= h;
        this.width += w * 2.0;
        this.height += h * 2.0;
    }
}

// CONCATENATED MODULE: ./cubism/src/config.ts
var config_config;
(function (config) {
    config.supportMoreMaskDivisions = true;
})(config_config || (config_config = {}));

// CONCATENATED MODULE: ./cubism/src/rendering/cubismrenderer_webgl.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */






const ColorChannelCount = 4; // 11RGB34
const shaderCount = 10; //  =  + ( +  + ) * ( +  + )
let s_instance;
let s_viewport;
let s_fbo;
/**
 * 
 */
class cubismrenderer_webgl_CubismClippingManager_WebGL {
    /**
     * 
     */
    constructor() {
        this._maskRenderTexture = null;
        this._colorBuffer = null;
        this._currentFrameNo = 0;
        this._clippingMaskBufferSize = 256;
        this._clippingContextListForMask = [];
        this._clippingContextListForDraw = [];
        this._channelColors = [];
        this._tmpBoundsOnModel = new csmRect();
        this._tmpMatrix = new CubismMatrix44();
        this._tmpMatrixForMask = new CubismMatrix44();
        this._tmpMatrixForDraw = new CubismMatrix44();
        let tmp = new CubismTextureColor();
        tmp.R = 1.0;
        tmp.G = 0.0;
        tmp.B = 0.0;
        tmp.A = 0.0;
        this._channelColors.push(tmp);
        tmp = new CubismTextureColor();
        tmp.R = 0.0;
        tmp.G = 1.0;
        tmp.B = 0.0;
        tmp.A = 0.0;
        this._channelColors.push(tmp);
        tmp = new CubismTextureColor();
        tmp.R = 0.0;
        tmp.G = 0.0;
        tmp.B = 1.0;
        tmp.A = 0.0;
        this._channelColors.push(tmp);
        tmp = new CubismTextureColor();
        tmp.R = 0.0;
        tmp.G = 0.0;
        tmp.B = 0.0;
        tmp.A = 1.0;
        this._channelColors.push(tmp);
    }
    /**
     * RGBA
     * @param channelNo RGBA0:R, 1:G, 2:B, 3:A
     */
    getChannelFlagAsColor(channelNo) {
        return this._channelColors[channelNo];
    }
    /**
     * 
     * FrameBufferObject
     *
     * @return 
     */
    getMaskRenderTexture() {
        let ret = 0;
        // RenderTexture
        if (this._maskTexture && this._maskTexture.texture != 0) {
            // 
            this._maskTexture.frameNo = this._currentFrameNo;
            ret = this._maskTexture.texture;
        }
        if (ret == 0) {
            // FrameBufferObject
            // 
            const size = this._clippingMaskBufferSize;
            this._colorBuffer = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, this._colorBuffer);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            ret = this.gl.createFramebuffer();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, ret);
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._colorBuffer, 0);
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
            this._maskTexture = new CubismRenderTextureResource(this._currentFrameNo, ret);
        }
        return ret;
    }
    /**
     * WebGL
     * @param gl WebGL
     */
    setGL(gl) {
        this.gl = gl;
    }
    /**
     * 
     * @param model 
     * @param clippingContext 
     */
    calcClippedDrawTotalBounds(model, clippingContext) {
        // 
        let clippedDrawTotalMinX = Number.MAX_VALUE;
        let clippedDrawTotalMinY = Number.MAX_VALUE;
        let clippedDrawTotalMaxX = Number.MIN_VALUE;
        let clippedDrawTotalMaxY = Number.MIN_VALUE;
        // 
        // 
        const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;
        for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {
            // 
            const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];
            const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);
            const drawableVertexes = model.getDrawableVertices(drawableIndex);
            let minX = Number.MAX_VALUE;
            let minY = Number.MAX_VALUE;
            let maxX = Number.MIN_VALUE;
            let maxY = Number.MIN_VALUE;
            const loop = drawableVertexCount * Constant.vertexStep;
            for (let pi = Constant.vertexOffset; pi < loop; pi += Constant.vertexStep) {
                const x = drawableVertexes[pi];
                const y = drawableVertexes[pi + 1];
                if (x < minX) {
                    minX = x;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }
            // 
            if (minX == Number.MAX_VALUE) {
                continue;
            }
            // 
            if (minX < clippedDrawTotalMinX) {
                clippedDrawTotalMinX = minX;
            }
            if (minY < clippedDrawTotalMinY) {
                clippedDrawTotalMinY = minY;
            }
            if (maxX > clippedDrawTotalMaxX) {
                clippedDrawTotalMaxX = maxX;
            }
            if (maxY > clippedDrawTotalMaxY) {
                clippedDrawTotalMaxY = maxY;
            }
            if (clippedDrawTotalMinX == Number.MAX_VALUE) {
                clippingContext._allClippedDrawRect.x = 0.0;
                clippingContext._allClippedDrawRect.y = 0.0;
                clippingContext._allClippedDrawRect.width = 0.0;
                clippingContext._allClippedDrawRect.height = 0.0;
                clippingContext._isUsing = false;
            }
            else {
                clippingContext._isUsing = true;
                const w = clippedDrawTotalMaxX - clippedDrawTotalMinX;
                const h = clippedDrawTotalMaxY - clippedDrawTotalMinY;
                clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;
                clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;
                clippingContext._allClippedDrawRect.width = w;
                clippingContext._allClippedDrawRect.height = h;
            }
        }
    }
    /**
     * 
     */
    release() {
        var _a, _b, _c;
        const self = this;
        for (let i = 0; i < this._clippingContextListForMask.length; i++) {
            if (this._clippingContextListForMask[i]) {
                (_a = this._clippingContextListForMask[i]) === null || _a === void 0 ? void 0 : _a.release();
            }
        }
        self._clippingContextListForMask = undefined;
        // _clippingContextListForDraw_clippingContextListForMaskDELETE
        self._clippingContextListForDraw = undefined;
        if (this._maskTexture) {
            (_b = this.gl) === null || _b === void 0 ? void 0 : _b.deleteFramebuffer(this._maskTexture.texture);
            self._maskTexture = undefined;
        }
        self._channelColors = undefined;
        // 
        (_c = this.gl) === null || _c === void 0 ? void 0 : _c.deleteTexture(this._colorBuffer);
        this._colorBuffer = null;
    }
    /**
     * 
     * 
     * @param model 
     * @param drawableCount 
     * @param drawableMasks 
     * @param drawableCounts 
     */
    initialize(model, drawableCount, drawableMasks, drawableMaskCounts) {
        // 
        // 
        for (let i = 0; i < drawableCount; i++) {
            if (drawableMaskCounts[i] <= 0) {
                // 
                this._clippingContextListForDraw.push(null);
                continue;
            }
            // ClipContext
            let clippingContext = this.findSameClip(drawableMasks[i], drawableMaskCounts[i]);
            if (clippingContext == null) {
                // 
                clippingContext = new cubismrenderer_webgl_CubismClippingContext(this, drawableMasks[i], drawableMaskCounts[i]);
                this._clippingContextListForMask.push(clippingContext);
            }
            clippingContext.addClippedDrawable(i);
            this._clippingContextListForDraw.push(clippingContext);
        }
    }
    /**
     * 
     * @param model 
     * @param renderer 
     */
    setupClippingContext(model, renderer) {
        this._currentFrameNo++;
        // 
        // 1
        let usingClipCount = 0;
        for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.length; clipIndex++) {
            // 1
            const cc = this._clippingContextListForMask[clipIndex];
            // 
            this.calcClippedDrawTotalBounds(model, cc);
            if (cc._isUsing) {
                usingClipCount++; // 
            }
        }
        // 
        if (usingClipCount > 0) {
            // FrameBuffer
            this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize);
            // active
            this._maskRenderTexture = this.getMaskRenderTexture();
            // DrawMeshNow(to)
            const modelToWorldF = renderer.getMvpMatrix();
            renderer.preDraw(); // 
            // 
            this.setupLayoutBounds(usingClipCount);
            // ----------  ----------
            // RenderTextureactive
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTexture);
            // 
            // () 10Cd*Cs01
            this.gl.clearColor(1.0, 1.0, 1.0, 1.0);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            // 
            // ClipContext, ClippedDrawContext
            for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.length; clipIndex++) {
                // --- 1 ---
                const clipContext = this._clippingContextListForMask[clipIndex];
                const allClipedDrawRect = clipContext._allClippedDrawRect; // 
                const layoutBoundsOnTex01 = clipContext._layoutBounds; // 
                // 
                const MARGIN = 0.05;
                this._tmpBoundsOnModel.setRect(allClipedDrawRect);
                this._tmpBoundsOnModel.expand(allClipedDrawRect.width * MARGIN, allClipedDrawRect.height * MARGIN);
                //########## 
                // 
                // movePeriod' = movePeriod * scaleX + offX		  [[ movePeriod' = (movePeriod - tmpBoundsOnModel.movePeriod)*scale + layoutBoundsOnTex01.movePeriod ]]
                const scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
                const scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
                // 
                {
                    //  <<<<<<<<<<<<<<<<<<<<<<<< 
                    this._tmpMatrix.loadIdentity();
                    {
                        // layout0..1  -1..1
                        this._tmpMatrix.translateRelative(-1.0, -1.0);
                        this._tmpMatrix.scaleRelative(2.0, 2.0);
                    }
                    {
                        // view to layout0..1
                        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
                        this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]
                        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
                        // new = [translate][scale][translate]
                    }
                    // tmpMatrixForMask
                    this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
                }
                //--------- draw mask 
                {
                    //  <<<<<<<<<<<<<<<<<<<<<<<< 
                    this._tmpMatrix.loadIdentity();
                    {
                        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
                        this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]
                        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
                        // new = [translate][scale][translate]
                    }
                    this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
                }
                clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
                clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
                const clipDrawCount = clipContext._clippingIdCount;
                for (let i = 0; i < clipDrawCount; i++) {
                    const clipDrawIndex = clipContext._clippingIdList[i];
                    // 
                    if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {
                        continue;
                    }
                    renderer.setIsCulling(model.getDrawableCulling(clipDrawIndex) != false);
                    // 
                    // (A,R,G,B)
                    renderer.setClippingContextBufferForMask(clipContext);
                    renderer.drawMesh(model.getDrawableTextureIndices(clipDrawIndex), model.getDrawableVertexIndexCount(clipDrawIndex), model.getDrawableVertexCount(clipDrawIndex), model.getDrawableVertexIndices(clipDrawIndex), model.getDrawableVertices(clipDrawIndex), model.getDrawableVertexUvs(clipDrawIndex), model.getDrawableOpacity(clipDrawIndex), CubismBlendMode.CubismBlendMode_Normal, // 
                    false);
                }
            }
            // ---  ---
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 
            renderer.setClippingContextBufferForMask(null);
            this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);
        }
    }
    /**
     * 
     * 
     * NULL
     * @param drawableMasks 
     * @param drawableMaskCounts 
     * @return NULL
     */
    findSameClip(drawableMasks, drawableMaskCounts) {
        // ClippingContext
        for (let i = 0; i < this._clippingContextListForMask.length; i++) {
            const clippingContext = this._clippingContextListForMask[i];
            const count = clippingContext._clippingIdCount;
            // 
            if (count != drawableMaskCounts) {
                continue;
            }
            let sameCount = 0;
            // ID
            for (let j = 0; j < count; j++) {
                const clipId = clippingContext._clippingIdList[j];
                for (let k = 0; k < count; k++) {
                    if (drawableMasks[k] == clipId) {
                        sameCount++;
                        break;
                    }
                }
            }
            if (sameCount == count) {
                return clippingContext;
            }
        }
        return null; // 
    }
    /**
     * 
     * 
     * 4RGBA56RGBA2,2,1,1
     *
     * @param usingClipCount 
     */
    setupLayoutBounds(usingClipCount) {
        // RenderTexture
        // 4RGBA156RGBA2,2,1,1
        // RGBA
        let div = usingClipCount / ColorChannelCount; // 1
        let mod = usingClipCount % ColorChannelCount; // 
        // 
        div = ~~div;
        mod = ~~mod;
        // RGBA0:R, 1:G, 2:B, 3:A
        let curClipIndex = 0; // 
        for (let channelNo = 0; channelNo < ColorChannelCount; channelNo++) {
            // 
            const layoutCount = div + (channelNo < mod ? 1 : 0);
            // 
            if (layoutCount == 0) {
                // 
            }
            else if (layoutCount == 1) {
                // 
                const clipContext = this._clippingContextListForMask[curClipIndex++];
                clipContext._layoutChannelNo = channelNo;
                clipContext._layoutBounds.x = 0.0;
                clipContext._layoutBounds.y = 0.0;
                clipContext._layoutBounds.width = 1.0;
                clipContext._layoutBounds.height = 1.0;
            }
            else if (layoutCount == 2) {
                for (let i = 0; i < layoutCount; i++) {
                    let xpos = i % 2;
                    // 
                    xpos = ~~xpos;
                    const cc = this._clippingContextListForMask[curClipIndex++];
                    cc._layoutChannelNo = channelNo;
                    cc._layoutBounds.x = xpos * 0.5;
                    cc._layoutBounds.y = 0.0;
                    cc._layoutBounds.width = 0.5;
                    cc._layoutBounds.height = 1.0;
                    // UV2
                }
            }
            else if (layoutCount <= 4) {
                // 4
                for (let i = 0; i < layoutCount; i++) {
                    let xpos = i % 2;
                    let ypos = i / 2;
                    // 
                    xpos = ~~xpos;
                    ypos = ~~ypos;
                    const cc = this._clippingContextListForMask[curClipIndex++];
                    cc._layoutChannelNo = channelNo;
                    cc._layoutBounds.x = xpos * 0.5;
                    cc._layoutBounds.y = ypos * 0.5;
                    cc._layoutBounds.width = 0.5;
                    cc._layoutBounds.height = 0.5;
                }
            }
            else if (layoutCount <= 9) {
                // 9
                for (let i = 0; i < layoutCount; i++) {
                    let xpos = i % 3;
                    let ypos = i / 3;
                    // 
                    xpos = ~~xpos;
                    ypos = ~~ypos;
                    const cc = this._clippingContextListForMask[curClipIndex++];
                    cc._layoutChannelNo = channelNo;
                    cc._layoutBounds.x = xpos / 3.0;
                    cc._layoutBounds.y = ypos / 3.0;
                    cc._layoutBounds.width = 1.0 / 3.0;
                    cc._layoutBounds.height = 1.0 / 3.0;
                }
            }
            else if (config_config.supportMoreMaskDivisions && layoutCount <= 16) {
                // support 4x4 division
                // https://docs.live2d.com/cubism-sdk-manual/ow-sdk-mask-premake-web/?locale=en_us
                for (let i = 0; i < layoutCount; i++) {
                    let xpos = i % 4;
                    let ypos = i / 4;
                    // 
                    xpos = ~~xpos;
                    ypos = ~~ypos;
                    const cc = this._clippingContextListForMask[curClipIndex++];
                    cc._layoutChannelNo = channelNo;
                    cc._layoutBounds.x = xpos / 4.0;
                    cc._layoutBounds.y = ypos / 4.0;
                    cc._layoutBounds.width = 1.0 / 4.0;
                    cc._layoutBounds.height = 1.0 / 4.0;
                }
            }
            else {
                CubismLogError('not supported mask count : {0}', layoutCount);
            }
        }
    }
    /**
     * 
     * @return 
     */
    getColorBuffer() {
        return this._colorBuffer;
    }
    /**
     * 
     * @return 
     */
    getClippingContextListForDraw() {
        return this._clippingContextListForDraw;
    }
    /**
     * 
     * @param size 
     */
    setClippingMaskBufferSize(size) {
        this._clippingMaskBufferSize = size;
    }
    /**
     * 
     * @return 
     */
    getClippingMaskBufferSize() {
        return this._clippingMaskBufferSize;
    }
}
/**
 * 
 * 
 */
class CubismRenderTextureResource {
    /**
     * 
     * @param frameNo 
     * @param texture 
     */
    constructor(frameNo, texture) {
        this.frameNo = frameNo;
        this.texture = texture;
    }
}
/**
 * 
 */
class cubismrenderer_webgl_CubismClippingContext {
    /**
     * 
     */
    constructor(manager, clippingDrawableIndices, clipCount) {
        this._isUsing = false; // true
        this._owner = manager;
        // Drawable
        this._clippingIdList = clippingDrawableIndices;
        // 
        this._clippingIdCount = clipCount;
        this._allClippedDrawRect = new csmRect();
        this._layoutBounds = new csmRect();
        this._clippedDrawableIndexList = [];
        this._matrixForMask = new CubismMatrix44();
        this._matrixForDraw = new CubismMatrix44();
    }
    /**
     * 
     */
    release() {
        const self = this;
        self._layoutBounds = undefined;
        self._allClippedDrawRect = undefined;
        self._clippedDrawableIndexList = undefined;
    }
    /**
     * 
     *
     * @param drawableIndex 
     */
    addClippedDrawable(drawableIndex) {
        this._clippedDrawableIndexList.push(drawableIndex);
    }
    /**
     * 
     * @return 
     */
    getClippingManager() {
        return this._owner;
    }
    setGl(gl) {
        this._owner.setGL(gl);
    }
}
/**
 * WebGL
 * CubismShader_WebGL.getInstance
 */
class cubismrenderer_webgl_CubismShader_WebGL {
    /**
     * private
     */
    constructor() {
        this._shaderSets = [];
    }
    /**
     * 
     * @return 
     */
    static getInstance() {
        if (s_instance == null) {
            s_instance = new cubismrenderer_webgl_CubismShader_WebGL();
            return s_instance;
        }
        return s_instance;
    }
    /**
     * 
     */
    static deleteInstance() {
        if (s_instance) {
            s_instance.release();
            s_instance = undefined;
        }
    }
    /**
     * 
     */
    release() {
        this.releaseShaderProgram();
    }
    /**
     * 
     * @param renderer 
     * @param textureId GPUID
     * @param vertexCount 
     * @param vertexArray 
     * @param indexArray 
     * @param uvArray uv
     * @param opacity 
     * @param colorBlendMode 
     * @param baseColor 
     * @param isPremultipliedAlpha 
     * @param matrix4x4 Model-View-Projection
     * @param invertedMask 
     */
    setupShaderProgram(renderer, textureId, vertexCount, vertexArray, indexArray, uvArray, bufferData, opacity, colorBlendMode, baseColor, isPremultipliedAlpha, matrix4x4, invertedMask) {
        if (!isPremultipliedAlpha) {
            CubismLogError('NoPremultipliedAlpha is not allowed');
        }
        if (this._shaderSets.length == 0) {
            this.generateShaders();
        }
        // Blending
        let SRC_COLOR;
        let DST_COLOR;
        let SRC_ALPHA;
        let DST_ALPHA;
        const clippingContextBufferForMask = renderer.getClippingContextBufferForMask();
        if (clippingContextBufferForMask != null) {
            // 
            const shaderSet = this._shaderSets[ShaderNames.ShaderNames_SetupMask];
            this.gl.useProgram(shaderSet.shaderProgram);
            // 
            this.gl.activeTexture(this.gl.TEXTURE0);
            this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
            this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
            // (VBO)
            if (bufferData.vertex == null) {
                bufferData.vertex = this.gl.createBuffer();
            }
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
            this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
            this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);
            // 
            if (bufferData.uv == null) {
                bufferData.uv = this.gl.createBuffer();
            }
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
            this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
            this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
            // 
            const channelNo = clippingContextBufferForMask._layoutChannelNo;
            const colorChannel = clippingContextBufferForMask
                .getClippingManager()
                .getChannelFlagAsColor(channelNo);
            this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);
            this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, clippingContextBufferForMask._matrixForMask.getArray());
            const rect = clippingContextBufferForMask._layoutBounds;
            this.gl.uniform4f(shaderSet.uniformBaseColorLocation, rect.x * 2.0 - 1.0, rect.y * 2.0 - 1.0, rect.getRight() * 2.0 - 1.0, rect.getBottom() * 2.0 - 1.0);
            SRC_COLOR = this.gl.ZERO;
            DST_COLOR = this.gl.ONE_MINUS_SRC_COLOR;
            SRC_ALPHA = this.gl.ZERO;
            DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;
        } // 
        else {
            const clippingContextBufferForDraw = renderer.getClippingContextBufferForDraw();
            const masked = clippingContextBufferForDraw != null; // 
            const offset = masked ? (invertedMask ? 2 : 1) : 0;
            let shaderSet;
            switch (colorBlendMode) {
                case CubismBlendMode.CubismBlendMode_Normal:
                default:
                    shaderSet = this._shaderSets[ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset];
                    SRC_COLOR = this.gl.ONE;
                    DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;
                    SRC_ALPHA = this.gl.ONE;
                    DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;
                    break;
                case CubismBlendMode.CubismBlendMode_Additive:
                    shaderSet = this._shaderSets[ShaderNames.ShaderNames_AddPremultipliedAlpha + offset];
                    SRC_COLOR = this.gl.ONE;
                    DST_COLOR = this.gl.ONE;
                    SRC_ALPHA = this.gl.ZERO;
                    DST_ALPHA = this.gl.ONE;
                    break;
                case CubismBlendMode.CubismBlendMode_Multiplicative:
                    shaderSet = this._shaderSets[ShaderNames.ShaderNames_MultPremultipliedAlpha + offset];
                    SRC_COLOR = this.gl.DST_COLOR;
                    DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;
                    SRC_ALPHA = this.gl.ZERO;
                    DST_ALPHA = this.gl.ONE;
                    break;
            }
            this.gl.useProgram(shaderSet.shaderProgram);
            // 
            if (bufferData.vertex == null) {
                bufferData.vertex = this.gl.createBuffer();
            }
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
            this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
            this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);
            // 
            if (bufferData.uv == null) {
                bufferData.uv = this.gl.createBuffer();
            }
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
            this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
            this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
            // 
            if (clippingContextBufferForDraw != null) {
                this.gl.activeTexture(this.gl.TEXTURE1);
                const tex = clippingContextBufferForDraw
                    .getClippingManager()
                    .getColorBuffer();
                this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
                this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);
                // viewClippingContext
                this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, clippingContextBufferForDraw._matrixForDraw.getArray());
                // 
                const channelNo = clippingContextBufferForDraw._layoutChannelNo;
                const colorChannel = clippingContextBufferForDraw
                    .getClippingManager()
                    .getChannelFlagAsColor(channelNo);
                this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);
            }
            // 
            this.gl.activeTexture(this.gl.TEXTURE0);
            this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
            this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
            // 
            this.gl.uniformMatrix4fv(shaderSet.uniformMatrixLocation, false, matrix4x4.getArray());
            this.gl.uniform4f(shaderSet.uniformBaseColorLocation, baseColor.R, baseColor.G, baseColor.B, baseColor.A);
        }
        // IBO
        if (bufferData.index == null) {
            bufferData.index = this.gl.createBuffer();
        }
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, bufferData.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);
        this.gl.blendFuncSeparate(SRC_COLOR, DST_COLOR, SRC_ALPHA, DST_ALPHA);
    }
    /**
     * 
     */
    releaseShaderProgram() {
        for (let i = 0; i < this._shaderSets.length; i++) {
            this.gl.deleteProgram(this._shaderSets[i].shaderProgram);
            this._shaderSets[i].shaderProgram = 0;
        }
        this._shaderSets = [];
    }
    /**
     * 
     * @param vertShaderSrc 
     * @param fragShaderSrc 
     */
    generateShaders() {
        for (let i = 0; i < shaderCount; i++) {
            this._shaderSets.push({});
        }
        this._shaderSets[0].shaderProgram = this.loadShaderProgram(vertexShaderSrcSetupMask, fragmentShaderSrcsetupMask);
        this._shaderSets[1].shaderProgram = this.loadShaderProgram(vertexShaderSrc, fragmentShaderSrcPremultipliedAlpha);
        this._shaderSets[2].shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskPremultipliedAlpha);
        this._shaderSets[3].shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskInvertedPremultipliedAlpha);
        // 
        this._shaderSets[4].shaderProgram = this._shaderSets[1].shaderProgram;
        this._shaderSets[5].shaderProgram = this._shaderSets[2].shaderProgram;
        this._shaderSets[6].shaderProgram = this._shaderSets[3].shaderProgram;
        // 
        this._shaderSets[7].shaderProgram = this._shaderSets[1].shaderProgram;
        this._shaderSets[8].shaderProgram = this._shaderSets[2].shaderProgram;
        this._shaderSets[9].shaderProgram = this._shaderSets[3].shaderProgram;
        // SetupMask
        this._shaderSets[0].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[0].shaderProgram, 'a_position');
        this._shaderSets[0].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[0].shaderProgram, 'a_texCoord');
        this._shaderSets[0].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, 's_texture0');
        this._shaderSets[0].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, 'u_clipMatrix');
        this._shaderSets[0].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, 'u_channelFlag');
        this._shaderSets[0].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[1].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[1].shaderProgram, 'a_position');
        this._shaderSets[1].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[1].shaderProgram, 'a_texCoord');
        this._shaderSets[1].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, 's_texture0');
        this._shaderSets[1].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, 'u_matrix');
        this._shaderSets[1].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[2].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[2].shaderProgram, 'a_position');
        this._shaderSets[2].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[2].shaderProgram, 'a_texCoord');
        this._shaderSets[2].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, 's_texture0');
        this._shaderSets[2].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, 's_texture1');
        this._shaderSets[2].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, 'u_matrix');
        this._shaderSets[2].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, 'u_clipMatrix');
        this._shaderSets[2].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, 'u_channelFlag');
        this._shaderSets[2].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, 'u_baseColor');
        // , PremultipliedAlpha
        this._shaderSets[3].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[3].shaderProgram, 'a_position');
        this._shaderSets[3].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[3].shaderProgram, 'a_texCoord');
        this._shaderSets[3].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, 's_texture0');
        this._shaderSets[3].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, 's_texture1');
        this._shaderSets[3].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, 'u_matrix');
        this._shaderSets[3].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, 'u_clipMatrix');
        this._shaderSets[3].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, 'u_channelFlag');
        this._shaderSets[3].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[4].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[4].shaderProgram, 'a_position');
        this._shaderSets[4].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[4].shaderProgram, 'a_texCoord');
        this._shaderSets[4].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, 's_texture0');
        this._shaderSets[4].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, 'u_matrix');
        this._shaderSets[4].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[5].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[5].shaderProgram, 'a_position');
        this._shaderSets[5].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[5].shaderProgram, 'a_texCoord');
        this._shaderSets[5].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, 's_texture0');
        this._shaderSets[5].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, 's_texture1');
        this._shaderSets[5].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, 'u_matrix');
        this._shaderSets[5].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, 'u_clipMatrix');
        this._shaderSets[5].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, 'u_channelFlag');
        this._shaderSets[5].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[6].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[6].shaderProgram, 'a_position');
        this._shaderSets[6].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[6].shaderProgram, 'a_texCoord');
        this._shaderSets[6].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, 's_texture0');
        this._shaderSets[6].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, 's_texture1');
        this._shaderSets[6].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, 'u_matrix');
        this._shaderSets[6].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, 'u_clipMatrix');
        this._shaderSets[6].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, 'u_channelFlag');
        this._shaderSets[6].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[7].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[7].shaderProgram, 'a_position');
        this._shaderSets[7].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[7].shaderProgram, 'a_texCoord');
        this._shaderSets[7].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, 's_texture0');
        this._shaderSets[7].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, 'u_matrix');
        this._shaderSets[7].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[8].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[8].shaderProgram, 'a_position');
        this._shaderSets[8].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[8].shaderProgram, 'a_texCoord');
        this._shaderSets[8].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, 's_texture0');
        this._shaderSets[8].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, 's_texture1');
        this._shaderSets[8].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, 'u_matrix');
        this._shaderSets[8].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, 'u_clipMatrix');
        this._shaderSets[8].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, 'u_channelFlag');
        this._shaderSets[8].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, 'u_baseColor');
        // PremultipliedAlpha
        this._shaderSets[9].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[9].shaderProgram, 'a_position');
        this._shaderSets[9].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[9].shaderProgram, 'a_texCoord');
        this._shaderSets[9].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, 's_texture0');
        this._shaderSets[9].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, 's_texture1');
        this._shaderSets[9].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, 'u_matrix');
        this._shaderSets[9].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, 'u_clipMatrix');
        this._shaderSets[9].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, 'u_channelFlag');
        this._shaderSets[9].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, 'u_baseColor');
    }
    /**
     * 
     * @param vertexShaderSource    
     * @param fragmentShaderSource  
     * @return 
     */
    loadShaderProgram(vertexShaderSource, fragmentShaderSource) {
        // Create Shader Program
        let shaderProgram = this.gl.createProgram();
        let vertShader = this.compileShaderSource(this.gl.VERTEX_SHADER, vertexShaderSource);
        if (!vertShader) {
            CubismLogError('Vertex shader compile error!');
            return 0;
        }
        let fragShader = this.compileShaderSource(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
        if (!fragShader) {
            CubismLogError('Vertex shader compile error!');
            return 0;
        }
        // Attach vertex shader to program
        this.gl.attachShader(shaderProgram, vertShader);
        // Attach fragment shader to program
        this.gl.attachShader(shaderProgram, fragShader);
        // link program
        this.gl.linkProgram(shaderProgram);
        const linkStatus = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);
        // 
        if (!linkStatus) {
            CubismLogError('Failed to link program: {0}', shaderProgram);
            this.gl.deleteShader(vertShader);
            this.gl.deleteShader(fragShader);
            if (shaderProgram) {
                this.gl.deleteProgram(shaderProgram);
            }
            return 0;
        }
        // Release vertex and fragment shaders.
        this.gl.deleteShader(vertShader);
        this.gl.deleteShader(fragShader);
        return shaderProgram;
    }
    /**
     * 
     * @param shaderType (Vertex/Fragment)
     * @param shaderSource 
     *
     * @return 
     */
    compileShaderSource(shaderType, shaderSource) {
        const source = shaderSource;
        const shader = this.gl.createShader(shaderType);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!shader) {
            const log = this.gl.getShaderInfoLog(shader);
            CubismLogError('Shader compile log: {0} ', log);
        }
        const status = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);
        if (!status) {
            this.gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    setGl(gl) {
        this.gl = gl;
    }
}
var ShaderNames;
(function (ShaderNames) {
    // SetupMask
    ShaderNames[ShaderNames["ShaderNames_SetupMask"] = 0] = "ShaderNames_SetupMask";
    // Normal
    ShaderNames[ShaderNames["ShaderNames_NormalPremultipliedAlpha"] = 1] = "ShaderNames_NormalPremultipliedAlpha";
    ShaderNames[ShaderNames["ShaderNames_NormalMaskedPremultipliedAlpha"] = 2] = "ShaderNames_NormalMaskedPremultipliedAlpha";
    ShaderNames[ShaderNames["ShaderNames_NomralMaskedInvertedPremultipliedAlpha"] = 3] = "ShaderNames_NomralMaskedInvertedPremultipliedAlpha";
    // Add
    ShaderNames[ShaderNames["ShaderNames_AddPremultipliedAlpha"] = 4] = "ShaderNames_AddPremultipliedAlpha";
    ShaderNames[ShaderNames["ShaderNames_AddMaskedPremultipliedAlpha"] = 5] = "ShaderNames_AddMaskedPremultipliedAlpha";
    ShaderNames[ShaderNames["ShaderNames_AddMaskedPremultipliedAlphaInverted"] = 6] = "ShaderNames_AddMaskedPremultipliedAlphaInverted";
    // Mult
    ShaderNames[ShaderNames["ShaderNames_MultPremultipliedAlpha"] = 7] = "ShaderNames_MultPremultipliedAlpha";
    ShaderNames[ShaderNames["ShaderNames_MultMaskedPremultipliedAlpha"] = 8] = "ShaderNames_MultMaskedPremultipliedAlpha";
    ShaderNames[ShaderNames["ShaderNames_MultMaskedPremultipliedAlphaInverted"] = 9] = "ShaderNames_MultMaskedPremultipliedAlphaInverted";
})(ShaderNames || (ShaderNames = {}));
const vertexShaderSrcSetupMask = 'attribute vec4     a_position;' +
    'attribute vec2     a_texCoord;' +
    'varying vec2       v_texCoord;' +
    'varying vec4       v_myPos;' +
    'uniform mat4       u_clipMatrix;' +
    'void main()' +
    '{' +
    '   gl_Position = u_clipMatrix * a_position;' +
    '   v_myPos = u_clipMatrix * a_position;' +
    '   v_texCoord = a_texCoord;' +
    '   v_texCoord.y = 1.0 - v_texCoord.y;' +
    '}';
const fragmentShaderSrcsetupMask = 'precision mediump float;' +
    'varying vec2       v_texCoord;' +
    'varying vec4       v_myPos;' +
    'uniform vec4       u_baseColor;' +
    'uniform vec4       u_channelFlag;' +
    'uniform sampler2D  s_texture0;' +
    'void main()' +
    '{' +
    '   float isInside = ' +
    '       step(u_baseColor.x, v_myPos.x/v_myPos.w)' +
    '       * step(u_baseColor.y, v_myPos.y/v_myPos.w)' +
    '       * step(v_myPos.x/v_myPos.w, u_baseColor.z)' +
    '       * step(v_myPos.y/v_myPos.w, u_baseColor.w);' +
    '   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;' +
    '}';
//-----  -----
// Normal & Add & Mult 
const vertexShaderSrc = 'attribute vec4     a_position;' + //v.vertex
    'attribute vec2     a_texCoord;' + //v.texcoord
    'varying vec2       v_texCoord;' + //v2f.texcoord
    'uniform mat4       u_matrix;' +
    'void main()' +
    '{' +
    '   gl_Position = u_matrix * a_position;' +
    '   v_texCoord = a_texCoord;' +
    '   v_texCoord.y = 1.0 - v_texCoord.y;' +
    '}';
// Normal & Add & Mult 
const vertexShaderSrcMasked = 'attribute vec4     a_position;' +
    'attribute vec2     a_texCoord;' +
    'varying vec2       v_texCoord;' +
    'varying vec4       v_clipPos;' +
    'uniform mat4       u_matrix;' +
    'uniform mat4       u_clipMatrix;' +
    'void main()' +
    '{' +
    '   gl_Position = u_matrix * a_position;' +
    '   v_clipPos = u_clipMatrix * a_position;' +
    '   v_texCoord = a_texCoord;' +
    '   v_texCoord.y = 1.0 - v_texCoord.y;' +
    '}';
//-----  -----
// Normal & Add & Mult  PremultipliedAlpha
const fragmentShaderSrcPremultipliedAlpha = 'precision mediump float;' +
    'varying vec2       v_texCoord;' + //v2f.texcoord
    'uniform vec4       u_baseColor;' +
    'uniform sampler2D  s_texture0;' + //_MainTex
    'void main()' +
    '{' +
    '   gl_FragColor = texture2D(s_texture0 , v_texCoord) * u_baseColor;' +
    '}';
// Normal PremultipliedAlpha
const fragmentShaderSrcMaskPremultipliedAlpha = 'precision mediump float;' +
    'varying vec2       v_texCoord;' +
    'varying vec4       v_clipPos;' +
    'uniform vec4       u_baseColor;' +
    'uniform vec4       u_channelFlag;' +
    'uniform sampler2D  s_texture0;' +
    'uniform sampler2D  s_texture1;' +
    'void main()' +
    '{' +
    '   vec4 col_formask = texture2D(s_texture0 , v_texCoord) * u_baseColor;' +
    '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +
    '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +
    '   col_formask = col_formask * maskVal;' +
    '   gl_FragColor = col_formask;' +
    '}';
// Normal & Add & Mult PremultipliedAlpha
const fragmentShaderSrcMaskInvertedPremultipliedAlpha = 'precision mediump float;' +
    'varying vec2 v_texCoord;' +
    'varying vec4 v_clipPos;' +
    'uniform sampler2D s_texture0;' +
    'uniform sampler2D s_texture1;' +
    'uniform vec4 u_channelFlag;' +
    'uniform vec4 u_baseColor;' +
    'void main()' +
    '{' +
    'vec4 col_formask = texture2D(s_texture0, v_texCoord) * u_baseColor;' +
    'vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +
    'float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +
    'col_formask = col_formask * (1.0 - maskVal);' +
    'gl_FragColor = col_formask;' +
    '}';
/**
 * WebGL
 */
class cubismrenderer_webgl_CubismRenderer_WebGL extends cubismrenderer_CubismRenderer {
    /**
     * 
     */
    constructor() {
        super();
        this._clippingContextBufferForMask = null;
        this._clippingContextBufferForDraw = null;
        this._clippingManager = new cubismrenderer_webgl_CubismClippingManager_WebGL();
        this.firstDraw = true;
        this._textures = {};
        this._sortedDrawableIndexList = [];
        this._bufferData = {
            vertex: null,
            uv: null,
            index: null,
        };
    }
    /**
     * 
     * 
     *
     * @param model 
     */
    initialize(model) {
        if (model.isUsingMasking()) {
            this._clippingManager = new cubismrenderer_webgl_CubismClippingManager_WebGL(); // 
            this._clippingManager.initialize(model, model.getDrawableCount(), model.getDrawableMasks(), model.getDrawableMaskCounts());
        }
        for (let i = model.getDrawableCount() - 1; i >= 0; i--) {
            this._sortedDrawableIndexList[i] = 0;
        }
        super.initialize(model); // 
    }
    /**
     * WebGL
     * CubismRendererCubismRendererIndex
     * @param modelTextureNo 
     * @param glTextureNo WebGL
     */
    bindTexture(modelTextureNo, glTexture) {
        this._textures[modelTextureNo] = glTexture;
    }
    /**
     * WebGL
     * @return 
     */
    getBindedTextures() {
        return this._textures;
    }
    /**
     * 
     * FrameBuffer
     * @param size 
     */
    setClippingMaskBufferSize(size) {
        // FrameBuffer
        this._clippingManager.release();
        this._clippingManager = new cubismrenderer_webgl_CubismClippingManager_WebGL();
        this._clippingManager.setClippingMaskBufferSize(size);
        this._clippingManager.initialize(this.getModel(), this.getModel().getDrawableCount(), this.getModel().getDrawableMasks(), this.getModel().getDrawableMaskCounts());
    }
    /**
     * 
     * @return 
     */
    getClippingMaskBufferSize() {
        return this._clippingManager.getClippingMaskBufferSize();
    }
    /**
     * 
     */
    release() {
        var _a, _b, _c;
        const self = this;
        this._clippingManager.release();
        self._clippingManager = undefined;
        (_a = this.gl) === null || _a === void 0 ? void 0 : _a.deleteBuffer(this._bufferData.vertex);
        this._bufferData.vertex = null;
        (_b = this.gl) === null || _b === void 0 ? void 0 : _b.deleteBuffer(this._bufferData.uv);
        this._bufferData.uv = null;
        (_c = this.gl) === null || _c === void 0 ? void 0 : _c.deleteBuffer(this._bufferData.index);
        this._bufferData.index = null;
        self._bufferData = undefined;
        self._textures = undefined;
    }
    /**
     * 
     */
    doDrawModel() {
        // PreDraw!!
        this.preDraw();
        //------------  ------------
        if (this._clippingManager != null) {
            this._clippingManager.setupClippingContext(this.getModel(), this);
        }
        const drawableCount = this.getModel().getDrawableCount();
        const renderOrder = this.getModel().getDrawableRenderOrders();
        // 
        for (let i = 0; i < drawableCount; ++i) {
            const order = renderOrder[i];
            this._sortedDrawableIndexList[order] = i;
        }
        // 
        for (let i = 0; i < drawableCount; ++i) {
            const drawableIndex = this._sortedDrawableIndexList[i];
            // Drawable
            if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {
                continue;
            }
            // 
            this.setClippingContextBufferForDraw(this._clippingManager != null
                ? this._clippingManager.getClippingContextListForDraw()[drawableIndex]
                : null);
            this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));
            this.drawMesh(this.getModel().getDrawableTextureIndices(drawableIndex), this.getModel().getDrawableVertexIndexCount(drawableIndex), this.getModel().getDrawableVertexCount(drawableIndex), this.getModel().getDrawableVertexIndices(drawableIndex), this.getModel().getDrawableVertices(drawableIndex), this.getModel().getDrawableVertexUvs(drawableIndex), this.getModel().getDrawableOpacity(drawableIndex), this.getModel().getDrawableBlendMode(drawableIndex), this.getModel().getDrawableInvertedMaskBit(drawableIndex));
        }
    }
    /**
     * []
     * 
     * 
     * @param textureNo 
     * @param indexCount 
     * @param vertexCount 
     * @param indexArray 
     * @param vertexArray 
     * @param uvArray uv
     * @param opacity 
     * @param colorBlendMode 
     * @param invertedMask 
     */
    drawMesh(textureNo, indexCount, vertexCount, indexArray, vertexArray, uvArray, opacity, colorBlendMode, invertedMask) {
        // 
        if (this.isCulling()) {
            this.gl.enable(this.gl.CULL_FACE);
        }
        else {
            this.gl.disable(this.gl.CULL_FACE);
        }
        this.gl.frontFace(this.gl.CCW); // Cubism SDK OpenGLCCW
        const modelColorRGBA = this.getModelColor();
        if (this.getClippingContextBufferForMask() == null) {
            // 
            modelColorRGBA.A *= opacity;
            if (this.isPremultipliedAlpha()) {
                modelColorRGBA.R *= modelColorRGBA.A;
                modelColorRGBA.G *= modelColorRGBA.A;
                modelColorRGBA.B *= modelColorRGBA.A;
            }
        }
        let drawtexture = null; // 
        // 
        // ID
        if (this._textures[textureNo] != null) {
            drawtexture = this._textures[textureNo];
        }
        cubismrenderer_webgl_CubismShader_WebGL.getInstance().setupShaderProgram(this, drawtexture, vertexCount, vertexArray, indexArray, uvArray, this._bufferData, opacity, colorBlendMode, modelColorRGBA, this.isPremultipliedAlpha(), this.getMvpMatrix(), invertedMask);
        // 
        this.gl.drawElements(this.gl.TRIANGLES, indexCount, this.gl.UNSIGNED_SHORT, 0);
        // 
        this.gl.useProgram(null);
        this.setClippingContextBufferForDraw(null);
        this.setClippingContextBufferForMask(null);
    }
    /**
     * 
     * WebGL
     */
    static doStaticRelease() {
        cubismrenderer_webgl_CubismShader_WebGL.deleteInstance();
    }
    /**
     * 
     * @param fbo 
     * @param viewport 
     */
    setRenderState(fbo, viewport) {
        s_fbo = fbo;
        s_viewport = viewport;
    }
    /**
     * 
     * 
     */
    preDraw() {
        if (this.firstDraw) {
            this.firstDraw = false;
            // 
            this._anisortopy =
                this.gl.getExtension('EXT_texture_filter_anisotropic') ||
                    this.gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||
                    this.gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
        }
        this.gl.disable(this.gl.SCISSOR_TEST);
        this.gl.disable(this.gl.STENCIL_TEST);
        this.gl.disable(this.gl.DEPTH_TEST);
        // 1.0beta3
        this.gl.frontFace(this.gl.CW);
        this.gl.enable(this.gl.BLEND);
        this.gl.colorMask(true, true, true, true);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); // 
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
    }
    /**
     * 
     */
    setClippingContextBufferForMask(clip) {
        this._clippingContextBufferForMask = clip;
    }
    /**
     * 
     * @return 
     */
    getClippingContextBufferForMask() {
        return this._clippingContextBufferForMask;
    }
    /**
     * 
     */
    setClippingContextBufferForDraw(clip) {
        this._clippingContextBufferForDraw = clip;
    }
    /**
     * 
     * @return 
     */
    getClippingContextBufferForDraw() {
        return this._clippingContextBufferForDraw;
    }
    /**
     * gl
     */
    startUp(gl) {
        this.gl = gl;
        this._clippingManager.setGL(gl);
        cubismrenderer_webgl_CubismShader_WebGL.getInstance().setGl(gl);
    }
}
/**
 * 
 */
cubismrenderer_CubismRenderer.staticRelease = () => {
    cubismrenderer_webgl_CubismRenderer_WebGL.doStaticRelease();
};

// EXTERNAL MODULE: external {"commonjs":"@pixi/math","commonjs2":"@pixi/math","amd":"@pixi/math","root":"PIXI"}
var math_root_PIXI_ = __webpack_require__(5);

// EXTERNAL MODULE: external "lodash/mapKeys"
var mapKeys_ = __webpack_require__(24);
var mapKeys_default = /*#__PURE__*/__webpack_require__.n(mapKeys_);

// CONCATENATED MODULE: ./src/cubism4/Cubism4InternalModel.ts









const tempMatrix = new CubismMatrix44();
class Cubism4InternalModel_Cubism4InternalModel extends InternalModel["a" /* InternalModel */] {
    constructor(coreModel, settings, options) {
        super();
        this.lipSync = true;
        this.breath = CubismBreath.create();
        this.renderer = new cubismrenderer_webgl_CubismRenderer_WebGL();
        this.idParamAngleX = ParamAngleX;
        this.idParamAngleY = ParamAngleY;
        this.idParamAngleZ = ParamAngleZ;
        this.idParamEyeBallX = ParamEyeBallX;
        this.idParamEyeBallY = ParamEyeBallY;
        this.idParamBodyAngleX = ParamBodyAngleX;
        this.idParamBreath = ParamBreath;
        /**
         * The model's internal scale, defined in the moc3 file.
         */
        this.pixelsPerUnit = 1;
        /**
         * Matrix that scales by {@link pixelsPerUnit}, and moves the origin from top-left to center.
         *
         * FIXME: This shouldn't be named as "centering"...
         */
        this.centeringTransform = new math_root_PIXI_["Matrix"]();
        this.coreModel = coreModel;
        this.settings = settings;
        this.motionManager = new Cubism4MotionManager_Cubism4MotionManager(settings, options);
        this.init();
    }
    init() {
        var _a;
        super.init();
        if (((_a = this.settings.getEyeBlinkParameters()) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            this.eyeBlink = CubismEyeBlink.create(this.settings);
        }
        this.breath.setParameters([
            new BreathParameterData(this.idParamAngleX, 0.0, 15.0, 6.5345, 0.5),
            new BreathParameterData(this.idParamAngleY, 0.0, 8.0, 3.5345, 0.5),
            new BreathParameterData(this.idParamAngleZ, 0.0, 10.0, 5.5345, 0.5),
            new BreathParameterData(this.idParamBodyAngleX, 0.0, 4.0, 15.5345, 0.5),
            new BreathParameterData(this.idParamBreath, 0.0, 0.5, 3.2345, 0.5),
        ]);
        this.renderer.initialize(this.coreModel);
        this.renderer.setIsPremultipliedAlpha(true);
    }
    getSize() {
        return [this.coreModel.getModel().canvasinfo.CanvasWidth, this.coreModel.getModel().canvasinfo.CanvasHeight];
    }
    getLayout() {
        // un-capitalize each key to satisfy the common layout format
        // e.g. CenterX -> centerX
        return mapKeys_default()(Object.assign({}, this.settings.layout), (_, key) => key.charAt(0).toLowerCase() + key.slice(1));
    }
    setupLayout() {
        super.setupLayout();
        this.pixelsPerUnit = this.coreModel.getModel().canvasinfo.PixelsPerUnit;
        // move the origin from top left to center
        this.centeringTransform
            .scale(this.pixelsPerUnit, this.pixelsPerUnit)
            .translate(this.originalWidth / 2, this.originalHeight / 2);
    }
    updateWebGLContext(gl, glContextID) {
        // reset resources that were bound to previous WebGL context
        this.renderer.firstDraw = true;
        this.renderer._bufferData = {
            vertex: null,
            uv: null,
            index: null,
        };
        this.renderer.startUp(gl);
        this.renderer._clippingManager._currentFrameNo = glContextID;
        this.renderer._clippingManager._maskTexture = undefined;
        cubismrenderer_webgl_CubismShader_WebGL.getInstance()._shaderSets = [];
    }
    bindTexture(index, texture) {
        this.renderer.bindTexture(index, texture);
    }
    getHitAreaDefs() {
        var _a, _b;
        return (_b = (_a = this.settings.hitAreas) === null || _a === void 0 ? void 0 : _a.map(hitArea => ({
            id: hitArea.Id,
            name: hitArea.Name,
            index: this.coreModel.getDrawableIndex(hitArea.Id),
        }))) !== null && _b !== void 0 ? _b : [];
    }
    getDrawableIDs() {
        return this.coreModel.getDrawableIds();
    }
    getDrawableIndex(id) {
        return this.coreModel.getDrawableIndex(id);
    }
    getDrawableVertices(drawIndex) {
        if (typeof drawIndex === 'string') {
            drawIndex = this.coreModel.getDrawableIndex(drawIndex);
            if (drawIndex === -1)
                throw new TypeError('Unable to find drawable ID: ' + drawIndex);
        }
        const arr = this.coreModel.getDrawableVertices(drawIndex).slice();
        for (let i = 0; i < arr.length; i += 2) {
            arr[i] = arr[i] * this.pixelsPerUnit + this.originalWidth / 2;
            arr[i + 1] = -arr[i + 1] * this.pixelsPerUnit + this.originalHeight / 2;
        }
        return arr;
    }
    updateTransform(transform) {
        this.drawingMatrix
            .copyFrom(this.centeringTransform)
            .prepend(this.localTransform)
            .prepend(transform);
    }
    update(dt, now) {
        var _a, _b, _c;
        super.update(dt, now);
        // cubism4 uses seconds
        dt /= 1000;
        now /= 1000;
        const model = this.coreModel;
        this.emit('beforeMotionUpdate');
        const motionUpdated = this.motionManager.update(this.coreModel, now);
        this.emit('afterMotionUpdate');
        model.saveParameters();
        if (!motionUpdated) {
            (_a = this.eyeBlink) === null || _a === void 0 ? void 0 : _a.updateParameters(model, dt);
        }
        this.updateFocus();
        // revert the timestamps to be milliseconds
        this.updateNaturalMovements(dt * 1000, now * 1000);
        // TODO: Add lip sync API
        // if (this.lipSync) {
        //     const value = 0; // 0 ~ 1
        //
        //     for (let i = 0; i < this.lipSyncIds.length; ++i) {
        //         model.addParameterValueById(this.lipSyncIds[i], value, 0.8);
        //     }
        // }
        (_b = this.physics) === null || _b === void 0 ? void 0 : _b.evaluate(model, dt);
        (_c = this.pose) === null || _c === void 0 ? void 0 : _c.updateParameters(model, dt);
        this.emit('beforeModelUpdate');
        model.update();
        model.loadParameters();
    }
    updateFocus() {
        this.coreModel.addParameterValueById(this.idParamEyeBallX, this.focusController.x); // -1 ~ 1
        this.coreModel.addParameterValueById(this.idParamEyeBallY, this.focusController.y);
        this.coreModel.addParameterValueById(this.idParamAngleX, this.focusController.x * 30); // -30 ~ 30
        this.coreModel.addParameterValueById(this.idParamAngleY, this.focusController.y * 30);
        this.coreModel.addParameterValueById(this.idParamAngleZ, this.focusController.x * this.focusController.y * -30);
        this.coreModel.addParameterValueById(this.idParamBodyAngleX, this.focusController.x * 10); // -10 ~ 10
    }
    updateNaturalMovements(dt, now) {
        var _a;
        (_a = this.breath) === null || _a === void 0 ? void 0 : _a.updateParameters(this.coreModel, dt / 1000);
    }
    draw(gl) {
        const matrix = this.drawingMatrix;
        const array = tempMatrix.getArray();
        // set given 3x3 matrix into a 4x4 matrix, with Y inverted
        array[0] = matrix.a;
        array[1] = matrix.b;
        array[4] = -matrix.c;
        array[5] = -matrix.d;
        array[12] = matrix.tx;
        array[13] = matrix.ty;
        this.renderer.setMvpMatrix(tempMatrix);
        this.renderer.setRenderState(gl.getParameter(gl.FRAMEBUFFER_BINDING), this.viewport);
        this.renderer.drawModel();
    }
    destroy() {
        super.destroy();
        this.renderer.release();
        this.coreModel.release();
        this.renderer = undefined;
        this.coreModel = undefined;
    }
}

// CONCATENATED MODULE: ./src/cubism4/setup.ts


let startupPromise;
let startupRetries = 20;
/**
 * Promises the Cubism 4 runtime has been started up.
 * @return Promise that resolves if the startup has succeeded, rejects if failed.
 */
function cubism4Ready() {
    if (live2dcubismframework_CubismFramework.isStarted()) {
        return Promise.resolve();
    }
    startupPromise !== null && startupPromise !== void 0 ? startupPromise : (startupPromise = new Promise(((resolve, reject) => {
        function startUpWithRetry() {
            try {
                startUpCubism4();
                resolve();
            }
            catch (e) {
                startupRetries--;
                if (startupRetries < 0) {
                    const err = new Error('Failed to start up Cubism 4 framework.');
                    err.cause = e;
                    reject(err);
                    return;
                }
                utils["f" /* logger */].log('Cubism4', 'Startup failed, retrying 10ms later...');
                setTimeout(startUpWithRetry, 10);
            }
        }
        startUpWithRetry();
    })));
    return startupPromise;
}
/**
 * Starts up the Cubism 4 runtime.
 */
function startUpCubism4(options) {
    options = Object.assign({
        logFunction: console.log,
        loggingLevel: LogLevel.LogLevel_Verbose,
    }, options);
    live2dcubismframework_CubismFramework.startUp(options);
    live2dcubismframework_CubismFramework.initialize();
}

// EXTERNAL MODULE: ./src/factory/Live2DFactory.ts + 2 modules
var Live2DFactory = __webpack_require__(4);

// CONCATENATED MODULE: ./cubism/src/effect/cubismpose.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */
const Epsilon = 0.001;
const DefaultFadeInSeconds = 0.5;
/**
 * 
 *
 * 
 */
class CubismPose {
    /**
     * 
     */
    constructor() {
        this._fadeTimeSeconds = DefaultFadeInSeconds;
        this._lastModel = undefined;
        this._partGroups = [];
        this._partGroupCounts = [];
    }
    /**
     * 
     * @param pose3json pose3.json
     * @return 
     */
    static create(pose3json) {
        const ret = new CubismPose();
        // 
        if (typeof pose3json.FadeInTime === 'number') {
            ret._fadeTimeSeconds = pose3json.FadeInTime;
            if (ret._fadeTimeSeconds <= 0.0) {
                ret._fadeTimeSeconds = DefaultFadeInSeconds;
            }
        }
        // 
        const poseListInfo = pose3json.Groups;
        const poseCount = poseListInfo.length;
        for (let poseIndex = 0; poseIndex < poseCount; ++poseIndex) {
            const idListInfo = poseListInfo[poseIndex];
            const idCount = idListInfo.length;
            let groupCount = 0;
            for (let groupIndex = 0; groupIndex < idCount; ++groupIndex) {
                const partInfo = idListInfo[groupIndex];
                const partData = new PartData();
                partData.partId = partInfo.Id;
                const linkListInfo = partInfo.Link;
                // 
                if (linkListInfo) {
                    const linkCount = linkListInfo.length;
                    for (let linkIndex = 0; linkIndex < linkCount; ++linkIndex) {
                        const linkPart = new PartData();
                        linkPart.partId = linkListInfo[linkIndex];
                        partData.link.push(linkPart);
                    }
                }
                ret._partGroups.push(partData);
                ++groupCount;
            }
            ret._partGroupCounts.push(groupCount);
        }
        return ret;
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     */
    updateParameters(model, deltaTimeSeconds) {
        // 
        if (model != this._lastModel) {
            // 
            this.reset(model);
        }
        this._lastModel = model;
        // 0
        if (deltaTimeSeconds < 0.0) {
            deltaTimeSeconds = 0.0;
        }
        let beginIndex = 0;
        for (let i = 0; i < this._partGroupCounts.length; i++) {
            const partGroupCount = this._partGroupCounts[i];
            this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);
            beginIndex += partGroupCount;
        }
        this.copyPartOpacities(model);
    }
    /**
     * 
     * @param model 
     * @note 0
     */
    reset(model) {
        let beginIndex = 0;
        for (let i = 0; i < this._partGroupCounts.length; ++i) {
            const groupCount = this._partGroupCounts[i];
            for (let j = beginIndex; j < beginIndex + groupCount; ++j) {
                this._partGroups[j].initialize(model);
                const partsIndex = this._partGroups[j].partIndex;
                const paramIndex = this._partGroups[j].parameterIndex;
                if (partsIndex < 0) {
                    continue;
                }
                model.setPartOpacityByIndex(partsIndex, j == beginIndex ? 1.0 : 0.0);
                model.setParameterValueByIndex(paramIndex, j == beginIndex ? 1.0 : 0.0);
                for (let k = 0; k < this._partGroups[j].link.length; ++k) {
                    this._partGroups[j]
                        .link[k]
                        .initialize(model);
                }
            }
            beginIndex += groupCount;
        }
    }
    /**
     * 
     *
     * @param model 
     */
    copyPartOpacities(model) {
        for (let groupIndex = 0; groupIndex < this._partGroups.length; ++groupIndex) {
            const partData = this._partGroups[groupIndex];
            if (partData.link.length == 0) {
                continue; // 
            }
            const partIndex = this._partGroups[groupIndex].partIndex;
            const opacity = model.getPartOpacityByIndex(partIndex);
            for (let linkIndex = 0; linkIndex < partData.link.length; ++linkIndex) {
                const linkPart = partData.link[linkIndex];
                const linkPartIndex = linkPart.partIndex;
                if (linkPartIndex < 0) {
                    continue;
                }
                model.setPartOpacityByIndex(linkPartIndex, opacity);
            }
        }
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     * @param beginIndex 
     * @param partGroupCount 
     */
    doFade(model, deltaTimeSeconds, beginIndex, partGroupCount) {
        let visiblePartIndex = -1;
        let newOpacity = 1.0;
        const phi = 0.5;
        const backOpacityThreshold = 0.15;
        // 
        for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
            const partIndex = this._partGroups[i].partIndex;
            const paramIndex = this._partGroups[i].parameterIndex;
            if (model.getParameterValueByIndex(paramIndex) > Epsilon) {
                if (visiblePartIndex >= 0) {
                    break;
                }
                visiblePartIndex = i;
                newOpacity = model.getPartOpacityByIndex(partIndex);
                // 
                newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;
                if (newOpacity > 1.0) {
                    newOpacity = 1.0;
                }
            }
        }
        if (visiblePartIndex < 0) {
            visiblePartIndex = 0;
            newOpacity = 1.0;
        }
        // 
        for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
            const partsIndex = this._partGroups[i].partIndex;
            // 
            if (visiblePartIndex == i) {
                model.setPartOpacityByIndex(partsIndex, newOpacity); // 
            }
            // 
            else {
                let opacity = model.getPartOpacityByIndex(partsIndex);
                let a1; // 
                if (newOpacity < phi) {
                    a1 = (newOpacity * (phi - 1)) / phi + 1.0; // (0,1),(phi,phi)
                }
                else {
                    a1 = ((1 - newOpacity) * phi) / (1.0 - phi); // (1,0),(phi,phi)
                }
                // 
                const backOpacity = (1.0 - a1) * (1.0 - newOpacity);
                if (backOpacity > backOpacityThreshold) {
                    a1 = 1.0 - backOpacityThreshold / (1.0 - newOpacity);
                }
                if (opacity > a1) {
                    opacity = a1; // 
                }
                model.setPartOpacityByIndex(partsIndex, opacity);
            }
        }
    }
}
/**
 * 
 */
class PartData {
    /**
     * 
     */
    constructor(v) {
        this.parameterIndex = 0;
        this.partIndex = 0;
        this.partId = '';
        this.link = [];
        if (v != undefined) {
            this.assignment(v);
        }
    }
    /**
     * =
     */
    assignment(v) {
        this.partId = v.partId;
        this.link = v.link.map(link => link.clone());
        return this;
    }
    /**
     * 
     * @param model 
     */
    initialize(model) {
        this.parameterIndex = model.getParameterIndex(this.partId);
        this.partIndex = model.getPartIndex(this.partId);
        model.setParameterValueByIndex(this.parameterIndex, 1);
    }
    /**
     * 
     */
    clone() {
        const clonePartData = new PartData();
        clonePartData.partId = this.partId;
        clonePartData.parameterIndex = this.parameterIndex;
        clonePartData.partIndex = this.partIndex;
        clonePartData.link = this.link.map(link => link.clone());
        return clonePartData;
    }
}

// CONCATENATED MODULE: ./cubism/src/model/cubismmodel.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */


/**
 * 
 *
 * Moc
 */
class cubismmodel_CubismModel {
    /**
     * 
     * @param model 
     */
    constructor(model) {
        this._model = model;
        this._savedParameters = [];
        this._parameterIds = [];
        this._drawableIds = [];
        this._partIds = [];
        this._notExistPartId = {};
        this._notExistParameterId = {};
        this._notExistParameterValues = {};
        this._notExistPartOpacities = {};
        this.initialize();
    }
    /**
     * 
     */
    update() {
        // Update model
        this._model.update();
        this._model.drawables.resetDynamicFlags();
    }
    /**
     * 
     */
    getCanvasWidth() {
        if (this._model == null) {
            return 0.0;
        }
        return (this._model.canvasinfo.CanvasWidth /
            this._model.canvasinfo.PixelsPerUnit);
    }
    /**
     * 
     */
    getCanvasHeight() {
        if (this._model == null) {
            return 0.0;
        }
        return (this._model.canvasinfo.CanvasHeight /
            this._model.canvasinfo.PixelsPerUnit);
    }
    /**
     * 
     */
    saveParameters() {
        const parameterCount = this._model.parameters.count;
        const savedParameterCount = this._savedParameters.length;
        for (let i = 0; i < parameterCount; ++i) {
            if (i < savedParameterCount) {
                this._savedParameters[i] = this._parameterValues[i];
            }
            else {
                this._savedParameters.push(this._parameterValues[i]);
            }
        }
    }
    /**
     * 
     */
    getModel() {
        return this._model;
    }
    /**
     * 
     * @param partId ID
     * @return 
     */
    getPartIndex(partId) {
        let partIndex;
        const partCount = this._model.parts.count;
        for (partIndex = 0; partIndex < partCount; ++partIndex) {
            if (partId == this._partIds[partIndex]) {
                return partIndex;
            }
        }
        // ID
        if (partId in this._notExistPartId) {
            return this._notExistPartId[partId];
        }
        // ID
        partIndex = partCount + this._notExistPartId.length;
        this._notExistPartId[partId] = partIndex;
        this._notExistPartOpacities[partIndex] = 0;
        return partIndex;
    }
    /**
     * 
     * @return 
     */
    getPartCount() {
        return this._model.parts.count;
    }
    /**
     * (Index)
     * @param partIndex 
     * @param opacity 
     */
    setPartOpacityByIndex(partIndex, opacity) {
        if (partIndex in this._notExistPartOpacities) {
            this._notExistPartOpacities[partIndex] = opacity;
            return;
        }
        // 
        CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
        this._partOpacities[partIndex] = opacity;
    }
    /**
     * (Id)
     * @param partId ID
     * @param opacity 
     */
    setPartOpacityById(partId, opacity) {
        // PartIndex
        const index = this.getPartIndex(partId);
        if (index < 0) {
            return; // 
        }
        this.setPartOpacityByIndex(index, opacity);
    }
    /**
     * (index)
     * @param partIndex 
     * @return 
     */
    getPartOpacityByIndex(partIndex) {
        if (partIndex in this._notExistPartOpacities) {
            // ID
            return this._notExistPartOpacities[partIndex];
        }
        // 
        CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
        return this._partOpacities[partIndex];
    }
    /**
     * (id)
     * @param partId 
     * @return 
     */
    getPartOpacityById(partId) {
        // PartIndex
        const index = this.getPartIndex(partId);
        if (index < 0) {
            return 0; // 
        }
        return this.getPartOpacityByIndex(index);
    }
    /**
     * 
     * @param ID
     * @return 
     */
    getParameterIndex(parameterId) {
        let parameterIndex;
        const idCount = this._model.parameters.count;
        for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {
            if (parameterId != this._parameterIds[parameterIndex]) {
                continue;
            }
            return parameterIndex;
        }
        // ID
        if (parameterId in this._notExistParameterId) {
            return this._notExistParameterId[parameterId];
        }
        // ID
        parameterIndex = this._model.parameters.count + Object.keys(this._notExistParameterId).length;
        this._notExistParameterId[parameterId] = parameterIndex;
        this._notExistParameterValues[parameterIndex] = 0;
        return parameterIndex;
    }
    /**
     * 
     * @return 
     */
    getParameterCount() {
        return this._model.parameters.count;
    }
    /**
     * 
     * @param parameterIndex 
     * @return 
     */
    getParameterMaximumValue(parameterIndex) {
        return this._model.parameters.maximumValues[parameterIndex];
    }
    /**
     * 
     * @param parameterIndex 
     * @return 
     */
    getParameterMinimumValue(parameterIndex) {
        return this._model.parameters.minimumValues[parameterIndex];
    }
    /**
     * 
     * @param parameterIndex 
     * @return 
     */
    getParameterDefaultValue(parameterIndex) {
        return this._model.parameters.defaultValues[parameterIndex];
    }
    /**
     * 
     * @param parameterIndex    
     * @return 
     */
    getParameterValueByIndex(parameterIndex) {
        if (parameterIndex in this._notExistParameterValues) {
            return this._notExistParameterValues[parameterIndex];
        }
        // 
        CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());
        return this._parameterValues[parameterIndex];
    }
    /**
     * 
     * @param parameterId    ID
     * @return 
     */
    getParameterValueById(parameterId) {
        // parameterIndex
        const parameterIndex = this.getParameterIndex(parameterId);
        return this.getParameterValueByIndex(parameterIndex);
    }
    /**
     * 
     * @param parameterIndex 
     * @param value 
     * @param weight 
     */
    setParameterValueByIndex(parameterIndex, value, weight = 1.0) {
        if (parameterIndex in this._notExistParameterValues) {
            this._notExistParameterValues[parameterIndex] =
                weight == 1
                    ? value
                    : this._notExistParameterValues[parameterIndex] *
                        (1 - weight) +
                        value * weight;
            return;
        }
        // 
        CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());
        if (this._model.parameters.maximumValues[parameterIndex] < value) {
            value = this._model.parameters.maximumValues[parameterIndex];
        }
        if (this._model.parameters.minimumValues[parameterIndex] > value) {
            value = this._model.parameters.minimumValues[parameterIndex];
        }
        this._parameterValues[parameterIndex] =
            weight == 1
                ? value
                : (this._parameterValues[parameterIndex] =
                    this._parameterValues[parameterIndex] * (1 - weight) +
                        value * weight);
    }
    /**
     * 
     * @param parameterId ID
     * @param value 
     * @param weight 
     */
    setParameterValueById(parameterId, value, weight = 1.0) {
        const index = this.getParameterIndex(parameterId);
        this.setParameterValueByIndex(index, value, weight);
    }
    /**
     * (index)
     * @param parameterIndex 
     * @param value 
     * @param weight 
     */
    addParameterValueByIndex(parameterIndex, value, weight = 1.0) {
        this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) + value * weight);
    }
    /**
     * (id)
     * @param parameterId 
     * @param value 
     * @param weight 
     */
    addParameterValueById(parameterId, value, weight = 1.0) {
        const index = this.getParameterIndex(parameterId);
        this.addParameterValueByIndex(index, value, weight);
    }
    /**
     * 
     * @param parameterId ID
     * @param value 
     * @param weight 
     */
    multiplyParameterValueById(parameterId, value, weight = 1.0) {
        const index = this.getParameterIndex(parameterId);
        this.multiplyParameterValueByIndex(index, value, weight);
    }
    /**
     * 
     * @param parameterIndex 
     * @param value 
     * @param weight 
     */
    multiplyParameterValueByIndex(parameterIndex, value, weight = 1.0) {
        this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) *
            (1.0 + (value - 1.0) * weight));
    }
    getDrawableIds() {
        return this._drawableIds.slice();
    }
    /**
     * Drawable
     * @param drawableId DrawableID
     * @return Drawable
     */
    getDrawableIndex(drawableId) {
        const drawableCount = this._model.drawables.count;
        for (let drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {
            if (this._drawableIds[drawableIndex] == drawableId) {
                return drawableIndex;
            }
        }
        return -1;
    }
    /**
     * Drawable
     * @return drawable
     */
    getDrawableCount() {
        return this._model.drawables.count;
    }
    /**
     * DrawableID
     * @param drawableIndex Drawable
     * @return drawableID
     */
    getDrawableId(drawableIndex) {
        return this._model.drawables.ids[drawableIndex];
    }
    /**
     * Drawable
     * @return Drawable
     */
    getDrawableRenderOrders() {
        return this._model.drawables.renderOrders;
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableTextureIndices(drawableIndex) {
        return this._model.drawables.textureIndices[drawableIndex];
    }
    /**
     * DrawableVertexPositions
     *
     * CubismModel.updateDrawable
     *
     * @param   drawableIndex   Drawable
     * @retval  true    DrawableCubismModel.update
     * @retval  false   DrawableCubismModel.update
     */
    getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex) {
        const dynamicFlags = this._model.drawables.dynamicFlags;
        return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableVertexIndexCount(drawableIndex) {
        return this._model.drawables.indexCounts[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableVertexCount(drawableIndex) {
        return this._model.drawables.vertexCounts[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex drawable
     * @return drawable
     */
    getDrawableVertices(drawableIndex) {
        return this.getDrawableVertexPositions(drawableIndex);
    }
    /**
     * Drawable
     * @param drarableIndex Drawable
     * @return drawable
     */
    getDrawableVertexIndices(drawableIndex) {
        return this._model.drawables.indices[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableVertexPositions(drawableIndex) {
        return this._model.drawables.vertexPositions[drawableIndex];
    }
    /**
     * DrawableUV
     * @param drawableIndex Drawable
     * @return drawableUV
     */
    getDrawableVertexUvs(drawableIndex) {
        return this._model.drawables.vertexUvs[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableOpacity(drawableIndex) {
        return this._model.drawables.opacities[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableCulling(drawableIndex) {
        const constantFlags = this._model.drawables.constantFlags;
        return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(constantFlags[drawableIndex]);
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableBlendMode(drawableIndex) {
        const constantFlags = this._model.drawables.constantFlags;
        return Live2DCubismCore.Utils.hasBlendAdditiveBit(constantFlags[drawableIndex])
            ? CubismBlendMode.CubismBlendMode_Additive
            : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(constantFlags[drawableIndex])
                ? CubismBlendMode.CubismBlendMode_Multiplicative
                : CubismBlendMode.CubismBlendMode_Normal;
    }
    /**
     * Drawable
     *
     * Drawable
     * 
     *
     * @param drawableIndex Drawable
     * @return Drawable
     */
    getDrawableInvertedMaskBit(drawableIndex) {
        const constantFlags = this._model.drawables.constantFlags;
        return Live2DCubismCore.Utils.hasIsInvertedMaskBit(constantFlags[drawableIndex]);
    }
    /**
     * Drawable
     * @return Drawable
     */
    getDrawableMasks() {
        return this._model.drawables.masks;
    }
    /**
     * Drawable
     * @return Drawable
     */
    getDrawableMaskCounts() {
        return this._model.drawables.maskCounts;
    }
    /**
     * 
     *
     * @return true 
     * @return false 
     */
    isUsingMasking() {
        for (let d = 0; d < this._model.drawables.count; ++d) {
            if (this._model.drawables.maskCounts[d] <= 0) {
                continue;
            }
            return true;
        }
        return false;
    }
    /**
     * Drawable
     *
     * @param drawableIndex Drawable
     * @return true Drawable
     * @return false Drawable
     */
    getDrawableDynamicFlagIsVisible(drawableIndex) {
        const dynamicFlags = this._model.drawables.dynamicFlags;
        return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);
    }
    /**
     * DrawableDrawOrder
     *
     * CubismModel.updatedrawabledrawOrder
     * drawOrderartMesh01000
     * @param drawableIndex drawable
     * @return true drawableCubismModel.update
     * @return false drawableCubismModel.update
     */
    getDrawableDynamicFlagVisibilityDidChange(drawableIndex) {
        const dynamicFlags = this._model.drawables.dynamicFlags;
        return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawable
     *
     * CubismModel.updatedrawable
     *
     * @param drawableIndex drawable
     * @return true DrawableCubismModel.update
     * @return false DrawableCubismModel.update
     */
    getDrawableDynamicFlagOpacityDidChange(drawableIndex) {
        const dynamicFlags = this._model.drawables.dynamicFlags;
        return Live2DCubismCore.Utils.hasOpacityDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawable
     *
     * CubismModel.updateDrawable
     *
     * @param drawableIndex Drawable
     * @return true DrawableCubismModel.update
     * @return false DrawableCubismModel.update
     */
    getDrawableDynamicFlagRenderOrderDidChange(drawableIndex) {
        const dynamicFlags = this._model.drawables.dynamicFlags;
        return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * 
     */
    loadParameters() {
        let parameterCount = this._model.parameters.count;
        const savedParameterCount = this._savedParameters.length;
        if (parameterCount > savedParameterCount) {
            parameterCount = savedParameterCount;
        }
        for (let i = 0; i < parameterCount; ++i) {
            this._parameterValues[i] = this._savedParameters[i];
        }
    }
    /**
     * 
     */
    initialize() {
        this._parameterValues = this._model.parameters.values;
        this._partOpacities = this._model.parts.opacities;
        this._parameterMaximumValues = this._model.parameters.maximumValues;
        this._parameterMinimumValues = this._model.parameters.minimumValues;
        {
            const parameterIds = this._model.parameters.ids;
            const parameterCount = this._model.parameters.count;
            for (let i = 0; i < parameterCount; ++i) {
                this._parameterIds.push(parameterIds[i]);
            }
        }
        {
            const partIds = this._model.parts.ids;
            const partCount = this._model.parts.count;
            for (let i = 0; i < partCount; ++i) {
                this._partIds.push(partIds[i]);
            }
        }
        {
            const drawableIds = this._model.drawables.ids;
            const drawableCount = this._model.drawables.count;
            for (let i = 0; i < drawableCount; ++i) {
                this._drawableIds.push(drawableIds[i]);
            }
        }
    }
    /**
     * 
     */
    release() {
        this._model.release();
        this._model = undefined;
    }
}

// CONCATENATED MODULE: ./cubism/src/model/cubismmoc.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

/**
 * Moc
 *
 * Moc
 */
class cubismmoc_CubismMoc {
    /**
     * 
     */
    constructor(moc) {
        this._moc = moc;
        this._modelCount = 0;
    }
    /**
     * Moc
     */
    static create(mocBytes) {
        const moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);
        if (moc) {
            return new cubismmoc_CubismMoc(moc);
        }
        throw new Error('Unknown error');
    }
    /**
     * 
     *
     * @return Moc
     */
    createModel() {
        let cubismModel;
        const model = Live2DCubismCore.Model.fromMoc(this._moc);
        if (model) {
            cubismModel = new cubismmodel_CubismModel(model);
            ++this._modelCount;
            return cubismModel;
        }
        throw new Error('Unknown error');
    }
    /**
     * 
     */
    deleteModel(model) {
        if (model != null) {
            --this._modelCount;
        }
    }
    /**
     * 
     */
    release() {
        this._moc._release();
        this._moc = undefined;
    }
}

// CONCATENATED MODULE: ./cubism/src/physics/cubismphysicsinternal.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

/**
 * 
 */
var CubismPhysicsTargetType;
(function (CubismPhysicsTargetType) {
    CubismPhysicsTargetType[CubismPhysicsTargetType["CubismPhysicsTargetType_Parameter"] = 0] = "CubismPhysicsTargetType_Parameter"; // 
})(CubismPhysicsTargetType || (CubismPhysicsTargetType = {}));
/**
 * 
 */
var CubismPhysicsSource;
(function (CubismPhysicsSource) {
    CubismPhysicsSource[CubismPhysicsSource["CubismPhysicsSource_X"] = 0] = "CubismPhysicsSource_X";
    CubismPhysicsSource[CubismPhysicsSource["CubismPhysicsSource_Y"] = 1] = "CubismPhysicsSource_Y";
    CubismPhysicsSource[CubismPhysicsSource["CubismPhysicsSource_Angle"] = 2] = "CubismPhysicsSource_Angle"; // 
})(CubismPhysicsSource || (CubismPhysicsSource = {}));
/**
 * @brief 
 *
 * 
 */
class cubismphysicsinternal_PhysicsJsonEffectiveForces {
    constructor() {
        this.gravity = new CubismVector2(0, 0);
        this.wind = new CubismVector2(0, 0);
    }
}
/**
 * 
 */
class cubismphysicsinternal_CubismPhysicsParticle {
    constructor() {
        this.initialPosition = new CubismVector2(0, 0);
        this.position = new CubismVector2(0, 0);
        this.lastPosition = new CubismVector2(0, 0);
        this.lastGravity = new CubismVector2(0, 0);
        this.force = new CubismVector2(0, 0);
        this.velocity = new CubismVector2(0, 0);
    }
}
/**
 * 
 */
class CubismPhysicsSubRig {
    constructor() {
        this.normalizationPosition = {}; // 
        this.normalizationAngle = {}; // 
    }
}
/**
 * 
 */
class CubismPhysicsInput {
    constructor() {
        this.source = {}; // 
    }
}
/**
 * @brief 
 *
 * 
 */
class cubismphysicsinternal_CubismPhysicsOutput {
    constructor() {
        this.destination = {}; // 
        this.translationScale = new CubismVector2(0, 0); // 
    }
}
/**
 * @brief 
 *
 * 
 */
class cubismphysicsinternal_CubismPhysicsRig {
    constructor() {
        this.settings = [];
        this.inputs = [];
        this.outputs = [];
        this.particles = [];
        this.gravity = new CubismVector2(0, 0);
        this.wind = new CubismVector2(0, 0);
    }
}

// CONCATENATED MODULE: ./cubism/src/physics/cubismphysicsjson.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */

/**
 * physics3.json
 */
class cubismphysicsjson_CubismPhysicsJson {
    /**
     * 
     * @param json physics3.json
     */
    constructor(json) {
        this._json = json;
    }
    /**
     * 
     */
    release() {
        this._json = undefined;
    }
    /**
     * 
     * @return 
     */
    getGravity() {
        const ret = new CubismVector2(0, 0);
        ret.x = this._json.Meta.EffectiveForces.Gravity.X;
        ret.y = this._json.Meta.EffectiveForces.Gravity.Y;
        return ret;
    }
    /**
     * 
     * @return 
     */
    getWind() {
        const ret = new CubismVector2(0, 0);
        ret.x = this._json.Meta.EffectiveForces.Wind.X;
        ret.y = this._json.Meta.EffectiveForces.Wind.Y;
        return ret;
    }
    /**
     * 
     * @return 
     */
    getSubRigCount() {
        return this._json.Meta.PhysicsSettingCount;
    }
    /**
     * 
     * @return 
     */
    getTotalInputCount() {
        return this._json.Meta.TotalInputCount;
    }
    /**
     * 
     * @return 
     */
    getTotalOutputCount() {
        return this._json.Meta.TotalOutputCount;
    }
    /**
     * 
     * @return 
     */
    getVertexCount() {
        return this._json.Meta.VertexCount;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationPositionMinimumValue(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Minimum;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationPositionMaximumValue(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Maximum;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationPositionDefaultValue(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Default;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationAngleMinimumValue(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Minimum;
    }
    /**
     * 
     * @param physicsSettingIndex
     * @return 
     */
    getNormalizationAngleMaximumValue(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Maximum;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationAngleDefaultValue(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Default;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getInputCount(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Input.length;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return 
     */
    getInputWeight(physicsSettingIndex, inputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Weight;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return 
     */
    getInputReflect(physicsSettingIndex, inputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Reflect;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return 
     */
    getInputType(physicsSettingIndex, inputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Type;
    }
    /**
     * ID
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return ID
     */
    getInputSourceId(physicsSettingIndex, inputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Source.Id;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getOutputCount(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Output.length;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputVertexIndex(physicsSettingIndex, outputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].VertexIndex;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputAngleScale(physicsSettingIndex, outputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Scale;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputWeight(physicsSettingIndex, outputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Weight;
    }
    /**
     * ID
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return ID
     */
    getOutputDestinationId(physicsSettingIndex, outputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Destination.Id;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputType(physicsSettingIndex, outputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Type;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputReflect(physicsSettingIndex, outputIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Reflect;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getParticleCount(physicsSettingIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Vertices.length;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleMobility(physicsSettingIndex, vertexIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Mobility;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleDelay(physicsSettingIndex, vertexIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Delay;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleAcceleration(physicsSettingIndex, vertexIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Acceleration;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleRadius(physicsSettingIndex, vertexIndex) {
        return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Radius;
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticlePosition(physicsSettingIndex, vertexIndex) {
        const ret = new CubismVector2(0, 0);
        ret.x = this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Position.X;
        ret.y = this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Position.Y;
        return ret;
    }
}

// CONCATENATED MODULE: ./cubism/src/physics/cubismphysics.ts
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */




// physics types tags.
const PhysicsTypeTagX = 'X';
const PhysicsTypeTagY = 'Y';
const PhysicsTypeTagAngle = 'Angle';
// Constant of air resistance.
const AirResistance = 5.0;
// Constant of maximum weight of input and output ratio.
const MaximumWeight = 100.0;
// Constant of threshold of movement.
const MovementThreshold = 0.001;
/**
 * 
 */
class cubismphysics_CubismPhysics {
    /**
     * 
     */
    constructor() {
        // set default options
        this._options = new cubismphysics_Options();
        this._options.gravity.y = -1.0;
        this._options.gravity.x = 0;
        this._options.wind.x = 0;
        this._options.wind.y = 0;
    }
    /**
     * 
     * @param json    physics3.json
     * @return 
     */
    static create(json) {
        const ret = new cubismphysics_CubismPhysics();
        ret.parse(json);
        ret._physicsRig.gravity.y = 0;
        return ret;
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     */
    evaluate(model, deltaTimeSeconds) {
        let totalAngle;
        let weight;
        let radAngle;
        let outputValue;
        const totalTranslation = new CubismVector2();
        let currentSetting;
        let currentInput;
        let currentOutput;
        let currentParticles;
        let parameterValue;
        let parameterMaximumValue;
        let parameterMinimumValue;
        let parameterDefaultValue;
        parameterValue = model.getModel().parameters.values;
        parameterMaximumValue = model.getModel().parameters.maximumValues;
        parameterMinimumValue = model.getModel().parameters.minimumValues;
        parameterDefaultValue = model.getModel().parameters.defaultValues;
        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
            totalAngle = { angle: 0.0 };
            totalTranslation.x = 0.0;
            totalTranslation.y = 0.0;
            currentSetting = this._physicsRig.settings[settingIndex];
            currentInput = this._physicsRig.inputs.slice(currentSetting.baseInputIndex);
            currentOutput = this._physicsRig.outputs.slice(currentSetting.baseOutputIndex);
            currentParticles = this._physicsRig.particles.slice(currentSetting.baseParticleIndex);
            // Load input parameters
            for (let i = 0; i < currentSetting.inputCount; ++i) {
                weight = currentInput[i].weight / MaximumWeight;
                if (currentInput[i].sourceParameterIndex == -1) {
                    currentInput[i].sourceParameterIndex = model.getParameterIndex(currentInput[i].source.id);
                }
                currentInput[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValue[currentInput[i].sourceParameterIndex], parameterMinimumValue[currentInput[i].sourceParameterIndex], parameterMaximumValue[currentInput[i].sourceParameterIndex], parameterDefaultValue[currentInput[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInput[i].reflect, weight);
            }
            radAngle = cubismmath_CubismMath.degreesToRadian(-totalAngle.angle);
            totalTranslation.x =
                totalTranslation.x * cubismmath_CubismMath.cos(radAngle) -
                    totalTranslation.y * cubismmath_CubismMath.sin(radAngle);
            totalTranslation.y =
                totalTranslation.x * cubismmath_CubismMath.sin(radAngle) +
                    totalTranslation.y * cubismmath_CubismMath.cos(radAngle);
            // Calculate particles position.
            updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, deltaTimeSeconds, AirResistance);
            // Update output parameters.
            for (let i = 0; i < currentSetting.outputCount; ++i) {
                const particleIndex = currentOutput[i].vertexIndex;
                if (particleIndex < 1 ||
                    particleIndex >= currentSetting.particleCount) {
                    break;
                }
                if (currentOutput[i].destinationParameterIndex == -1) {
                    currentOutput[i].destinationParameterIndex = model.getParameterIndex(currentOutput[i].destination.id);
                }
                const translation = new CubismVector2();
                translation.x =
                    currentParticles[particleIndex].position.x -
                        currentParticles[particleIndex - 1].position.x;
                translation.y =
                    currentParticles[particleIndex].position.y -
                        currentParticles[particleIndex - 1].position.y;
                outputValue = currentOutput[i].getValue(translation, currentParticles, particleIndex, currentOutput[i].reflect, this._options.gravity);
                const destinationParameterIndex = currentOutput[i].destinationParameterIndex;
                const outParameterValue = !Float32Array.prototype.slice &&
                    'subarray' in Float32Array.prototype
                    ? JSON.parse(JSON.stringify(parameterValue.subarray(destinationParameterIndex))) // JSON.parse, JSON.stringify
                    : parameterValue.slice(destinationParameterIndex);
                updateOutputParameterValue(outParameterValue, parameterMinimumValue[destinationParameterIndex], parameterMaximumValue[destinationParameterIndex], outputValue, currentOutput[i]);
                // 
                for (let offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValue.length; offset++, outParamIndex++) {
                    parameterValue[offset] = outParameterValue[outParamIndex];
                }
            }
        }
    }
    /**
     * 
     * @param options 
     */
    setOptions(options) {
        this._options = options;
    }
    /**
     * 
     * @return 
     */
    getOption() {
        return this._options;
    }
    /**
     * 
     */
    release() {
        this._physicsRig = undefined;
    }
    /**
     * physics3.json
     * @param physicsJson physics3.json
     */
    parse(physicsJson) {
        this._physicsRig = new cubismphysicsinternal_CubismPhysicsRig();
        let json = new cubismphysicsjson_CubismPhysicsJson(physicsJson);
        this._physicsRig.gravity = json.getGravity();
        this._physicsRig.wind = json.getWind();
        this._physicsRig.subRigCount = json.getSubRigCount();
        let inputIndex = 0, outputIndex = 0, particleIndex = 0;
        for (let i = 0; i < this._physicsRig.subRigCount; ++i) {
            const setting = new CubismPhysicsSubRig();
            setting.normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i);
            setting.normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i);
            setting.normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i);
            setting.normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i);
            setting.normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i);
            setting.normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i);
            // Input
            setting.inputCount = json.getInputCount(i);
            setting.baseInputIndex = inputIndex;
            inputIndex += setting.inputCount;
            for (let j = 0; j < setting.inputCount; ++j) {
                const input = new CubismPhysicsInput();
                input.sourceParameterIndex = -1;
                input.weight = json.getInputWeight(i, j);
                input.reflect = json.getInputReflect(i, j);
                switch (json.getInputType(i, j)) {
                    case PhysicsTypeTagX:
                        input.type = CubismPhysicsSource.CubismPhysicsSource_X;
                        input.getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;
                        break;
                    case PhysicsTypeTagY:
                        input.type = CubismPhysicsSource.CubismPhysicsSource_Y;
                        input.getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;
                        break;
                    case PhysicsTypeTagAngle:
                        input.type = CubismPhysicsSource.CubismPhysicsSource_Angle;
                        input.getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;
                        break;
                }
                input.source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
                input.source.id = json.getInputSourceId(i, j);
                this._physicsRig.inputs.push(input);
            }
            // Output
            setting.outputCount = json.getOutputCount(i);
            setting.baseOutputIndex = outputIndex;
            outputIndex += setting.outputCount;
            for (let j = 0; j < setting.outputCount; ++j) {
                const output = new cubismphysicsinternal_CubismPhysicsOutput();
                output.destinationParameterIndex = -1;
                output.vertexIndex = json.getOutputVertexIndex(i, j);
                output.angleScale = json.getOutputAngleScale(i, j);
                output.weight = json.getOutputWeight(i, j);
                output.destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
                output.destination.id = json.getOutputDestinationId(i, j);
                switch (json.getOutputType(i, j)) {
                    case PhysicsTypeTagX:
                        output.type = CubismPhysicsSource.CubismPhysicsSource_X;
                        output.getValue = getOutputTranslationX;
                        output.getScale = getOutputScaleTranslationX;
                        break;
                    case PhysicsTypeTagY:
                        output.type = CubismPhysicsSource.CubismPhysicsSource_Y;
                        output.getValue = getOutputTranslationY;
                        output.getScale = getOutputScaleTranslationY;
                        break;
                    case PhysicsTypeTagAngle:
                        output.type = CubismPhysicsSource.CubismPhysicsSource_Angle;
                        output.getValue = getOutputAngle;
                        output.getScale = getOutputScaleAngle;
                        break;
                }
                output.reflect = json.getOutputReflect(i, j);
                this._physicsRig.outputs.push(output);
            }
            // Particle
            setting.particleCount = json.getParticleCount(i);
            setting.baseParticleIndex = particleIndex;
            particleIndex += setting.particleCount;
            for (let j = 0; j < setting.particleCount; ++j) {
                const particle = new cubismphysicsinternal_CubismPhysicsParticle();
                particle.mobility = json.getParticleMobility(i, j);
                particle.delay = json.getParticleDelay(i, j);
                particle.acceleration = json.getParticleAcceleration(i, j);
                particle.radius = json.getParticleRadius(i, j);
                particle.position = json.getParticlePosition(i, j);
                this._physicsRig.particles.push(particle);
            }
            this._physicsRig.settings.push(setting);
        }
        this.initialize();
        json.release();
    }
    /**
     * 
     */
    initialize() {
        let strand;
        let currentSetting;
        let radius;
        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
            currentSetting = this._physicsRig.settings[settingIndex];
            strand = this._physicsRig.particles.slice(currentSetting.baseParticleIndex);
            // Initialize the top of particle.
            strand[0].initialPosition = new CubismVector2(0.0, 0.0);
            strand[0].lastPosition = new CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);
            strand[0].lastGravity = new CubismVector2(0.0, -1.0);
            strand[0].lastGravity.y *= -1.0;
            strand[0].velocity = new CubismVector2(0.0, 0.0);
            strand[0].force = new CubismVector2(0.0, 0.0);
            // Initialize paritcles.
            for (let i = 1; i < currentSetting.particleCount; ++i) {
                radius = new CubismVector2(0.0, 0.0);
                radius.y = strand[i].radius;
                strand[i].initialPosition = new CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);
                strand[i].position = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);
                strand[i].lastPosition = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);
                strand[i].lastGravity = new CubismVector2(0.0, -1.0);
                strand[i].lastGravity.y *= -1.0;
                strand[i].velocity = new CubismVector2(0.0, 0.0);
                strand[i].force = new CubismVector2(0.0, 0.0);
            }
        }
    }
}
/**
 * 
 */
class cubismphysics_Options {
    constructor() {
        this.gravity = new CubismVector2(0, 0);
        this.wind = new CubismVector2(0, 0);
    }
}
function getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
    targetTranslation.x +=
        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;
}
function getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
    targetTranslation.y +=
        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;
}
function getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {
    targetAngle.angle +=
        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;
}
function getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue = translation.x;
    if (isInverted) {
        outputValue *= -1.0;
    }
    return outputValue;
}
function getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue = translation.y;
    if (isInverted) {
        outputValue *= -1.0;
    }
    return outputValue;
}
function getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue;
    if (particleIndex >= 2) {
        parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);
    }
    else {
        parentGravity = parentGravity.multiplyByScaler(-1.0);
    }
    outputValue = cubismmath_CubismMath.directionToRadian(parentGravity, translation);
    if (isInverted) {
        outputValue *= -1.0;
    }
    return outputValue;
}
function getRangeValue(min, max) {
    return Math.abs(Math.max(min, max) - Math.min(min, max));
}
function getDefaultValue(min, max) {
    const minValue = Math.min(min, max);
    return minValue + getRangeValue(min, max) / 2.0;
}
function getOutputScaleTranslationX(translationScale, angleScale) {
    return translationScale.x;
}
function getOutputScaleTranslationY(translationScale, angleScale) {
    return translationScale.y;
}
function getOutputScaleAngle(translationScale, angleScale) {
    return angleScale;
}
/**
 * Updates particles.
 *
 * @param strand                Target array of particle.
 * @param strandCount           Count of particle.
 * @param totalTranslation      Total translation value.
 * @param totalAngle            Total angle.
 * @param windDirection         Direction of Wind.
 * @param thresholdValue        Threshold of movement.
 * @param deltaTimeSeconds      Delta time.
 * @param airResistance         Air resistance.
 */
function updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {
    let totalRadian;
    let delay;
    let radian;
    let currentGravity;
    let direction = new CubismVector2(0.0, 0.0);
    let velocity = new CubismVector2(0.0, 0.0);
    let force = new CubismVector2(0.0, 0.0);
    let newDirection = new CubismVector2(0.0, 0.0);
    strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);
    totalRadian = cubismmath_CubismMath.degreesToRadian(totalAngle);
    currentGravity = cubismmath_CubismMath.radianToDirection(totalRadian);
    currentGravity.normalize();
    for (let i = 1; i < strandCount; ++i) {
        strand[i].force = currentGravity
            .multiplyByScaler(strand[i].acceleration)
            .add(windDirection);
        strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);
        delay = strand[i].delay * deltaTimeSeconds * 30.0;
        direction = strand[i].position.substract(strand[i - 1].position);
        radian =
            cubismmath_CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) /
                airResistance;
        direction.x =
            cubismmath_CubismMath.cos(radian) * direction.x -
                direction.y * cubismmath_CubismMath.sin(radian);
        direction.y =
            cubismmath_CubismMath.sin(radian) * direction.x +
                direction.y * cubismmath_CubismMath.cos(radian);
        strand[i].position = strand[i - 1].position.add(direction);
        velocity = strand[i].velocity.multiplyByScaler(delay);
        force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);
        strand[i].position = strand[i].position.add(velocity).add(force);
        newDirection = strand[i].position.substract(strand[i - 1].position);
        newDirection.normalize();
        strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));
        if (cubismmath_CubismMath.abs(strand[i].position.x) < thresholdValue) {
            strand[i].position.x = 0.0;
        }
        if (delay != 0.0) {
            strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);
            strand[i].velocity = strand[i].velocity.divisionByScalar(delay);
            strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);
        }
        strand[i].force = new CubismVector2(0.0, 0.0);
        strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);
    }
}
/**
 * Updates output parameter value.
 * @param parameterValue            Target parameter value.
 * @param parameterValueMinimum     Minimum of parameter value.
 * @param parameterValueMaximum     Maximum of parameter value.
 * @param translation               Translation value.
 */
function updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {
    let outputScale;
    let value;
    let weight;
    outputScale = output.getScale(output.translationScale, output.angleScale);
    value = translation * outputScale;
    if (value < parameterValueMinimum) {
        if (value < output.valueBelowMinimum) {
            output.valueBelowMinimum = value;
        }
        value = parameterValueMinimum;
    }
    else if (value > parameterValueMaximum) {
        if (value > output.valueExceededMaximum) {
            output.valueExceededMaximum = value;
        }
        value = parameterValueMaximum;
    }
    weight = output.weight / MaximumWeight;
    if (weight >= 1.0) {
        parameterValue[0] = value;
    }
    else {
        value = parameterValue[0] * (1.0 - weight) + value * weight;
        parameterValue[0] = value;
    }
}
function normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {
    let result = 0.0;
    const maxValue = cubismmath_CubismMath.max(parameterMaximum, parameterMinimum);
    if (maxValue < value) {
        value = maxValue;
    }
    const minValue = cubismmath_CubismMath.min(parameterMaximum, parameterMinimum);
    if (minValue > value) {
        value = minValue;
    }
    const minNormValue = cubismmath_CubismMath.min(normalizedMinimum, normalizedMaximum);
    const maxNormValue = cubismmath_CubismMath.max(normalizedMinimum, normalizedMaximum);
    const middleNormValue = normalizedDefault;
    const middleValue = getDefaultValue(minValue, maxValue);
    const paramValue = value - middleValue;
    switch (Math.sign(paramValue)) {
        case 1: {
            const nLength = maxNormValue - middleNormValue;
            const pLength = maxValue - middleValue;
            if (pLength != 0.0) {
                result = paramValue * (nLength / pLength);
                result += middleNormValue;
            }
            break;
        }
        case -1: {
            const nLength = minNormValue - middleNormValue;
            const pLength = minValue - middleValue;
            if (pLength != 0.0) {
                result = paramValue * (nLength / pLength);
                result += middleNormValue;
            }
            break;
        }
        case 0: {
            result = middleNormValue;
            break;
        }
        default: {
            break;
        }
    }
    return isInverted ? result : result * -1.0;
}

// CONCATENATED MODULE: ./src/cubism4/factory.ts









config["b" /* config */].cubism4 = config_config;
Live2DFactory["a" /* Live2DFactory */].registerRuntime({
    version: 4,
    ready: cubism4Ready,
    test(source) {
        return source instanceof Cubism4ModelSettings_Cubism4ModelSettings || Cubism4ModelSettings_Cubism4ModelSettings.isValidJSON(source);
    },
    isValidMoc(modelData) {
        if (modelData.byteLength < 4) {
            return false;
        }
        const view = new Int8Array(modelData, 0, 4);
        return String.fromCharCode(...view) === 'MOC3';
    },
    createModelSettings(json) {
        return new Cubism4ModelSettings_Cubism4ModelSettings(json);
    },
    createCoreModel(data) {
        const moc = cubismmoc_CubismMoc.create(data);
        try {
            const model = moc.createModel();
            // store the moc instance so we can reference it later
            model.__moc = moc;
            return model;
        }
        catch (e) {
            try {
                moc.release();
            }
            catch (ignored) {
            }
            throw e;
        }
    },
    createInternalModel(coreModel, settings, options) {
        const model = new Cubism4InternalModel_Cubism4InternalModel(coreModel, settings, options);
        const coreModelWithMoc = coreModel;
        if (coreModelWithMoc.__moc) {
            // transfer the moc to InternalModel, because the coreModel will
            // probably have been set to undefined when we receive the "destroy" event
            model.__moc = coreModelWithMoc.__moc;
            delete coreModelWithMoc.__moc;
            // release the moc when destroying
            model.once('destroy', releaseMoc);
        }
        return model;
    },
    createPhysics(coreModel, data) {
        return cubismphysics_CubismPhysics.create(data);
    },
    createPose(coreModel, data) {
        return CubismPose.create(data);
    },
});
function releaseMoc() {
    var _a;
    (_a = this.__moc) === null || _a === void 0 ? void 0 : _a.release();
}

// CONCATENATED MODULE: ./src/cubism4/index.ts









/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ Cubism2ExpressionManager_Cubism2ExpressionManager; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ Cubism2InternalModel_Cubism2InternalModel; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ Cubism2ModelSettings_Cubism2ModelSettings; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ Cubism2MotionManager_Cubism2MotionManager; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ Live2DExpression_Live2DExpression; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ Live2DEyeBlink_Live2DEyeBlink; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ Live2DPhysics; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ Live2DPose_Live2DPose; });

// EXTERNAL MODULE: ./src/cubism2/check-runtime.ts
var check_runtime = __webpack_require__(25);

// EXTERNAL MODULE: ./src/cubism2/patch-motion.ts
var patch_motion = __webpack_require__(21);

// EXTERNAL MODULE: ./src/cubism-common/ExpressionManager.ts
var ExpressionManager = __webpack_require__(10);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(1);

// CONCATENATED MODULE: ./src/cubism2/Live2DExpression.ts

class Live2DExpression_Live2DExpression extends AMotion {
    constructor(json) {
        super();
        this.params = [];
        this.setFadeIn(json.fade_in > 0 ? json.fade_in : config["b" /* config */].expressionFadingDuration);
        this.setFadeOut(json.fade_out > 0 ? json.fade_out : config["b" /* config */].expressionFadingDuration);
        if (Array.isArray(json.params)) {
            json.params.forEach(param => {
                const calc = param.calc || 'add';
                if (calc === 'add') {
                    const defaultValue = param.def || 0;
                    param.val -= defaultValue;
                }
                else if (calc === 'mult') {
                    const defaultValue = param.def || 1;
                    param.val /= defaultValue;
                }
                this.params.push({
                    calc,
                    val: param.val,
                    id: param.id,
                });
            });
        }
    }
    /** @override */
    updateParamExe(model, time, weight, motionQueueEnt) {
        this.params.forEach(param => {
            // this algorithm seems to be broken for newer Neptunia series models, have no idea
            //
            // switch (param.type) {
            //     case ParamCalcType.Set:
            //         model.setParamFloat(param.id, param.value, weight);
            //         break;
            //     case ParamCalcType.Add:
            //         model.addToParamFloat(param.id, param.value * weight);
            //         break;
            //     case ParamCalcType.Mult:
            //         model.multParamFloat(param.id, param.value, weight);
            //         break;
            // }
            // this works fine for any model
            model.setParamFloat(param.id, param.val * weight);
        });
    }
}

// CONCATENATED MODULE: ./src/cubism2/Cubism2ExpressionManager.ts


class Cubism2ExpressionManager_Cubism2ExpressionManager extends ExpressionManager["a" /* ExpressionManager */] {
    constructor(settings, options) {
        var _a;
        super(settings, options);
        this.queueManager = new MotionQueueManager();
        this.definitions = (_a = this.settings.expressions) !== null && _a !== void 0 ? _a : [];
        this.init();
    }
    isFinished() {
        return this.queueManager.isFinished();
    }
    getExpressionIndex(name) {
        return this.definitions.findIndex(def => def.name === name);
    }
    getExpressionFile(definition) {
        return definition.file;
    }
    createExpression(data, definition) {
        return new Live2DExpression_Live2DExpression(data);
    }
    _setExpression(motion) {
        return this.queueManager.startMotion(motion);
    }
    stopAllExpressions() {
        this.queueManager.stopAllMotions();
    }
    updateParameters(model, dt) {
        return this.queueManager.updateParam(model);
    }
}

// EXTERNAL MODULE: ./src/cubism-common/InternalModel.ts
var InternalModel = __webpack_require__(13);

// EXTERNAL MODULE: ./src/cubism-common/MotionManager.ts
var MotionManager = __webpack_require__(12);

// CONCATENATED MODULE: ./src/cubism2/Cubism2MotionManager.ts




class Cubism2MotionManager_Cubism2MotionManager extends MotionManager["a" /* MotionManager */] {
    constructor(settings, options) {
        super(settings, options);
        this.groups = { idle: 'idle' };
        this.motionDataType = 'arraybuffer';
        this.queueManager = new MotionQueueManager();
        this.definitions = this.settings.motions;
        this.init(options);
    }
    init(options) {
        super.init(options);
        if (this.settings.expressions) {
            this.expressionManager = new Cubism2ExpressionManager_Cubism2ExpressionManager(this.settings, options);
        }
    }
    isFinished() {
        return this.queueManager.isFinished();
    }
    createMotion(data, group, definition) {
        const motion = Live2DMotion.loadMotion(data);
        const defaultFadingDuration = group === this.groups.idle
            ? config["b" /* config */].idleMotionFadingDuration
            : config["b" /* config */].motionFadingDuration;
        motion.setFadeIn(definition.fade_in > 0 ? definition.fade_in : defaultFadingDuration);
        motion.setFadeOut(definition.fade_out > 0 ? definition.fade_out : defaultFadingDuration);
        return motion;
    }
    getMotionFile(definition) {
        return definition.file;
    }
    getMotionName(definition) {
        return definition.file;
    }
    getSoundFile(definition) {
        return definition.sound;
    }
    _startMotion(motion, onFinish) {
        motion.onFinishHandler = onFinish;
        this.queueManager.stopAllMotions();
        return this.queueManager.startMotion(motion);
    }
    _stopAllMotions() {
        this.queueManager.stopAllMotions();
    }
    updateParameters(model, now) {
        return this.queueManager.updateParam(model);
    }
    destroy() {
        super.destroy();
        this.queueManager = undefined;
    }
}

// EXTERNAL MODULE: ./src/utils/index.ts + 4 modules
var utils = __webpack_require__(0);

// CONCATENATED MODULE: ./src/cubism2/Live2DEyeBlink.ts

var EyeState;
(function (EyeState) {
    EyeState[EyeState["Idle"] = 0] = "Idle";
    EyeState[EyeState["Closing"] = 1] = "Closing";
    EyeState[EyeState["Closed"] = 2] = "Closed";
    EyeState[EyeState["Opening"] = 3] = "Opening";
})(EyeState || (EyeState = {}));
class Live2DEyeBlink_Live2DEyeBlink {
    constructor(coreModel) {
        this.coreModel = coreModel;
        this.blinkInterval = 4000;
        this.closingDuration = 100;
        this.closedDuration = 50;
        this.openingDuration = 150;
        this.eyeState = EyeState.Idle;
        this.eyeParamValue = 1;
        this.closedTimer = 0;
        this.nextBlinkTimeLeft = this.blinkInterval;
        this.leftParam = coreModel.getParamIndex('PARAM_EYE_L_OPEN');
        this.rightParam = coreModel.getParamIndex('PARAM_EYE_R_OPEN');
    }
    setEyeParams(value) {
        this.eyeParamValue = Object(utils["b" /* clamp */])(value, 0, 1);
        this.coreModel.setParamFloat(this.leftParam, this.eyeParamValue);
        this.coreModel.setParamFloat(this.rightParam, this.eyeParamValue);
    }
    update(dt) {
        switch (this.eyeState) {
            case EyeState.Idle:
                this.nextBlinkTimeLeft -= dt;
                if (this.nextBlinkTimeLeft < 0) {
                    this.eyeState = EyeState.Closing;
                    this.nextBlinkTimeLeft =
                        this.blinkInterval +
                            this.closingDuration +
                            this.closedDuration +
                            this.openingDuration +
                            Object(utils["g" /* rand */])(0, 2000);
                }
                break;
            case EyeState.Closing:
                this.setEyeParams(this.eyeParamValue + dt / this.closingDuration);
                if (this.eyeParamValue <= 0) {
                    this.eyeState = EyeState.Closed;
                    this.closedTimer = 0;
                }
                break;
            case EyeState.Closed:
                this.closedTimer += dt;
                if (this.closedTimer >= this.closedDuration) {
                    this.eyeState = EyeState.Opening;
                }
                break;
            case EyeState.Opening:
                this.setEyeParams(this.eyeParamValue + dt / this.openingDuration);
                if (this.eyeParamValue >= 1) {
                    this.eyeState = EyeState.Idle;
                }
        }
    }
}

// CONCATENATED MODULE: ./src/cubism2/Cubism2InternalModel.ts



// prettier-ignore
const tempMatrixArray = new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1,
]);
class Cubism2InternalModel_Cubism2InternalModel extends InternalModel["a" /* InternalModel */] {
    constructor(coreModel, settings, options) {
        super();
        this.textureFlipY = true;
        /**
         * Number of the drawables in this model.
         */
        this.drawDataCount = 0;
        /**
         * If true, the face culling will always be disabled when drawing the model,
         * regardless of the model's internal flags.
         */
        this.disableCulling = false;
        this.coreModel = coreModel;
        this.settings = settings;
        this.motionManager = new Cubism2MotionManager_Cubism2MotionManager(settings, options);
        this.eyeBlink = new Live2DEyeBlink_Live2DEyeBlink(coreModel);
        this.eyeballXParamIndex = coreModel.getParamIndex('PARAM_EYE_BALL_X');
        this.eyeballYParamIndex = coreModel.getParamIndex('PARAM_EYE_BALL_Y');
        this.angleXParamIndex = coreModel.getParamIndex('PARAM_ANGLE_X');
        this.angleYParamIndex = coreModel.getParamIndex('PARAM_ANGLE_Y');
        this.angleZParamIndex = coreModel.getParamIndex('PARAM_ANGLE_Z');
        this.bodyAngleXParamIndex = coreModel.getParamIndex('PARAM_BODY_ANGLE_X');
        this.breathParamIndex = coreModel.getParamIndex('PARAM_BREATH');
        this.init();
    }
    init() {
        super.init();
        if (this.settings.initParams) {
            this.settings.initParams.forEach(({ id, value }) => this.coreModel.setParamFloat(id, value));
        }
        if (this.settings.initOpacities) {
            this.settings.initOpacities.forEach(({ id, value }) => this.coreModel.setPartsOpacity(id, value));
        }
        this.coreModel.saveParam();
        const arr = this.coreModel.getModelContext()._$aS;
        if (arr === null || arr === void 0 ? void 0 : arr.length) {
            this.drawDataCount = arr.length;
        }
        let culling = this.coreModel.drawParamWebGL.culling;
        Object.defineProperty(this.coreModel.drawParamWebGL, 'culling', {
            set: (v) => culling = v,
            // always return false when disabled
            get: () => this.disableCulling ? false : culling,
        });
        const clipManager = this.coreModel.getModelContext().clipManager;
        const originalSetupClip = clipManager.setupClip;
        // after setupClip(), the GL viewport will be set to [0, 0, canvas.width, canvas.height],
        // so we have to set it back
        clipManager.setupClip = (modelContext, drawParam) => {
            originalSetupClip.call(clipManager, modelContext, drawParam);
            drawParam.gl.viewport(...this.viewport);
        };
    }
    getSize() {
        return [this.coreModel.getCanvasWidth(), this.coreModel.getCanvasHeight()];
    }
    getLayout() {
        const layout = this.settings.layout || {};
        return Object.assign(Object.assign({}, layout), { centerX: layout.center_x, centerY: layout.center_y });
    }
    updateWebGLContext(gl, glContextID) {
        const drawParamWebGL = this.coreModel.drawParamWebGL;
        drawParamWebGL.firstDraw = true;
        drawParamWebGL.setGL(gl);
        drawParamWebGL.glno = glContextID;
        // reset WebGL buffers
        for (const prop in drawParamWebGL) {
            if (drawParamWebGL.hasOwnProperty(prop) && drawParamWebGL[prop] instanceof WebGLBuffer) {
                drawParamWebGL[prop] = null;
            }
        }
        const clipManager = this.coreModel.getModelContext().clipManager;
        clipManager.curFrameNo = glContextID;
        const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        // force Live2D to re-create the framebuffer
        clipManager.getMaskRenderTexture();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    }
    bindTexture(index, texture) {
        this.coreModel.setTexture(index, texture);
    }
    getHitAreaDefs() {
        var _a;
        return ((_a = this.settings.hitAreas) === null || _a === void 0 ? void 0 : _a.map(hitArea => ({
            id: hitArea.id,
            name: hitArea.name,
            index: this.coreModel.getDrawDataIndex(hitArea.id),
        }))) || [];
    }
    getDrawableIDs() {
        const modelContext = this.coreModel.getModelContext();
        const ids = [];
        for (let i = 0; i < this.drawDataCount; i++) {
            const drawData = modelContext.getDrawData(i);
            if (drawData) {
                ids.push(drawData.getDrawDataID().id);
            }
        }
        return ids;
    }
    getDrawableIndex(id) {
        return this.coreModel.getDrawDataIndex(id);
    }
    getDrawableVertices(drawIndex) {
        if (typeof drawIndex === 'string') {
            drawIndex = this.coreModel.getDrawDataIndex(drawIndex);
            if (drawIndex === -1)
                throw new TypeError('Unable to find drawable ID: ' + drawIndex);
        }
        return this.coreModel.getTransformedPoints(drawIndex).slice();
    }
    update(dt, now) {
        var _a, _b, _c;
        super.update(dt, now);
        const model = this.coreModel;
        this.emit('beforeMotionUpdate');
        const motionUpdated = this.motionManager.update(this.coreModel, now);
        this.emit('afterMotionUpdate');
        model.saveParam();
        if (!motionUpdated) {
            (_a = this.eyeBlink) === null || _a === void 0 ? void 0 : _a.update(dt);
        }
        this.updateFocus();
        this.updateNaturalMovements(dt, now);
        (_b = this.physics) === null || _b === void 0 ? void 0 : _b.update(now);
        (_c = this.pose) === null || _c === void 0 ? void 0 : _c.update(dt);
        this.emit('beforeModelUpdate');
        model.update();
        model.loadParam();
    }
    updateFocus() {
        this.coreModel.addToParamFloat(this.eyeballXParamIndex, this.focusController.x);
        this.coreModel.addToParamFloat(this.eyeballYParamIndex, this.focusController.y);
        this.coreModel.addToParamFloat(this.angleXParamIndex, this.focusController.x * 30);
        this.coreModel.addToParamFloat(this.angleYParamIndex, this.focusController.y * 30);
        this.coreModel.addToParamFloat(this.angleZParamIndex, this.focusController.x * this.focusController.y * -30);
        this.coreModel.addToParamFloat(this.bodyAngleXParamIndex, this.focusController.x * 10);
    }
    updateNaturalMovements(dt, now) {
        const t = (now / 1000) * 2 * Math.PI;
        this.coreModel.addToParamFloat(this.angleXParamIndex, 15 * Math.sin(t / 6.5345) * 0.5);
        this.coreModel.addToParamFloat(this.angleYParamIndex, 8 * Math.sin(t / 3.5345) * 0.5);
        this.coreModel.addToParamFloat(this.angleZParamIndex, 10 * Math.sin(t / 5.5345) * 0.5);
        this.coreModel.addToParamFloat(this.bodyAngleXParamIndex, 4 * Math.sin(t / 15.5345) * 0.5);
        this.coreModel.setParamFloat(this.breathParamIndex, 0.5 + 0.5 * Math.sin(t / 3.2345));
    }
    draw(gl) {
        const disableCulling = this.disableCulling;
        // culling must be disabled to get this cubism2 model drawn properly on a framebuffer
        if (gl.getParameter(gl.FRAMEBUFFER_BINDING)) {
            this.disableCulling = true;
        }
        const matrix = this.drawingMatrix;
        // set given 3x3 matrix into a 4x4 matrix
        tempMatrixArray[0] = matrix.a;
        tempMatrixArray[1] = matrix.b;
        tempMatrixArray[4] = matrix.c;
        tempMatrixArray[5] = matrix.d;
        tempMatrixArray[12] = matrix.tx;
        tempMatrixArray[13] = matrix.ty;
        this.coreModel.setMatrix(tempMatrixArray);
        this.coreModel.draw();
        this.disableCulling = disableCulling;
    }
    destroy() {
        super.destroy();
        // cubism2 core has a super dumb memory management so there's basically nothing much to do to release the model
        this.coreModel = undefined;
    }
}

// EXTERNAL MODULE: ./src/cubism-common/ModelSettings.ts
var ModelSettings = __webpack_require__(11);

// CONCATENATED MODULE: ./src/cubism2/Cubism2ModelSettings.ts


class Cubism2ModelSettings_Cubism2ModelSettings extends ModelSettings["a" /* ModelSettings */] {
    constructor(json) {
        super(json);
        this.motions = {};
        if (!Cubism2ModelSettings_Cubism2ModelSettings.isValidJSON(json)) {
            throw new TypeError('Invalid JSON.');
        }
        this.moc = json.model;
        // copy textures array
        Object(utils["c" /* copyArray */])('string', json, this, 'textures', 'textures');
        this.copy(json);
    }
    /**
     * Checks if a JSON object is valid model settings.
     * @param json
     */
    static isValidJSON(json) {
        var _a;
        // should always return a boolean
        return !!json
            && typeof json.model === 'string'
            && ((_a = json.textures) === null || _a === void 0 ? void 0 : _a.length) > 0
            // textures must be an array of strings
            && json.textures.every((item) => typeof item === 'string');
    }
    /**
     * Validates and copies *optional* properties from raw JSON.
     */
    copy(json) {
        Object(utils["d" /* copyProperty */])('string', json, this, 'name', 'name');
        Object(utils["d" /* copyProperty */])('string', json, this, 'pose', 'pose');
        Object(utils["d" /* copyProperty */])('string', json, this, 'physics', 'physics');
        Object(utils["d" /* copyProperty */])('object', json, this, 'layout', 'layout');
        Object(utils["d" /* copyProperty */])('object', json, this, 'motions', 'motions');
        Object(utils["c" /* copyArray */])('object', json, this, 'hit_areas', 'hitAreas');
        Object(utils["c" /* copyArray */])('object', json, this, 'expressions', 'expressions');
        Object(utils["c" /* copyArray */])('object', json, this, 'init_params', 'initParams');
        Object(utils["c" /* copyArray */])('object', json, this, 'init_opacities', 'initOpacities');
    }
    replaceFiles(replace) {
        super.replaceFiles(replace);
        for (const [group, motions] of Object.entries(this.motions)) {
            for (let i = 0; i < motions.length; i++) {
                motions[i].file = replace(motions[i].file, `motions.${group}[${i}].file`);
                if (motions[i].sound !== undefined) {
                    motions[i].sound = replace(motions[i].sound, `motions.${group}[${i}].sound`);
                }
            }
        }
        if (this.expressions) {
            for (let i = 0; i < this.expressions.length; i++) {
                this.expressions[i].file = replace(this.expressions[i].file, `expressions[${i}].file`);
            }
        }
    }
}

// CONCATENATED MODULE: ./src/cubism2/Live2DPhysics.ts
const SRC_TYPE_MAP = {
    x: PhysicsHair.Src.SRC_TO_X,
    y: PhysicsHair.Src.SRC_TO_Y,
    angle: PhysicsHair.Src.SRC_TO_G_ANGLE,
};
const TARGET_TYPE_MAP = {
    x: PhysicsHair.Src.SRC_TO_X,
    y: PhysicsHair.Src.SRC_TO_Y,
    angle: PhysicsHair.Src.SRC_TO_G_ANGLE,
};
class Live2DPhysics {
    constructor(coreModel, json) {
        this.coreModel = coreModel;
        this.physicsHairs = [];
        if (json.physics_hair) {
            this.physicsHairs = json.physics_hair.map(definition => {
                const physicsHair = new PhysicsHair();
                physicsHair.setup(definition.setup.length, definition.setup.regist, definition.setup.mass);
                definition.src.forEach(({ id, ptype, scale, weight }) => {
                    const type = SRC_TYPE_MAP[ptype];
                    if (type) {
                        physicsHair.addSrcParam(type, id, scale, weight);
                    }
                });
                definition.targets.forEach(({ id, ptype, scale, weight }) => {
                    const type = TARGET_TYPE_MAP[ptype];
                    if (type) {
                        physicsHair.addTargetParam(type, id, scale, weight);
                    }
                });
                return physicsHair;
            });
        }
    }
    update(elapsed) {
        this.physicsHairs.forEach(physicsHair => physicsHair.update(this.coreModel, elapsed));
    }
}

// CONCATENATED MODULE: ./src/cubism2/Live2DPose.ts

class Live2DPartsParam {
    constructor(id) {
        this.id = id;
        this.paramIndex = -1;
        this.partsIndex = -1;
        this.link = [];
    }
    initIndex(model) {
        this.paramIndex = model.getParamIndex('VISIBLE:' + this.id);
        this.partsIndex = model.getPartsDataIndex(PartsDataID.getID(this.id));
        model.setParamFloat(this.paramIndex, 1);
    }
}
class Live2DPose_Live2DPose {
    constructor(coreModel, json) {
        this.coreModel = coreModel;
        this.opacityAnimDuration = 500;
        this.partsGroups = [];
        if (json.parts_visible) {
            this.partsGroups = json.parts_visible.map(({ group }) => group.map(({ id, link }) => {
                const parts = new Live2DPartsParam(id);
                if (link) {
                    parts.link = link.map(l => new Live2DPartsParam(l));
                }
                return parts;
            }));
            this.init();
        }
    }
    init() {
        this.partsGroups.forEach(group => {
            group.forEach(parts => {
                parts.initIndex(this.coreModel);
                if (parts.paramIndex >= 0) {
                    const visible = this.coreModel.getParamFloat(parts.paramIndex) !== 0;
                    this.coreModel.setPartsOpacity(parts.partsIndex, visible ? 1 : 0);
                    this.coreModel.setParamFloat(parts.paramIndex, visible ? 1 : 0);
                    if (parts.link.length > 0) {
                        parts.link.forEach(p => p.initIndex(this.coreModel));
                    }
                }
            });
        });
    }
    normalizePartsOpacityGroup(partsGroup, dt) {
        const model = this.coreModel;
        const phi = 0.5;
        const maxBackOpacity = 0.15;
        let visibleOpacity = 1;
        let visibleIndex = partsGroup.findIndex(({ paramIndex, partsIndex }) => partsIndex >= 0 && model.getParamFloat(paramIndex) !== 0);
        if (visibleIndex >= 0) {
            const originalOpacity = model.getPartsOpacity(partsGroup[visibleIndex].partsIndex);
            visibleOpacity = Object(utils["b" /* clamp */])(originalOpacity + dt / this.opacityAnimDuration, 0, 1);
        }
        else {
            visibleIndex = 0;
            visibleOpacity = 1;
        }
        partsGroup.forEach(({ partsIndex }, index) => {
            if (partsIndex >= 0) {
                if (visibleIndex == index) {
                    model.setPartsOpacity(partsIndex, visibleOpacity);
                }
                else {
                    let opacity = model.getPartsOpacity(partsIndex);
                    // I can't understand this part, so just leave it original
                    let a1;
                    if (visibleOpacity < phi) {
                        a1 = (visibleOpacity * (phi - 1)) / phi + 1;
                    }
                    else {
                        a1 = ((1 - visibleOpacity) * phi) / (1 - phi);
                    }
                    let backOp = (1 - a1) * (1 - visibleOpacity);
                    if (backOp > maxBackOpacity) {
                        a1 = 1 - maxBackOpacity / (1 - visibleOpacity);
                    }
                    if (opacity > a1) {
                        opacity = a1;
                    }
                    model.setPartsOpacity(partsIndex, opacity);
                }
            }
        });
    }
    copyOpacity(partsGroup) {
        const model = this.coreModel;
        partsGroup.forEach(({ partsIndex, link }) => {
            if (partsIndex >= 0 && link) {
                const opacity = model.getPartsOpacity(partsIndex);
                link.forEach(({ partsIndex }) => {
                    if (partsIndex >= 0) {
                        model.setPartsOpacity(partsIndex, opacity);
                    }
                });
            }
        });
    }
    update(dt) {
        this.partsGroups.forEach(partGroup => {
            this.normalizePartsOpacityGroup(partGroup, dt);
            this.copyOpacity(partGroup);
        });
    }
}

// EXTERNAL MODULE: ./src/factory/Live2DFactory.ts + 2 modules
var Live2DFactory = __webpack_require__(4);

// CONCATENATED MODULE: ./src/cubism2/factory.ts





Live2DFactory["a" /* Live2DFactory */].registerRuntime({
    version: 2,
    test(source) {
        return source instanceof Cubism2ModelSettings_Cubism2ModelSettings || Cubism2ModelSettings_Cubism2ModelSettings.isValidJSON(source);
    },
    ready() {
        return Promise.resolve();
    },
    isValidMoc(modelData) {
        if (modelData.byteLength < 3) {
            return false;
        }
        const view = new Int8Array(modelData, 0, 3);
        return String.fromCharCode(...view) === 'moc';
    },
    createModelSettings(json) {
        return new Cubism2ModelSettings_Cubism2ModelSettings(json);
    },
    createCoreModel(data) {
        const model = Live2DModelWebGL.loadModel(data);
        const error = Live2D.getError();
        if (error)
            throw error;
        return model;
    },
    createInternalModel(coreModel, settings, options) {
        return new Cubism2InternalModel_Cubism2InternalModel(coreModel, settings, options);
    },
    createPose(coreModel, data) {
        return new Live2DPose_Live2DPose(coreModel, data);
    },
    createPhysics(coreModel, data) {
        return new Live2DPhysics(coreModel, data);
    },
});

// CONCATENATED MODULE: ./src/cubism2/index.ts













/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__24__;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (!window.Live2D) {
    throw new Error('Cannot find Cubism 2 runtime. Did you forget to include the live2d.min.js?');
}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (!window.Live2DCubismCore) {
    throw new Error('Cannot find Cubism 4 runtime. Did you forget to include the live2dcubismcore.min.js?');
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LOGICAL_WIDTH", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LOGICAL_HEIGHT", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExpressionManager", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FocusController", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ModelSettings", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["l"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MotionPriority", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["o"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MotionState", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MotionPreloadStrategy", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["n"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MotionManager", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["m"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SoundManager", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["q"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InternalModel", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DModel", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["j"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DTransform", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InteractionMixin", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "config", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["w"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["r"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DFactory", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DLoader", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["s"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZipLoader", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["t"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["A"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["v"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["B"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyProperty", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["y"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArray", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["x"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyMixins", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["u"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "folderName", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["z"]; });

/* harmony import */ var _cubism2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism2ExpressionManager", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism2InternalModel", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism2ModelSettings", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism2MotionManager", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DExpression", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DEyeBlink", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DPhysics", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Live2DPose", function() { return _cubism2__WEBPACK_IMPORTED_MODULE_1__["h"]; });

/* harmony import */ var _cubism4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism4ExpressionManager", function() { return _cubism4__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism4ModelSettings", function() { return _cubism4__WEBPACK_IMPORTED_MODULE_2__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism4MotionManager", function() { return _cubism4__WEBPACK_IMPORTED_MODULE_2__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubism4InternalModel", function() { return _cubism4__WEBPACK_IMPORTED_MODULE_2__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubism4Ready", function() { return _cubism4__WEBPACK_IMPORTED_MODULE_2__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startUpCubism4", function() { return _cubism4__WEBPACK_IMPORTED_MODULE_2__["f"]; });






/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map